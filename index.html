<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoreGrid - Strategy Defense Game</title>
    <link rel="icon" href="./sprites/tower.png">
    <meta name="description"
        content="CoreGrid - a strategy game where you build and defend your base against waves of enemies">
    <meta name="keywords" content="grid, game, management, resource, online game, strategy game">
    <meta name="author" content="A_I_X">
    <meta name="theme-color" content="#121212">

    <style>
        :root {
            --bg-primary: #2b2b2b;
            --bg-secondary: #3a3a3a;
            --bg-tertiary: #404040;
            --border-color: #555;
            --text-primary: #e0e0e0;
            --text-secondary: #c0c0c0;
            --accent-primary: #66d9ff;
            --accent-secondary: #99ecff;
            --danger: #dd7e77;
            --success: #7a977b;
            --warning: #ceab77;
            --cell-size: 42px;
            --grid-gap: 6px;
            --border-radius: 4px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', sans-serif;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            padding: 30px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            max-width: 900px;
            width: 100%;
            text-align: center;
        }

        .game-header {
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--accent-primary);
            text-align: center;
            border-bottom: 4px solid var(--border-color);
            padding-bottom: 10px;
            letter-spacing: 1px;
        }

        .game-subtitle {
            color: var(--text-secondary);
            margin-bottom: 20px;
            text-align: center;
        }

        .ui-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding: 20px;
            background: #353535;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            box-shadow: 0 6px 0 rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .resources {
            display: flex;
            gap: 20px;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: var(--text-primary);
            padding: 10px 15px;
            background: #353535;
            border-radius: var(--border-radius);
            border: 2px solid #7a7a7a;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .resource img {
            width: 24px;
            height: 24px;
        }

        .controls-folder {
            display: flex;
            gap: 15px;
        }

        .folder {
            background: var(--bg-tertiary);
            border-radius: var(--border-radius);
            border: 3px solid #7a7a7a;
            min-width: 100px;
            position: relative;
            z-index: 100;
            transition: all 0.2s ease;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
            display: inline-block;
        }

        .folder:not(.open) .folder-content {
            display: none !important;
        }

        .folder-title {
            padding: 10px 12px;
            background: #353535;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #ddd;
            border-radius: var(--border-radius);
            border: 3px solid #7a7a7a;
            display: flex;
            align-items: center;
            gap: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: inset 0 -3px 0 rgba(0, 0, 0, 0.2);
            font-size: 12px;
            user-select: none;
        }

        .folder-title img {
            width: 24px;
            height: 24px;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
        }

        .folder-content {
            display: none;
            flex-direction: column;
            gap: 8px;
            padding: 0;
            position: fixed;
            background: var(--bg-tertiary);
            border-radius: var(--border-radius);
            border: 3px solid #7a7a7a;
            width: 200px;
            z-index: 1000;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
            min-width: 140px;
        }

        .folder-header {
            padding: 8px 12px;
            background: #3a3a3a;
            font-weight: bold;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid #7a7a7a;
            user-select: none;
        }

        .folder-header-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .folder-close {
            background: none;
            border: none;
            color: #ddd;
            cursor: pointer;
            font-size: 16px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }

        .folder-close:hover {
            background: #ff5555;
        }

        .folder-content.draggable {
            position: fixed;
        }

        .folder-buttons {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .folder.open .folder-content {
            display: block;
            animation: dropdownFade 0.2s ease;
        }

        @keyframes dropdownFade {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .folder-content .btn {
            width: 100%;
            height: auto;
            min-height: 50px;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            background-color: #353535;
            color: #ddd;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            font-size: 11px;
            text-align: left;
            padding: 6px 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .folder-content .btn:hover {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
            transform: translateX(5px);
        }

        .folder-content .btn img {
            width: 20px;
            height: 20px;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
            margin: 0;
            max-width: 20px;
            max-height: 20px;
        }

        .btn-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-right {
            display: flex;
            align-items: center;
        }

        .btn-left img {
            width: 20px;
            height: 20px;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .btn-left span {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .btn-right .lowcol {
            font-weight: bold;
            color: #aaa;
        }

        .btn {
            width: 100px;
            height: 80px;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            background-color: #353535;
            color: #ddd;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            font-size: 11px;
            text-align: center;
            padding: 5px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .info-icon {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 16px;
            height: 16px;
            background-color: #444;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: #ddd;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
            border: 1px solid #7a7a7a;
        }

        .btn:hover .info-icon {
            opacity: 1;
        }

        .info-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            padding: 15px;
            width: auto;
            min-width: 250px;
            max-width: 350px;
            z-index: 2000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
            font-size: 12px;
        }

        .info-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #555;
        }

        .info-popup-title {
            font-weight: bold;
            font-size: 14px;
            text-transform: uppercase;
        }

        .info-popup-close {
            background: none;
            border: none;
            color: #ddd;
            cursor: pointer;
            font-size: 18px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }

        .info-popup-close:hover {
            background: #ff5555;
        }

        .info-popup-content {
            font-size: 12px;
            line-height: 1.5;
        }

        .info-popup-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 10px 0;
        }

        .info-popup-stat {
            background: #444;
            padding: 5px 8px;
            border-radius: 3px;
            font-size: 11px;
            white-space: nowrap;
        }

        .info-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1999;
            display: none;
        }

        .btn:hover {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
            transform: translateY(-2px);
        }

        .btn img {
            width: 16px;
            height: 16px;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
            margin: 0 auto;
            max-width: 16px;
            max-height: 16px;
        }

        .btn.active {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
        }

        .btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn.disabled:hover {
            transform: none;
            background: var(--bg-tertiary);
        }

        .btn.researched {
            background-color: #7a977b;
            border-color: #5a775b;
        }

        .btn.researched:hover {
            background-color: #8aac8b;
            border-color: #6a8c6b;
        }

        .btn.available {
            background-color: #66d9ff;
            border-color: #46b9df;
            color: #111;
        }

        .btn.available:hover {
            background-color: #76e9ff;
            border-color: #56c9ef;
        }

        .game-grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(25, 1fr);
            grid-template-rows: repeat(15, 1fr);
            gap: var(--grid-gap);
            background: #353535;
            border: 2px solid #7a7a7a;
            padding: 15px;
            border-radius: var(--border-radius);
            justify-content: center;
            align-content: center;
            min-height: 650px;
            aspect-ratio: 25 / 15;
            box-shadow: 0 6px 0 rgba(0, 0, 0, 0.2);
        }

        .grid-cell {
            background: #2f811b;
            border: 3px solid #398d24;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #ccc;
            border-radius: var(--border-radius);
            aspect-ratio: 1 / 1;
        }

        .grid-cell:hover {
            background: #3ea326;
            border: 3px solid #4cb72f;
            transform: translateY(-2px);
            border-radius: var(--border-radius);
            z-index: 2;
        }

        .grid-cell.selected {
            box-shadow: 0 0 8px var(--accent-secondary);
            border-color: var(--accent-secondary);
            background: rgba(255, 215, 0, 0.2);
        }

        .grid-cell.valid-move {
            background: rgba(76, 175, 80, 0.3);
            border-color: var(--accent-primary);
            cursor: pointer;
        }

        .grid-cell.valid-attack {
            background: rgba(244, 67, 54, 0.3);
            border-color: var(--danger);
            cursor: crosshair;
        }

        .grid-cell.valid-attack:hover {
            background: rgba(244, 67, 54, 0.5);
        }

        .grid-cell .object-sprite {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            border-radius: 2px;
        }

        .grid-cell .object-sprite img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
        }

        .game-info {
            display: flex;
            gap: 25px;
            margin-bottom: 25px;
        }

        .turn-info,
        .wave-info {
            padding: 20px;
            background: #353535;
            border-radius: var(--border-radius);
            border: 2px solid #7a7a7a;
            text-align: center;
            color: var(--text-primary);
            flex: 1;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .info-panel {
            padding: 20px;
            background: #353535;
            border-radius: var(--border-radius);
            border: 2px solid #7a7a7a;
            text-align: left;
            color: var(--text-primary);
            margin-bottom: 25px;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .info-panel h3 {
            margin-bottom: 10px;
            color: var(--accent-primary);
            border-left: 5px solid var(--accent-primary);
            padding-left: 10px;
        }

        .info-panel p {
            color: var(--text-secondary);
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .floating-sidebar {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
            background: #353535;
            border-radius: var(--border-radius);
            border: 2px solid #7a7a7a;
            z-index: 1000;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        .control-btn {
            padding: 12px 20px;
            border: 2px solid #7a7a7a;
            background-color: #353535;
            color: #ddd;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .control-btn:hover {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
            transform: translateY(-2px);
        }

        .control-btn.primary {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
        }

        .control-btn.warning {
            background: var(--warning);
            color: white;
            border-color: #7a7a7a;
        }

        .health-bar {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            height: 3px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            border: 1px solid #555;
        }

        .health-fill {
            height: 100%;
            background: var(--success);
            transition: width 0.3s ease;
        }

        .notification {
            padding: 15px 20px;
            background: #353535;
            color: var(--text-primary);
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            animation: slideIn 0.3s ease;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
            width: 300px;
            margin-bottom: 10px;
        }

        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }

        .lowcol {
            color: #858585;
        }

        .card {
            background: #353535;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            padding: 25px;
            margin-bottom: 25px;
            transition: transform 0.15s ease, border-color 0.2s ease;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .card:hover {
            transform: scale(1.01);
            border-color: var(--accent-primary);
        }

        .card h2 {
            margin-bottom: 10px;
            color: #e8e8e8;
            font-size: 1.4rem;
        }

        .card p {
            color: var(--text-secondary);
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .text-section h2 {
            color: #eee;
            border-left: 5px solid var(--accent-primary);
            padding-left: 10px;
            margin-bottom: 15px;
        }

        .highlight {
            background-color: #353535;
            border: 2px solid #7a7a7a;
            padding: 20px;
            color: #ddd;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 25px 0;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #111111;
            color: #fff;
            text-align: left;
            border-radius: 4px;
            padding: 8px;
            position: absolute;
            z-index: 1001;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 11px;
            line-height: 1.4;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #303030 transparent transparent transparent;
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 0;
            pointer-events: none;
            opacity: 0;
        }

        .particle-effect {
            position: absolute;
            pointer-events: none;
            z-index: 999;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .folder-buttons .btn {
            position: relative;
        }

        .tech-tree-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #353535;
            border: 3px solid #7a7a7a;
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 1000px;
            height: 80vh;
            z-index: 2000;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .tech-tree-header {
            padding: 15px 20px;
            background: #3a3a3a;
            border-bottom: 2px solid #7a7a7a;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }

        .tech-tree-header h2 {
            margin: 0;
            color: var(--accent-primary);
            font-size: 1.5rem;
        }

        .tech-tree-close {
            background: none;
            border: none;
            color: #ddd;
            cursor: pointer;
            font-size: 24px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }

        .tech-tree-close:hover {
            background: #ff5555;
        }

        .tech-tree-content {
            padding: 25px;
            overflow: auto;
            flex-grow: 1;
            position: relative;
            background: #2b2b2b;
            min-height: 700px;
            background-image:
                radial-gradient(circle at 10px 10px, rgba(100, 100, 100, 0.1) 1px, transparent 0);
            background-size: 30px 30px;
            display: flex;
            flex-direction: column;
        }
        
        .tech-tree-main {
            flex-grow: 1;
            position: relative;
        }
        
        .tech-info-panel {
            background: #353535;
            border: 2px solid #7a7a7a;
            padding: 15px;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            z-index: 30;
            border-radius: var(--border-radius);
        }
        
        .tech-info-panel.hidden {
            opacity: 0.6;
        }
        
        .tech-info-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--accent-primary);
            margin-bottom: 8px;
        }
        
        .tech-info-description {
            color: var(--text-secondary);
            margin-bottom: 12px;
            line-height: 1.4;
            max-width: 80%;
        }
        
        .tech-info-cost {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .tech-cost-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
        }
        
        .tech-cost-steel { color: #aaa; }
        .tech-cost-coins { color: #d4af37; }
        .tech-cost-gold { color: #ffcc00; }
        .tech-cost-oil { color: #8B4513; }
        
        .tech-info-default {
            color: #888;
            font-style: italic;
        }

        .tech-tree-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1999;
            display: none;
        }

        .tech-node {
            position: absolute;
            width: 90px;
            height: 90px;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            background: linear-gradient(145deg, #3a3a3a, #2d2d2d);
            color: #ddd;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.15);
            text-align: center;
            z-index: 10;
            font-size: 12px;
            overflow: hidden;
        }

        .tech-node::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: #7a7a7a;
            border-radius: var(--border-radius) var(--border-radius) 0 0;
        }

        .tech-node:hover {
            transform: translateY(-5px) scale(1.15);
            z-index: 20;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border-color: var(--accent-primary);
            background: linear-gradient(145deg, #4a4a4a, #3a3a3a);
        }

        .tech-node.researched {
            background: linear-gradient(145deg, #7a977b, #6a876b);
            border-color: #5a775b;
        }

        .tech-node.researched::before {
            background: #5a775b;
        }

        .tech-node.available {
            background: linear-gradient(145deg, #66d9ff, #56c9ef);
            border-color: #46b9df;
            color: #111;
        }

        .tech-node.available::before {
            background: #46b9df;
        }

        .tech-node.available:hover {
            background: linear-gradient(145deg, #76e9ff, #66d9ff);
            border-color: #56c9ef;
        }

        .tech-node.locked {
            background: linear-gradient(145deg, #4a4a4a, #3a3a3a);
            border-color: #555;
            opacity: 1;
            cursor: not-allowed;
        }

        .tech-node.locked::before {
            background: #555;
        }

        .tech-node.locked:hover {
            transform: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border-color: #555;
        }

        .tech-tooltip {
            position: absolute;
            background: #66d9ff;
            outline: 3px solid #64d1f5;
            color: #111;
            padding: 8px 12px;
            border-radius: 4px 24px 24px 24px;
            font-size: 13px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transform: translate(0, 0);
        }

        .tech-node-icon {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.25);
            padding: 10px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .tech-node-icon img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .tech-node-name {
            display: none;
        }

        .tech-node-cost {
            display: none;
        }

        .tech-node-status {
            display: none;
        }

        .tech-node.researched .tech-node-status {
            background: #5a775b;
            color: #e0ffe0;
        }

        .tech-node.available .tech-node-status {
            background: #46b9df;
            color: #111;
        }

        .tech-node.locked .tech-node-status {
            background: #666;
            color: #bbb;
        }

        .tech-connection {
            position: absolute;
            background: #7a7a7a;
            transform-origin: 0 0;
            z-index: 5;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
            height: 4px;
        }

        .tech-connection.researched {
            background: #5a775b;
            box-shadow: 0 0 5px #5a775b;
        }

        .tech-connection.locked {
            background: #555;
            opacity: 0.6;
        }

        .building-info-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #353535;
            border: 3px solid #7a7a7a;
            border-radius: var(--border-radius);
            width: 400px;
            max-width: 90vw;
            height: auto;
            max-height: 80vh;
            z-index: 2000;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .building-info-header {
            padding: 15px 20px;
            background: #3a3a3a;
            border-bottom: 2px solid #7a7a7a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .building-info-header h2 {
            margin: 0;
            color: var(--accent-primary);
            font-size: 1.5rem;
        }

        .building-info-close {
            background: none;
            border: none;
            color: #ddd;
            cursor: pointer;
            font-size: 24px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }

        .building-info-close:hover {
            background: #ff5555;
        }

        .building-info-content {
            padding: 25px;
            overflow-y: auto;
            flex-grow: 1;
            background: #2b2b2b;
        }

        .building-icon-container {
            text-align: center;
            margin-bottom: 20px;
        }

        .building-icon {
            width: 64px;
            height: 64px;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .building-description {
            margin-bottom: 25px;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .module-slots-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .modules-locked-message {
            text-align: center;
            padding: 20px;
            background: #3a3a3a;
            border: 2px dashed #7a7a7a;
            border-radius: var(--border-radius);
            color: #aaa;
            font-style: italic;
        }
        
        .modules-locked-message strong {
            color: var(--warning);
            font-style: normal;
        }

        .module-slot {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #3a3a3a;
            border: 1px solid #7a7a7a;
            border-radius: var(--border-radius);
        }

        .module-slot-label {
            font-weight: bold;
            min-width: 80px;
        }

        .module-select {
            flex-grow: 1;
            padding: 8px;
            background: #353535;
            border: 1px solid #7a7a7a;
            border-radius: var(--border-radius);
            color: #ddd;
        }

        .equip-btn, .unequip-btn {
            padding: 8px 12px;
            border: 1px solid #7a7a7a;
            background-color: #353535;
            color: #ddd;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .equip-btn:hover {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
        }

        .unequip-btn:hover {
            background-color: var(--danger);
            color: #fff;
            border-color: var(--danger);
        }

        .building-info-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1999;
            display: none;
        }
        
        .module-slots-header {
            margin-bottom: 15px;
            text-align: center;
        }
        
        .module-slots-title {
            font-size: 16px;
            font-weight: bold;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .module-slots {
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        
        .module-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100px;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 8px;
            border-radius: var(--border-radius);
            border: 2px solid #7a7a7a;
            background: #3a3a3a;
            position: relative;
        }
        
        .module-slot:hover {
            background: #4a4a4a;
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }
        
        .module-slot.equipped {
            background: #4a5a4a;
            border-color: #66d9ff;
        }
        
        .module-slot-inner {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #5a5a5a;
            border-radius: var(--border-radius);
            background: #2d2d2d;
            position: relative;
            overflow: hidden;
        }
        
        .module-slot.equipped .module-slot-inner {
            background: #3d3d3d;
            border-color: #66d9ff;
        }
        
        .module-slot-icon {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .module-slot-icon img {
            width: 80%;
            height: 80%;
            object-fit: contain;
            image-rendering: pixelated;
        }
        
        .module-slot-empty .module-slot-icon {
            display: none;
        }
        
        .module-slot-tier {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 10px;
            font-weight: bold;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #7a7a7a;
        }
        
        .module-slot-label {
            margin-top: 8px;
            font-size: 12px;
            color: var(--text-secondary);
            text-align: center;
        }
        
        /* Module Selection Popup */
        .module-selection-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #353535;
            border: 3px solid #7a7a7a;
            border-radius: var(--border-radius);
            width: 350px;
            max-width: 90vw;
            max-height: 80vh;
            z-index: 2001;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            overflow: hidden;
            animation: popupFadeIn 0.3s ease;
        }
        
        @keyframes popupFadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        .module-selection-header {
            padding: 15px 20px;
            background: #3a3a3a;
            border-bottom: 2px solid #7a7a7a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .module-selection-header span {
            color: var(--accent-primary);
            font-size: 1.2rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .module-close-btn {
            background: none;
            border: none;
            color: #ddd;
            cursor: pointer;
            font-size: 24px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }
        
        .module-close-btn:hover {
            background: #ff5555;
        }
        
        .module-options {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .module-options::-webkit-scrollbar {
            width: 8px;
        }
        
        .module-options::-webkit-scrollbar-track {
            background: #2a2a2a;
            border-radius: 4px;
        }
        
        .module-options::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }
        
        .module-options::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
        
        .module-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #3a3a3a;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .module-option:hover {
            background: var(--accent-primary);
            border-color: var(--accent-secondary);
            color: #111;
            transform: translateX(5px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .module-option.unaffordable {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .module-option.unaffordable:hover {
            background: #3a3a3a;
            border-color: #7a7a7a;
            color: #ddd;
            transform: none;
        }
        
        .module-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.25);
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 4px;
        }
        
        .module-icon img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
        }
        
        .module-info {
            flex-grow: 1;
        }
        
        .module-name {
            font-weight: bold;
            margin-bottom: 4px;
        }
        
        .module-cost {
            font-size: 14px;
            color: #ceab77;
            font-weight: bold;
        }
        
        .module-cost[data-resource="iron"]::before {
            content: "IRON ";
            color: #aaa;
            font-weight: normal;
        }
        
        .module-selection-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            display: none;
        }
    </style>
</head>

<body>
    <div class="game-container">

        <div class="ui-panel">
            <div class="resources">
                <div class="resource">
                    <img src="./sprites/ironin.png" alt="Steel">
                    <span id="steel-count">100</span>
                </div>
                <div class="resource">
                    <img src="./sprites/coin.png" alt="Coins">
                    <span id="coin-count">50</span>
                </div>
                <div class="resource">
                    <img src="./sprites/goldin.png" alt="Gold">
                    <span id="gold-count">25</span>
                </div>
                <div class="resource">
                    <img src="./sprites/Oil.png" alt="Oil">
                    <span id="oil-count">0</span>
                </div>
            </div>

            <div class="controls-folder">
                <div class="folder" data-folder>
                    <div class="folder-title">
                        <img src="./sprites/wall.png" alt="Walls"> Walls
                    </div>
                    <div class="folder-content">
                        <div class="folder-header">
                            <div class="folder-header-title">Walls</div>
                            <button class="folder-close">×</button>
                        </div>
                        <div class="folder-buttons">
                            <button class="btn" id="place-wall"
                                data-info="Wall,Basic defensive structure to block enemy movement,Health: 1">
                                <div class="btn-left">
                                    <img src="./sprites/wall.png" alt="Wall">
                                    <span>Wall</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">10S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-steel-wall"
                                data-info="Steel Wall,Stronger wall with increased durability,Health: 3,Requires: Advanced Defense">
                                <div class="btn-left">
                                    <img src="./sprites/wallsteel.png" alt="Steel Wall">
                                    <span>Steel</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">20S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-spike"
                                data-info="Spike,Damages enemies that walk over it,Health: 3,Requires: Spike Traps">
                                <div class="btn-left">
                                    <img src="./sprites/spike.png" alt="Spike">
                                    <span>Spike</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">15S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-fortress"
                                data-info="Fortress,Your main base that must be protected,Health: 5,Requires: Fortress">
                                <div class="btn-left">
                                    <img src="./sprites/spawn.png" alt="Fortress">
                                    <span>Fortress</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">25G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                        </div>
                    </div>
                </div>

                <div class="folder" data-folder>
                    <div class="folder-title">
                        <img src="./sprites/turret.png" alt="Tech"> Tech
                    </div>
                    <div class="folder-content">
                        <div class="folder-header">
                            <div class="folder-header-title">Tech</div>
                            <button class="folder-close">×</button>
                        </div>
                        <div class="folder-buttons">
                            <button class="btn" id="place-tech"
                                data-info="Steel Mine,Generates 5 steel per turn,Health: 2,Requires: Fortress">
                                <div class="btn-left">
                                    <img src="./sprites/iron.png" alt="Steel Mine">
                                    <span>Steel Mine</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">20S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-gold-miner"
                                data-info="Gold Mine,Generates 1 gold per turn,Health: 2,Requires: Advanced Mining">
                                <div class="btn-left">
                                    <img src="./sprites/gold.png" alt="Gold Mine">
                                    <span>Gold Mine</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">25S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-coin-maker"
                                data-info="Bank,Generates 5 coins per turn,Health: 2,Requires: Advanced Mining">
                                <div class="btn-left">
                                    <img src="./sprites/bank.png" alt="Bank">
                                    <span>Bank</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">30S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-turret"
                                data-info="Turret,Attacks enemies within range 3,Health: 2,Shots: 8,Requires: Fortress">
                                <div class="btn-left">
                                    <img src="./sprites/turret.png" alt="Turret">
                                    <span>Turret</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">40S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-gold-turret"
                                data-info="Gold Turret,Powerful turret with range 3,Health: 2,Shots: 10,Requires: Fortified Defense">
                                <div class="btn-left">
                                    <img src="./sprites/goldturret.png" alt="Gold Turret">
                                    <span>Gold Turret</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">200G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-bomb"
                                data-info="Bomb,Explodes when enemy approaches damaging area,Health: 1,Requires: Spike Traps">
                                <div class="btn-left">
                                    <img src="./sprites/bomb.png" alt="Bomb">
                                    <span>Bomb</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">10G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-supply"
                                data-info="Supply Drop,Randomly generates resources,Health: 1,Requires: Supply Systems">
                                <div class="btn-left">
                                    <img src="./sprites/supply.gif" alt="Supply Drop">
                                    <span>Supply Drop</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">35G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-oil-rig"
                                data-info="Oil Rig,Generates 1 oil per turn,Health: 2,Requires: Oil Rig Tech">
                                <div class="btn-left">
                                    <img src="./sprites/oilrig.png" alt="Oil Rig">
                                    <span>Oil Rig</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">35S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-campfire"
                                data-info="Campfire,Boosts nearby resource buildings by 50%,Health: 1,Requires: Resource Management">
                                <div class="btn-left">
                                    <img src="./sprites/campfire.gif" alt="Campfire">
                                    <span>Campfire</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">30S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                        </div>
                    </div>
                </div>

                <div class="folder" data-folder>
                    <div class="folder-title">
                        <img src="./sprites/Tank.png" alt="Army"> Army
                    </div>
                    <div class="folder-content">
                        <div class="folder-header">
                            <div class="folder-header-title">Army</div>
                            <button class="folder-close">×</button>
                        </div>
                        <div class="folder-buttons">
                            <button class="btn" id="place-scout"
                                data-info="Soldier,Basic unit with balanced stats,Health: 1,Range: 1,Movement: 1,Requires: Fortress">
                                <div class="btn-left">
                                    <img src="./sprites/soldier.png" alt="Soldier">
                                    <span>Soldier</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">15C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-knight"
                                data-info="Knight,Fast-moving unit with high mobility,Health: 1,Range: 1,Movement: 5,Requires: Basic Army">
                                <div class="btn-left">
                                    <img src="./sprites/knight.png" alt="Knight">
                                    <span>Knight</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">25C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-archer"
                                data-info="Archer,Ranged unit that can attack from a distance,Health: 1,Range: 4,Movement: 1,Requires: Basic Army">
                                <div class="btn-left">
                                    <img src="./sprites/Archer.png" alt="Archer">
                                    <span>Archer</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">20C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-tank"
                                data-info="Tank,Heavy unit with high health,Health: 5,Range: 1,Movement: 1,Requires: Elite Units">
                                <div class="btn-left">
                                    <img src="./sprites/Tank.png" alt="Tank">
                                    <span>Tank</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">50C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-siege-tower"
                                data-info="Siege Tower,Powerful siege unit with long range,Health: 1,Range: 4,Movement: 1,Requires: Siege Weapons">
                                <div class="btn-left">
                                    <img src="./sprites/siegetower.png" alt="Siege Tower">
                                    <span>Siege Tower</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">275C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-king"
                                data-info="King,Command unit that boosts nearby army,Health: 25,Range: 2,Movement: 2,Requires: Elite Units">
                                <div class="btn-left">
                                    <img src="./sprites/king.png" alt="King">
                                    <span>King</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">500G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-barrack"
                                data-info="Barrack,Automatically spawns soldier units,Health: 2,Requires: Advanced Army">
                                <div class="btn-left">
                                    <img src="./sprites/barrack.png" alt="Barrack">
                                    <span>Barrack</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">50G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="tech-tree-popup" id="tech-tree-popup">
            <div class="tech-tree-header">
                <h2>Tech Tree</h2>
                <button class="tech-tree-close" id="tech-tree-close">×</button>
            </div>
            <div class="tech-tree-content" id="tech-tree-content">
                <div class="tech-tree-main" id="tech-tree-main"></div>
                <div class="tech-info-panel" id="tech-info-panel">
                    <div class="tech-info-default">Hover over a technology to see details</div>
                </div>
            </div>
        </div>

        <div class="tech-tree-overlay" id="tech-tree-overlay"></div>

        <!-- Building Information Window -->
        <div class="building-info-popup" id="building-info-popup">
            <div class="building-info-header">
                <div class="building-info-title" id="building-info-title">Building Name</div>
                <button class="building-info-close" id="building-info-close">×</button>
            </div>
            <div class="building-info-content">
                <div class="building-icon-container">
                    <img class="building-icon" id="building-icon" src="./sprites/turret.png" alt="Building Icon">
                </div>
                <div class="building-description" id="building-description">Building description goes here.</div>
                <div class="module-slots-container">
                    <div class="module-slots-header">
                        <span class="module-slots-title">Modules</span>
                    </div>
                    <div class="module-slots">
                        <div class="module-slot" id="module-slot-1" data-slot="1">
                            <div class="module-slot-inner">
                                <div class="module-slot-icon"></div>
                                <div class="module-slot-tier"></div>
                            </div>
                            <div class="module-slot-label">Slot 1</div>
                        </div>
                        <div class="module-slot" id="module-slot-2" data-slot="2">
                            <div class="module-slot-inner">
                                <div class="module-slot-icon"></div>
                                <div class="module-slot-tier"></div>
                            </div>
                            <div class="module-slot-label">Slot 2</div>
                        </div>
                    </div>
                </div>
                
                <!-- Module Selection Popup -->
                <div class="module-selection-popup" id="module-selection-popup">
                    <div class="module-selection-header">
                        <span>Select Module</span>
                        <button class="module-close-btn" id="module-close-btn">×</button>
                    </div>
                    <div class="module-options">
                        <div class="module-option" data-module="speed" data-tier="1">
                            <div class="module-icon">
                                <img src="./sprites/speedmod.png" alt="Speed Module">
                            </div>
                            <div class="module-info">
                                <div class="module-name">Speed Module (T1)</div>
                                <div class="module-cost" data-resource="iron">145</div>
                            </div>
                        </div>
                        <div class="module-option" data-module="speed" data-tier="2">
                            <div class="module-icon">
                                <img src="./sprites/speedmod.png" alt="Speed Module">
                            </div>
                            <div class="module-info">
                                <div class="module-name">Speed Module (T2)</div>
                                <div class="module-cost" data-resource="iron">290</div>
                            </div>
                        </div>
                        <div class="module-option" data-module="speed" data-tier="3">
                            <div class="module-icon">
                                <img src="./sprites/speedmod.png" alt="Speed Module">
                            </div>
                            <div class="module-info">
                                <div class="module-name">Speed Module (T3)</div>
                                <div class="module-cost" data-resource="iron">580</div>
                            </div>
                        </div>
                        <div class="module-option" data-module="defense" data-tier="1">
                            <div class="module-icon">
                                <img src="./sprites/defensemod.png" alt="Defense Module">
                            </div>
                            <div class="module-info">
                                <div class="module-name">Defense Module (T1)</div>
                                <div class="module-cost" data-resource="iron">50</div>
                            </div>
                        </div>
                        <div class="module-option" data-module="defense" data-tier="2">
                            <div class="module-icon">
                                <img src="./sprites/defensemod.png" alt="Defense Module">
                            </div>
                            <div class="module-info">
                                <div class="module-name">Defense Module (T2)</div>
                                <div class="module-cost" data-resource="iron">100</div>
                            </div>
                        </div>
                        <div class="module-option" data-module="defense" data-tier="3">
                            <div class="module-icon">
                                <img src="./sprites/defensemod.png" alt="Defense Module">
                            </div>
                            <div class="module-info">
                                <div class="module-name">Defense Module (T3)</div>
                                <div class="module-cost" data-resource="iron">200</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="module-selection-overlay" id="module-selection-overlay"></div>
            </div>
        </div>
        <div class="building-info-overlay" id="building-info-overlay"></div>

        <div class="game-grid-container">
            <div class="game-grid" id="game-grid"></div>
        </div>

        <div class="game-info">
            <div class="turn-info">
                <h3>Information</h3>
                <p>Turn: <span id="turn-count">1</span></p>
                <p id="turn-instructions"></p>
            </div>
            <div class="wave-info">
                <h3>Wave Information</h3>
                <p>Wave: <span id="wave-count">1</span></p>
                <p id="wave-status">Enemies remaining: <span id="enemies-remaining">3</span></p>
            </div>
        </div>

        <div class="info-panel">
            <h3>Game Instructions</h3>
            <p><strong>Combat:</strong> Move your army units into enemy squares to attack! Different units have
                different movement ranges and attacks.</p>
            <p><strong>Defense:</strong> Use walls and fortresses to protect your units and resources.</p>
            <p><strong>Resources:</strong> Place miner buildings to generate resources.</p>
            <p><strong>Waves:</strong> Defend against waves of different enemies.</p>
            <p><strong>Modules:</strong> Upgrade your buildings with modules for increased speed and defense. Try clicking on buildings to add modules!</p>
        </div>

        <div class="floating-sidebar">
            <h1 class="game-title">CoreGrid</h1>
            <p class="game-subtitle">Build, Defend, and Conquer</p>
            <button class="control-btn" id="save-game">Save Game</button>
            <button class="control-btn" id="load-game">Load Game</button>
            <button class="control-btn" id="restart-game">Restart Game</button>
            <button class="control-btn" id="tech-tree-button">Research</button>
        </div>
    </div>

    <script>
        const CONFIG = {
            GRID_SIZE_X: 25,
            GRID_SIZE_Y: 15,
            PLAYER_START: { x: 12, y: 7 },
            WAVE_BREAK_TURNS: 3,
            INITIAL_RESOURCES: {
                Steel: 100,
                coins: 50,
                gold: 25,
                oil: 0
            },
            SPRITES: {
                player: './sprites/spawn.png',
                wall: {
                    stone: './sprites/wall.png',
                    steel: './sprites/wallsteel.png',
                    spike: './sprites/spike.png',
                    fortress: './sprites/spawn.png'
                },
                tech: {
                    miner: './sprites/iron.png',
                    goldminer: './sprites/gold.png',
                    coinmaker: './sprites/bank.png',
                    oilrig: './sprites/oilrig.png',
                    turret: './sprites/turret.png',
                    goldturret: './sprites/goldturret.png',
                    bomb: './sprites/bomb.png',
                    supply: './sprites/supply.gif',
                    campfire: './sprites/campfire.gif'
                },
                army: {
                    scout: './sprites/soldier.png',
                    knight: './sprites/knight.png',
                    archer: './sprites/Archer.png',
                    tank: './sprites/Tank.png',
                    king: './sprites/king.png',
                    barrack: './sprites/barrack.png',
                    siegetower: './sprites/siegetower.png'
                },
                enemy: {
                    basic: './sprites/defaultbad.png',
                    fast: './sprites/badfast.png',
                    tank: './sprites/badheavy.png',
                    ranged: './sprites/badarcher.png',
                    healer: './sprites/badhealer.png'
                }
            }
        }
        
        // Load TECH_TREE and positions from external JSON file
        CONFIG.TECH_TREE = {};
        let NODE_POSITIONS = {};
        
        // Function to load tech tree and positions from external file
        async function loadTechTree() {
            try {
                // First check if we can fetch the file
                console.log('Attempting to load tech tree...');
                
                const response = await fetch('tech-tree-full.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const text = await response.text();
                console.log('Raw response text:', text.substring(0, 200));
                
                try {
                    const fullData = JSON.parse(text);
                    
                    // Load tech tree data
                    CONFIG.TECH_TREE = fullData.tech_tree;
                    
                    // Load positions data
                    NODE_POSITIONS = fullData.positions;
                    
                    console.log('Tech tree loaded successfully. Nodes:', Object.keys(CONFIG.TECH_TREE).length);
                    console.log('Positions loaded:', Object.keys(NODE_POSITIONS).length);
                    
                    // Update tech tree display if it's available
                    if (typeof updateTechTreeDisplay === 'function') {
                        updateTechTreeDisplay();
                    }
                    
                } catch (parseError) {
                    console.error('Error parsing JSON:', parseError);
                    throw new Error('Invalid JSON format in tech tree file');
                }
                
            } catch (error) {
                console.error('Error loading tech tree:', error);
                
                // Fallback: use minimal data to ensure the game works
                console.log('Using fallback tech tree data');
                CONFIG.TECH_TREE = {
                    'fortress': {
                        name: 'Fortress',
                        description: 'Your main base that must be protected',
                        cost: { Steel: 0 },
                        tier: 0,
                        prerequisites: [],
                        unlocks: ['basic_defense', 'basic_army', 'module_research'],
                        icon: 'spawn.png'
                    },
                    'module_research': {
                        name: 'Module Research',
                        description: 'Unlocks the ability to research specialized modules',
                        cost: { Steel: 150, gold: 75 },
                        tier: 2,
                        prerequisites: ['fortress'],
                        unlocks: ['speed_module', 'defense_module'],
                        icon: 'research.png'
                    }
                };
                
                NODE_POSITIONS = {
                    'fortress': { x: 400, y: 30 },
                    'module_research': { x: 400, y: 120 }
                };
                
                // Initialize the tech tree display
                if (typeof updateTechTreeDisplay === 'function') {
                    updateTechTreeDisplay();
                }
            }
        }
        

        class GameState {
            constructor() {
                this.reset();
            }

            reset() {
                if (window.waveBreakTimeout) {
                    clearTimeout(window.waveBreakTimeout);
                    window.waveBreakTimeout = null;
                }

                this.resources = { ...CONFIG.INITIAL_RESOURCES };
                this.turn = 1;
                this.selectedUnit = null;
                this.placementMode = null;

                this.cameraOffset = { x: 0, y: 0 };
                this.worldObjects = new Map();
                this.grid = Array(CONFIG.GRID_SIZE_Y).fill().map(() => Array(CONFIG.GRID_SIZE_X).fill(null));
                this.objects = new Map();
                this.wave = 1;
                this.waveBreakTurns = 0;
                this.inWaveBreak = false;
                this.enemiesRemaining = 0;
                this.researchedTechs = new Set();
                this.availableTechs = new Set();
                
                // Automatically research 'fortress' at the start since it's the base tech
                if (CONFIG.TECH_TREE.fortress) {
                    this.researchedTechs.add('fortress');
                }
                
                this.updateAvailableTechs();
            }

            canAfford(cost) {
                return this.resources.Steel >= (cost.Steel || 0) &&
                    this.resources.coins >= (cost.coins || 0) &&
                    this.resources.gold >= (cost.gold || 0) &&
                    this.resources.oil >= (cost.oil || 0);
            }

            spendResources(cost) {
                if (cost.Steel) this.resources.Steel -= cost.Steel;
                if (cost.coins) this.resources.coins -= cost.coins;
                if (cost.gold) this.resources.gold -= cost.gold;
                if (cost.oil) this.resources.oil -= cost.oil;
            }

            addResources(resources) {
                if (resources.Steel) this.resources.Steel += resources.Steel;
                if (resources.coins) this.resources.coins += resources.coins;
                if (resources.gold) this.resources.gold += resources.gold;
                if (resources.oil) this.resources.oil += resources.oil;
            }

            isTechResearched(techId) {
                return this.researchedTechs.has(techId);
            }

            canResearchTech(techId) {
                const tech = CONFIG.TECH_TREE[techId];
                if (!tech) return false;
                if (this.isTechResearched(techId)) return false;

                return tech.prerequisites.every(prereq => this.isTechResearched(prereq)) &&
                    this.canAfford(tech.cost);
            }

            researchTech(techId) {
                if (!this.canResearchTech(techId)) return false;

                const tech = CONFIG.TECH_TREE[techId];
                this.spendResources(tech.cost);
                this.researchedTechs.add(techId);
                this.updateAvailableTechs();
                return true;
            }

            updateAvailableTechs() {
                this.availableTechs.clear();
                for (const techId in CONFIG.TECH_TREE) {
                    const tech = CONFIG.TECH_TREE[techId];
                    if (!this.isTechResearched(techId) &&
                        tech.prerequisites.every(prereq => this.isTechResearched(prereq))) {
                        this.availableTechs.add(techId);
                    }
                }
            }

            getResourceMultiplier() {
                let multiplier = 1.0;
                if (this.isTechResearched('advanced_mining')) {
                    multiplier += 0.25;
                }
                if (this.isTechResearched('premium_mining')) {
                    multiplier += 0.5;
                }
                return multiplier;
            }

            countEnemies() {
                let count = 0;
                this.worldObjects.forEach(obj => {
                    if (obj.type === 'enemy') count++;
                });
                console.log(`countEnemies: calculated ${count}, previous value was ${this.enemiesRemaining}`);
                this.enemiesRemaining = count;
                return count;
            }
        }

        class GameObject {
            constructor(x, y, type, subtype) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.subtype = subtype;
                this.id = `${type}_${subtype}_${x}_${y}_${Date.now()}`;
                this.modules = [];
                this.originalHealth = null;
                this.originalMaxHealth = null;
                this.originalRange = null;
                this.originalShotsLeft = null;
                this.originalMovement = null;
            }

            getSprite() {
                return CONFIG.SPRITES[this.type]?.[this.subtype] || 'sprites/missing.png';
            }

            addModule(moduleType) {
                if (this.modules.length >= 2) return false;
                if (this.modules.includes(moduleType)) return false;
                
                this.modules.push(moduleType);
                this.applyModuleEffect(moduleType);
                return true;
            }

            removeModule(moduleType) {
                const index = this.modules.indexOf(moduleType);
                if (index === -1) return false;
                
                this.modules.splice(index, 1);
                this.removeModuleEffect(moduleType);
                return true;
            }

            applyModuleEffect(moduleType) {
                // Extract the base module type if it includes a tier (e.g., 'speed-2' -> 'speed')
                const baseModuleType = moduleType.includes('-') ? moduleType.split('-')[0] : moduleType;
                
                // Determine the tier multiplier (default to 1 if no tier specified)
                const tier = moduleType.includes('-') ? parseInt(moduleType.split('-')[1]) : 1;
                const multiplier = tier + 1; // Tier 1 = 2x, Tier 2 = 3x, Tier 3 = 4x
                
                if (baseModuleType === 'speed') {
                    // Apply speed effect with tier-based multiplier
                    if (this.type === 'army') {
                        if (this.originalMovement === null) {
                            this.originalMovement = this.movement;
                        }
                        this.movement = this.originalMovement * multiplier;
                    } else if (this.type === 'tech') {
                        // For turrets, multiply shots
                        if (this.subtype === 'turret' || this.subtype === 'goldturret') {
                            if (this.originalShotsLeft === null) {
                                this.originalShotsLeft = this.shotsLeft;
                            }
                            this.shotsLeft = this.originalShotsLeft * multiplier;
                        }
                        // For resource buildings, multiplier would be handled in their onTurn method
                    }
                } else if (baseModuleType === 'defense') {
                    // Apply defense effect with tier-based multiplier
                    if (this.originalHealth === null) {
                        this.originalHealth = this.health;
                        this.originalMaxHealth = this.maxHealth;
                    }
                    this.health = this.originalHealth * multiplier;
                    this.maxHealth = this.originalMaxHealth * multiplier;
                }
            }

            removeModuleEffect(moduleType) {
                // Extract the base module type if it includes a tier (e.g., 'speed-2' -> 'speed')
                const baseModuleType = moduleType.includes('-') ? moduleType.split('-')[0] : moduleType;
                
                // Determine the tier multiplier (default to 1 if no tier specified)
                const tier = moduleType.includes('-') ? parseInt(moduleType.split('-')[1]) : 1;
                const multiplier = tier + 1; // Tier 1 = 2x, Tier 2 = 3x, Tier 3 = 4x
                
                if (baseModuleType === 'speed') {
                    if (this.type === 'army') {
                        if (this.originalMovement !== null) {
                            // Revert to original movement value
                            this.movement = this.originalMovement;
                        }
                    } else if (this.type === 'tech') {
                        if (this.subtype === 'turret' || this.subtype === 'goldturret') {
                            if (this.originalShotsLeft !== null) {
                                // Revert to original shots value
                                this.shotsLeft = this.originalShotsLeft;
                            }
                        }
                    }
                } else if (baseModuleType === 'defense') {
                    if (this.originalHealth !== null && this.originalMaxHealth !== null) {
                        // Revert to original health values
                        this.health = this.originalHealth;
                        this.maxHealth = this.originalMaxHealth;
                    }
                }
            }

            getModuleBonus() {
                return {
                    speed: this.modules.filter(m => m && m.startsWith('speed')).length,
                    defense: this.modules.filter(m => m && m.startsWith('defense')).length
                };
            }
            
            getSpeedModuleTiers() {
                const speedModules = this.modules.filter(m => m && m.startsWith('speed'));
                return speedModules.map(module => {
                    const parts = module.split('-');
                    return parts.length > 1 ? parseInt(parts[1]) : 1;
                });
            }
            
            getDefenseModuleTiers() {
                const defenseModules = this.modules.filter(m => m && m.startsWith('defense'));
                return defenseModules.map(module => {
                    const parts = module.split('-');
                    return parts.length > 1 ? parseInt(parts[1]) : 1;
                });
            }
        }

        class Wall extends GameObject {
            constructor(x, y, subtype = 'stone') {
                super(x, y, 'wall', subtype);
                this.health = this.getMaxHealth();
                this.maxHealth = this.health;
                this.blocksMovement = true;
            }

            getMaxHealth() {
                switch (this.subtype) {
                    case 'steel': return 3;
                    case 'spike': return 3;
                    case 'fortress': return 5;
                    default: return 1;
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        class Tech extends GameObject {
            constructor(x, y, subtype = 'miner') {
                super(x, y, 'tech', subtype);
                this.cost = this.getCost();
                this.health = 2;
                this.maxHealth = 2;

                if (subtype === 'turret') {
                    this.shotsLeft = 8;
                    this.range = 3;
                } else if (subtype === 'goldturret') {
                    this.shotsLeft = 10;
                    this.range = 3;
                }
            }

            getCost() {
                const costs = {
                    miner: { Steel: 20 },
                    goldminer: { Steel: 25 },
                    coinmaker: { Steel: 30 },
                    oilrig: { Steel: 35 },
                    turret: { Steel: 40 },
                    goldturret: { gold: 200 },
                    bomb: { gold: 10 },
                    supply: { gold: 35 },
                    campfire: { Steel: 30 }
                };
                return costs[this.subtype] || { Steel: 20 };
            }

            onTurn() {
                const multiplier = gameState.getResourceMultiplier();

                const campfireBonus = 1 + (0.5 * this.getNearbyCampfires());
                
                // Calculate module bonus for speed (with tier multipliers)
                const speedModuleTiers = this.getSpeedModuleTiers();
                const speedModuleMultiplier = speedModuleTiers.reduce((total, tier) => total + (tier + 1), 1); // Base is 1, each tier adds (tier + 1)

                switch (this.subtype) {
                    case 'miner':
                        gameState.addResources({ Steel: Math.floor(5 * campfireBonus * multiplier * speedModuleMultiplier) });
                        createResourceCollectionEffect(this.x, this.y, 'Steel');
                        break;
                    case 'goldminer':
                        gameState.addResources({ gold: Math.ceil(1 * campfireBonus * multiplier * speedModuleMultiplier) });
                        createResourceCollectionEffect(this.x, this.y, 'gold');
                        break;
                    case 'coinmaker':
                        gameState.addResources({ coins: Math.floor(5 * campfireBonus * multiplier * speedModuleMultiplier) });
                        createResourceCollectionEffect(this.x, this.y, 'coins');
                        break;
                    case 'oilrig':
                        gameState.addResources({ oil: Math.ceil(1 * campfireBonus * multiplier * speedModuleMultiplier) });
                        createResourceCollectionEffect(this.x, this.y, 'oil');
                        break;
                    case 'supply':
                        this.handleSupplyDrop();
                        break;
                    case 'turret':
                    case 'goldturret':
                        // Attack multiple times based on speed module tiers
                        const speedModuleTiers = this.getSpeedModuleTiers();
                        const attacksPerTurn = speedModuleTiers.reduce((total, tier) => total + (tier + 1), 1); // Base is 1, each tier adds (tier + 1)
                        for (let i = 0; i < attacksPerTurn; i++) {
                            if (this.shotsLeft > 0) {
                                this.attackNearbyEnemies();
                            }
                        }
                        break;
                    case 'bomb':
                        this.handleBomb();
                        break;
                }
            }

            getNearbyCampfires() {
                let count = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const worldX = this.x + dx;
                        const worldY = this.y + dy;

                        const gridX = worldX - gameState.cameraOffset.x;
                        const gridY = worldY - gameState.cameraOffset.y;

                        if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X && gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                            const obj = gameState.grid[gridY][gridX];
                            if (obj && obj.type === 'tech' && obj.subtype === 'campfire') {
                                count++;
                            }
                        }
                    }
                }
                return count;
            }

            handleSupplyDrop() {
                if (Math.random() < 0.33) {
                    const resources = ['coins', 'Steel', 'gold'];
                    const resource = resources[Math.floor(Math.random() * resources.length)];
                    const amount = 5 + Math.floor(Math.random() * 6);
                    gameState.addResources({ [resource]: amount });
                    showNotification(`+${amount} ${resource} from Supply Drop!`, this.x, this.y);
                    createResourceCollectionEffect(this.x, this.y, resource);
                }
            }

            attackNearbyEnemies() {
                if (this.shotsLeft <= 0) return false;

                for (let dy = -this.range; dy <= this.range; dy++) {
                    for (let dx = -this.range; dx <= this.range; dx++) {
                        if (Math.max(Math.abs(dx), Math.abs(dy)) > this.range) continue;
                        const worldX = this.x + dx;
                        const worldY = this.y + dy;

                        const gridX = worldX - gameState.cameraOffset.x;
                        const gridY = worldY - gameState.cameraOffset.y;

                        if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X && gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                            const target = gameState.grid[gridY][gridX];
                            if (target && target.type === 'enemy') {
                                if (gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y &&
                                    gridX >= 0 && gridX < CONFIG.GRID_SIZE_X) {
                                    gameState.grid[gridY][gridX] = null;
                                }

                                gameState.objects.delete(target.id);
                                gameState.worldObjects.delete(target.id);
                                this.shotsLeft--;
                                if (this.shotsLeft <= 0) {
                                    const selfGridX = this.x - gameState.cameraOffset.x;
                                    const selfGridY = this.y - gameState.cameraOffset.y;
                                    if (selfGridY >= 0 && selfGridY < CONFIG.GRID_SIZE_Y &&
                                        selfGridX >= 0 && selfGridX < CONFIG.GRID_SIZE_X) {
                                        gameState.grid[selfGridY][selfGridX] = null;
                                    }

                                    gameState.objects.delete(this.id);
                                    gameState.worldObjects.delete(this.id);
                                }
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            handleBomb() {
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const worldX = this.x + dx;
                        const worldY = this.y + dy;

                        const gridX = worldX - gameState.cameraOffset.x;
                        const gridY = worldY - gameState.cameraOffset.y;

                        if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X && gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                            const target = gameState.grid[gridY][gridX];
                            if (target && target.type === 'enemy') {
                                for (let dy2 = -2; dy2 <= 2; dy2++) {
                                    for (let dx2 = -2; dx2 <= 2; dx2++) {
                                        const worldX2 = this.x + dx2;
                                        const worldY2 = this.y + dy2;

                                        const gridX2 = worldX2 - gameState.cameraOffset.x;
                                        const gridY2 = worldY2 - gameState.cameraOffset.y;

                                        if (gridX2 >= 0 && gridX2 < CONFIG.GRID_SIZE_X && gridY2 >= 0 && gridY2 < CONFIG.GRID_SIZE_Y) {
                                            const target2 = gameState.grid[gridY2][gridX2];
                                            if (target2 && target2.type === 'enemy') {
                                                if (gridY2 >= 0 && gridY2 < CONFIG.GRID_SIZE_Y &&
                                                    gridX2 >= 0 && gridX2 < CONFIG.GRID_SIZE_X) {
                                                    gameState.grid[gridY2][gridX2] = null;
                                                }

                                                gameState.objects.delete(target2.id);
                                                gameState.worldObjects.delete(target2.id);
                                            }
                                        }
                                    }
                                }

                                const selfGridX = this.x - gameState.cameraOffset.x;
                                const selfGridY = this.y - gameState.cameraOffset.y;
                                if (selfGridY >= 0 && selfGridY < CONFIG.GRID_SIZE_Y &&
                                    selfGridX >= 0 && selfGridX < CONFIG.GRID_SIZE_X) {
                                    gameState.grid[selfGridY][selfGridX] = null;
                                }

                                gameState.objects.delete(this.id);
                                gameState.worldObjects.delete(this.id);
                                return;
                            }
                        }
                    }
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        class Army extends GameObject {
            constructor(x, y, subtype = 'scout') {
                super(x, y, 'army', subtype);
                this.cost = this.getCost();
                this.health = this.getMaxHealth();
                this.maxHealth = this.health;
                this.range = this.getRange();
                this.movement = this.getMovement();

                if (subtype === 'barrack') {
                    this.spawnCounter = 0;
                }
            }

            getCost() {
                const costs = {
                    scout: { coins: 15 },
                    knight: { coins: 25 },
                    archer: { coins: 20 },
                    tank: { coins: 50 },
                    siegetower: { coins: 275 },
                    king: { gold: 500 },
                    barrack: { gold: 50 }
                };
                return costs[this.subtype] || { coins: 15 };
            }

            getMaxHealth() {
                switch (this.subtype) {
                    case 'tank': return 5;
                    case 'king': return 25;
                    default: return 1;
                }
            }

            getRange() {
                switch (this.subtype) {
                    case 'archer':
                    case 'siegetower': return 4;
                    case 'king': return 2;
                    default: return 1;
                }
            }

            getMovement() {
                switch (this.subtype) {
                    case 'knight': return 5;
                    case 'archer': return 1;
                    case 'tank': return 1;
                    case 'king': return 2;
                    default: return 1;
                }
            }

            getValidMoves() {
                const moves = [];
                const attacks = [];

                const directions = this.subtype === 'knight' ?
                    [[-1, -1], [-1, 1], [1, -1], [1, 1]] :
                    [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];

                directions.forEach(([dx, dy]) => {
                    for (let i = 1; i <= this.movement; i++) {
                        const worldX = this.x + dx * i;
                        const worldY = this.y + dy * i;

                        const gridX = worldX - gameState.cameraOffset.x;
                        const gridY = worldY - gameState.cameraOffset.y;

                        if (gridX < 0 || gridX >= CONFIG.GRID_SIZE_X || gridY < 0 || gridY >= CONFIG.GRID_SIZE_Y) break;

                        const target = gameState.grid[gridY][gridX];
                        if (target === null) {
                            moves.push({ x: worldX, y: worldY });
                        } else if (target.type === 'enemy') {
                            attacks.push({ x: worldX, y: worldY });
                            break;
                        } else {
                            break;
                        }
                    }
                });

                if (this.subtype === 'archer' || this.subtype === 'siegetower') {
                    const allDirections = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];
                    allDirections.forEach(([dx, dy]) => {
                        for (let i = 1; i <= this.range; i++) {
                            const worldX = this.x + dx * i;
                            const worldY = this.y + dy * i;

                            const gridX = worldX - gameState.cameraOffset.x;
                            const gridY = worldY - gameState.cameraOffset.y;

                            if (gridX < 0 || gridX >= CONFIG.GRID_SIZE_X || gridY < 0 || gridY >= CONFIG.GRID_SIZE_Y) break;

                            const target = gameState.grid[gridY][gridX];
                            if (target && target.type === 'enemy') {
                                attacks.push({ x: worldX, y: worldY });
                            }
                        }
                    });
                }

                return { moves, attacks };
            }

            onTurn() {
                if (this.subtype === 'barrack') {
                    this.spawnCounter = (this.spawnCounter || 0) + 1;
                    if (this.spawnCounter >= 2) {
                        this.spawnCounter = 0;
                        const worldX = this.x - 1;
                        const worldY = this.y;

                        const gridX = worldX - gameState.cameraOffset.x;
                        const gridY = worldY - gameState.cameraOffset.y;

                        if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X && gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y && gameState.grid[gridY][gridX] === null) {
                            const scout = new Army(worldX, worldY, 'scout');
                            addObjectToWorld(scout);
                            showNotification('Barrack spawned a Soldier!', gridX, gridY);
                        }
                    }
                }
            }

            moveTo(x, y) {
                const oldX = this.x;
                const oldY = this.y;

                this.x = x;
                this.y = y;

                gameState.worldObjects.set(this.id, this);

                const oldGridX = oldX - gameState.cameraOffset.x;
                const oldGridY = oldY - gameState.cameraOffset.y;
                if (oldGridX >= 0 && oldGridX < CONFIG.GRID_SIZE_X &&
                    oldGridY >= 0 && oldGridY < CONFIG.GRID_SIZE_Y) {
                    gameState.grid[oldGridY][oldGridX] = null;
                }

                const gridX = x - gameState.cameraOffset.x;
                const gridY = y - gameState.cameraOffset.y;

                if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X && gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                    gameState.grid[gridY][gridX] = this;
                    gameState.objects.set(this.id, this);
                } else {
                    gameState.objects.delete(this.id);
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        class Enemy extends GameObject {
            constructor(x, y, subtype = 'basic') {
                super(x, y, 'enemy', subtype);
                this.health = this.getMaxHealth();
                this.maxHealth = this.health;
            }

            getMaxHealth() {
                switch (this.subtype) {
                    case 'tank': return 100;
                    case 'fast': return 30;
                    case 'ranged': return 40;
                    case 'healer': return 25;
                    default: return 50;
                }
            }

            onTurn() {
                const playerGridX = CONFIG.PLAYER_START.x - gameState.cameraOffset.x;
                const playerGridY = CONFIG.PLAYER_START.y - gameState.cameraOffset.y;

                const playerWorldX = CONFIG.PLAYER_START.x;
                const playerWorldY = CONFIG.PLAYER_START.y;

                if (this.x === playerWorldX && this.y === playerWorldY) {
                    gameOver();
                    return;
                }

                const attacks = this.getValidAttacks();
                if (attacks.length > 0) {
                    const target = attacks[0].target;
                    this.attackTarget(target);
                    return;
                }

                this.moveTowardsPlayer();
            }

            getValidAttacks() {
                const attacks = [];
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];

                directions.forEach(([dx, dy]) => {
                    const worldX = this.x + dx;
                    const worldY = this.y + dy;

                    const gridX = worldX - gameState.cameraOffset.x;
                    const gridY = worldY - gameState.cameraOffset.y;

                    let target = null;

                    if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X && gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                        target = gameState.grid[gridY][gridX];
                    } else {
                        for (const [id, obj] of gameState.worldObjects) {
                            if (obj.x === worldX && obj.y === worldY) {
                                target = obj;
                                break;
                            }
                        }

                        if (worldX === CONFIG.PLAYER_START.x && worldY === CONFIG.PLAYER_START.y) {
                            target = 'player';
                        }
                    }

                    if (target && (
                        (target.type === 'army' && target.owner === 'player') ||
                        target.type === 'wall' ||
                        target.type === 'tech' ||
                        target === 'player'
                    )) {
                        attacks.push({ x: worldX, y: worldY, target });
                    }
                });

                return attacks;
            }

            moveTowardsPlayer() {
                const playerGridX = CONFIG.PLAYER_START.x - gameState.cameraOffset.x;
                const playerGridY = CONFIG.PLAYER_START.y - gameState.cameraOffset.y;

                const playerWorldX = CONFIG.PLAYER_START.x;
                const playerWorldY = CONFIG.PLAYER_START.y;

                let dx = Math.sign(playerWorldX - this.x);
                let dy = Math.sign(playerWorldY - this.y);

                let newX = this.x + dx;
                let newY = this.y + dy;

                let newGridX = newX - gameState.cameraOffset.x;
                let newGridY = newY - gameState.cameraOffset.y;

                let canMove = true;
                if (newGridX >= 0 && newGridX < CONFIG.GRID_SIZE_X &&
                    newGridY >= 0 && newGridY < CONFIG.GRID_SIZE_Y) {
                    canMove = gameState.grid[newGridY][newGridX] === null;
                }

                if (canMove) {
                    const oldGridX = this.x - gameState.cameraOffset.x;
                    const oldGridY = this.y - gameState.cameraOffset.y;
                    if (oldGridY >= 0 && oldGridY < CONFIG.GRID_SIZE_Y &&
                        oldGridX >= 0 && oldGridX < CONFIG.GRID_SIZE_X) {
                        gameState.grid[oldGridY][oldGridX] = null;
                    }

                    this.x = newX;
                    this.y = newY;

                    if (newGridX >= 0 && newGridX < CONFIG.GRID_SIZE_X &&
                        newGridY >= 0 && newGridY < CONFIG.GRID_SIZE_Y) {
                        gameState.grid[newGridY][newGridX] = this;
                    }

                    gameState.worldObjects.set(this.id, this);
                    gameState.objects.set(this.id, this);
                }
            }

            attackTarget(target) {
                if (target.type === 'army' || target.type === 'tech') {
                    const isDestroyed = target.takeDamage(1);
                    if (isDestroyed) {
                        if (target.y >= gameState.cameraOffset.y && target.y < gameState.cameraOffset.y + CONFIG.GRID_SIZE_Y &&
                            target.x >= gameState.cameraOffset.x && target.x < gameState.cameraOffset.x + CONFIG.GRID_SIZE_X) {
                            const gridY = target.y - gameState.cameraOffset.y;
                            const gridX = target.x - gameState.cameraOffset.x;
                            gameState.grid[gridY][gridX] = null;
                        }

                        gameState.objects.delete(target.id);
                        gameState.worldObjects.delete(target.id);

                        if (gameState.selectedUnit && gameState.selectedUnit.id === target.id) {
                            clearSelection();
                        }
                    }
                } else if (target.type === 'wall') {
                    const isDestroyed = target.takeDamage(1);
                    if (isDestroyed) {
                        if (target.y >= gameState.cameraOffset.y && target.y < gameState.cameraOffset.y + CONFIG.GRID_SIZE_Y &&
                            target.x >= gameState.cameraOffset.x && target.x < gameState.cameraOffset.x + CONFIG.GRID_SIZE_X) {
                            const gridY = target.y - gameState.cameraOffset.y;
                            const gridX = target.x - gameState.cameraOffset.x;
                            gameState.grid[gridY][gridX] = null;
                        }

                        gameState.objects.delete(target.id);
                        gameState.worldObjects.delete(target.id);
                    }
                } else if (target === 'player') {
                    gameOver();
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        const gameState = new GameState();

        async function initGame() {
            // Wait for the tech tree to be loaded
            await loadTechTree();
            
            // Now that tech tree is loaded, automatically research fortress
            if (CONFIG.TECH_TREE.fortress && !gameState.isTechResearched('fortress')) {
                console.log('Automatically researching Fortress at game start');
                gameState.researchedTechs.add('fortress');
                gameState.updateAvailableTechs();
            }
            
            if (window.waveBreakTimeout) {
                clearTimeout(window.waveBreakTimeout);
                window.waveBreakTimeout = null;
            }

            createGrid();

            if (typeof gameState.cameraOffset === 'undefined') {
                gameState.cameraOffset = { x: 0, y: 0 };
            }

            gameState.cameraOffset.x = Math.floor(CONFIG.GRID_SIZE_X / 2) - CONFIG.PLAYER_START.x;
            gameState.cameraOffset.y = Math.floor(CONFIG.GRID_SIZE_Y / 2) - CONFIG.PLAYER_START.y;

            const playerWorldX = CONFIG.PLAYER_START.x;
            const playerWorldY = CONFIG.PLAYER_START.y;
            const playerGridX = playerWorldX - gameState.cameraOffset.x;
            const playerGridY = playerWorldY - gameState.cameraOffset.y;

            if (playerGridX >= 0 && playerGridX < CONFIG.GRID_SIZE_X &&
                playerGridY >= 0 && playerGridY < CONFIG.GRID_SIZE_Y) {
                gameState.grid[playerGridY][playerGridX] = 'player';
            }

            if (typeof gameState.enemiesRemaining === 'undefined') {
                gameState.enemiesRemaining = 0;
            }

            spawnEnemy(5, 5);
            spawnEnemy(10, 2);
            spawnEnemy(2, 10);

            console.log(`Initial enemies spawned, count: ${gameState.enemiesRemaining}`);
            gameState.countEnemies();
            console.log(`After countEnemies, enemies remaining: ${gameState.enemiesRemaining}`);
            updateDisplay();
            setupEventListeners();

            if (window.buttonStateInterval) {
                clearInterval(window.buttonStateInterval);
            }
            window.buttonStateInterval = setInterval(updateButtonStates, 2000);
        }

        function createGrid() {
            const gridElement = document.getElementById('game-grid');
            if (!gridElement) {
                console.error('Game grid element not found');
                return;
            }

            gridElement.innerHTML = '';

            for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    cell.addEventListener('click', (function (x, y) {
                        return function (e) {
                            e.stopPropagation();
                            handleCellClick(x, y);
                        };
                    })(x, y));

                    gridElement.appendChild(cell);
                }
            }
        }

        function reattachGridCellListeners() {
            document.querySelectorAll('.grid-cell').forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const newCell = cell.cloneNode(true);
                cell.parentNode.replaceChild(newCell, cell);
                newCell.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleCellClick(x, y);
                });
            });
        }

        function handleCellClick(x, y) {
            const worldX = x + gameState.cameraOffset.x;
            const worldY = y + gameState.cameraOffset.y;

            const cell = gameState.grid[y][x];
            let actionTaken = false;

            if (gameState.placementMode) {
                if (cell === null) {
                    const [type, subtype] = parsePlacementMode(gameState.placementMode);
                    const placed = placeObject(x, y, type, subtype);
                    if (placed) {
                        actionTaken = true;
                        // Reset folder open flag after successful placement
                        window.keepFoldersOpen = false;
                        console.log('Resetting keepFoldersOpen = false after placement');
                    }
                }
                updateDisplay();
                if (actionTaken) {
                    processEnemyTurn();
                }
                return;
            }

            // Handle army units separately - allow movement/selection instead of opening building info
            if (cell && cell.type === 'army') {
                clearSelection();
                gameState.selectedUnit = cell;
                highlightValidMoves(cell);
                updateDisplay();
                return;
            }

            // If we clicked on a building (not army), show the building info window
            if (cell && (cell.type === 'wall' || cell.type === 'tech')) {
                showBuildingInfo(cell);
                return;
            }

            if (gameState.selectedUnit) {
                const { moves, attacks } = gameState.selectedUnit.getValidMoves();

                const isValidMove = moves.some(move => move.x === worldX && move.y === worldY);
                const isValidAttack = attacks.some(attack => attack.x === worldX && attack.y === worldY);

                if (isValidMove && cell === null) {
                    gameState.selectedUnit.moveTo(worldX, worldY);
                    actionTaken = true;
                } else if (isValidAttack && cell && cell.type === 'enemy') {
                    attackEnemy(cell);
                    actionTaken = true;
                } else {
                    clearSelection();
                }

                clearSelection();
                updateDisplay();
                if (actionTaken) {
                    processEnemyTurn();
                }
            }
        }

        function parsePlacementMode(mode) {
            if (mode.includes('-')) {
                const parts = mode.split('-');
                return [parts[0], parts[1]];
            }
            return [mode, null];
        }

        function placeObject(x, y, type, subtype = null) {
            const worldX = x + gameState.cameraOffset.x;
            const worldY = y + gameState.cameraOffset.y;

            if (type === 'tech' && subtype === 'oilrig') {
                if (isAdjacentToCampfire(x, y)) {
                    showNotification('Oil rigs cannot be placed beside campfires!', x, y, 'warning');
                    return false;
                }
            }

            if (type === 'tech' && subtype === 'campfire') {
                if (isAdjacentToOilRig(x, y)) {
                    showNotification('Campfires cannot be placed beside oil rigs!', x, y, 'warning');
                    return false;
                }
            }

            let obj;
            let cost;

            switch (type) {
                case 'wall':
                    obj = new Wall(worldX, worldY, subtype || 'stone');
                    cost = getWallCost(subtype);
                    break;
                case 'tech':
                    obj = new Tech(worldX, worldY, subtype || 'miner');
                    cost = obj.cost;
                    break;
                case 'army':
                    obj = new Army(worldX, worldY, subtype || 'scout');
                    cost = obj.cost;
                    break;
                default:
                    return false;
            }

            if (!gameState.canAfford(cost)) {
                showNotification('Not enough resources!', x, y, 'warning');
                return false;
            }

            gameState.spendResources(cost);
            addObjectToWorld(obj);

            if (type === 'tech') {
                obj.onTurn();
            }

            showNotification(`${subtype || type} placed!`, x, y, 'success');
            createPlacementEffect(x, y);
            return true;
        }

        function isAdjacentToCampfire(x, y) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const checkX = x + dx;
                    const checkY = y + dy;

                    if (checkX >= 0 && checkX < CONFIG.GRID_SIZE_X && checkY >= 0 && checkY < CONFIG.GRID_SIZE_Y) {
                        const obj = gameState.grid[checkY][checkX];
                        if (obj && obj.type === 'tech' && obj.subtype === 'campfire') {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function isAdjacentToOilRig(x, y) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const checkX = x + dx;
                    const checkY = y + dy;

                    if (checkX >= 0 && checkX < CONFIG.GRID_SIZE_X && checkY >= 0 && checkY < CONFIG.GRID_SIZE_Y) {
                        const obj = gameState.grid[checkY][checkX];
                        if (obj && obj.type === 'tech' && obj.subtype === 'oilrig') {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function getWallCost(subtype) {
            switch (subtype) {
                case 'steel': return { Steel: 20 };
                case 'spike': return { Steel: 15 };
                case 'fortress': return { gold: 25 };
                default: return { Steel: 10 };
            }
        }

        function spawnEnemy(x, y, subtype = null) {
            console.log(`spawnEnemy called with x=${x}, y=${y}`);
            const worldX = x + gameState.cameraOffset.x;
            const worldY = y + gameState.cameraOffset.y;

            if (y >= 0 && y < CONFIG.GRID_SIZE_Y && x >= 0 && x < CONFIG.GRID_SIZE_X && gameState.grid[y][x] === null) {
                if (!subtype) {
                    const enemyTypes = [
                        { type: 'basic', weight: 5 },
                        { type: 'fast', weight: 3 },
                        { type: 'tank', weight: 2 },
                        { type: 'ranged', weight: 3 },
                        { type: 'healer', weight: 2 }
                    ];

                    const totalWeight = enemyTypes.reduce((sum, type) => sum + type.weight, 0);
                    let random = Math.random() * totalWeight;

                    for (const enemyType of enemyTypes) {
                        random -= enemyType.weight;
                        if (random <= 0) {
                            subtype = enemyType.type;
                            break;
                        }
                    }
                }

                const enemy = new Enemy(worldX, worldY, subtype || 'basic');
                addObjectToWorld(enemy);
                gameState.enemiesRemaining++;
                console.log(`Enemy spawned, enemies remaining: ${gameState.enemiesRemaining}`);
            } else {
                console.log(`Failed to spawn enemy at ${x},${y} - cell not empty or out of bounds`);
            }
        }

        function clearSelection() {
            gameState.selectedUnit = null;
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.classList.remove('selected', 'valid-move', 'valid-attack');
            });
        }

        function attackEnemy(enemy) {
            const gridX = enemy.x - gameState.cameraOffset.x;
            const gridY = enemy.y - gameState.cameraOffset.y;

            if (gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y &&
                gridX >= 0 && gridX < CONFIG.GRID_SIZE_X) {
                gameState.grid[gridY][gridX] = null;
            }

            gameState.objects.delete(enemy.id);
            gameState.worldObjects.delete(enemy.id);
            gameState.enemiesRemaining--;
            console.log(`Enemy attacked, enemies remaining: ${gameState.enemiesRemaining}`);

            gameState.addResources({ coins: 5 });
            createEnemyDefeatEffect(enemy.x, enemy.y);
        }

        function gameOver() {
            showNotification('Game Over! The enemies have reached your base!', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'danger');
            setTimeout(() => {
                if (confirm('Game Over! Would you like to restart?')) {
                    restartGame();
                }
            }, 1000);
        }

        function highlightValidMoves(unit) {
            const { moves, attacks } = unit.getValidMoves();

            moves.forEach(move => {
                const gridX = move.x - gameState.cameraOffset.x;
                const gridY = move.y - gameState.cameraOffset.y;

                if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X &&
                    gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                    const cell = document.querySelector(`[data-x="${gridX}"][data-y="${gridY}"]`);
                    if (cell) {
                        cell.classList.add('valid-move');
                    }
                }
            });

            attacks.forEach(attack => {
                const gridX = attack.x - gameState.cameraOffset.x;
                const gridY = attack.y - gameState.cameraOffset.y;

                if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X &&
                    gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                    const cell = document.querySelector(`[data-x="${gridX}"][data-y="${gridY}"]`);
                    if (cell) {
                        cell.classList.add('valid-attack');
                    }
                }
            });

            const unitGridX = unit.x - gameState.cameraOffset.x;
            const unitGridY = unit.y - gameState.cameraOffset.y;

            if (unitGridX >= 0 && unitGridX < CONFIG.GRID_SIZE_X &&
                unitGridY >= 0 && unitGridY < CONFIG.GRID_SIZE_Y) {
                const unitCell = document.querySelector(`[data-x="${unitGridX}"][data-y="${unitGridY}"]`);
                if (unitCell) {
                    unitCell.classList.add('selected');
                }
            }
        }

        function spawnNextWave() {
            console.log("spawnNextWave called");
            if (window.waveBreakTimeout) {
                clearTimeout(window.waveBreakTimeout);
                window.waveBreakTimeout = null;
            }
            gameState.wave++;
            console.log(`Wave incremented to ${gameState.wave}`);
            gameState.inWaveBreak = false;
            console.log("Wave break reset to false");

            let numEnemies = 3 + gameState.wave * 2;

            const emptyCells = [];
            for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                    const playerGridX = CONFIG.PLAYER_START.x - gameState.cameraOffset.x;
                    const playerGridY = CONFIG.PLAYER_START.y - gameState.cameraOffset.y;

                    if (x === playerGridX && y === playerGridY) continue;

                    if (gameState.grid[y][x] === null) {
                        emptyCells.push({ x, y });
                    }
                }
            }

            for (let i = emptyCells.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [emptyCells[i], emptyCells[j]] = [emptyCells[j], emptyCells[i]];
            }

            const enemiesToSpawn = Math.min(numEnemies, emptyCells.length);

            console.log(`Spawning wave ${gameState.wave}: ${enemiesToSpawn} enemies`);

            for (let i = 0; i < enemiesToSpawn; i++) {
                const { x, y } = emptyCells[i];
                spawnEnemy(x, y);
            }

            gameState.countEnemies();
            showNotification(`Wave ${gameState.wave} incoming!`, CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'warning');
            updateDisplay();
        }

        function processEnemyTurn() {
            gameState.objects.forEach(obj => {
                if (obj.type === 'army' && obj.onTurn) {
                    obj.onTurn();
                }
            });

            gameState.objects.forEach(obj => {
                if (obj.type === 'tech' && obj.onTurn) {
                    obj.onTurn();
                }
            });

            const enemies = [];
            gameState.objects.forEach(obj => {
                if (obj.type === 'enemy') {
                    enemies.push(obj);
                }
            });

            enemies.forEach(enemy => {
                enemy.onTurn();
            });

            gameState.turn++;
            gameState.countEnemies();

            console.log(`Enemies remaining: ${gameState.enemiesRemaining}, In wave break: ${gameState.inWaveBreak}`);

            if (gameState.enemiesRemaining === 0 && !gameState.inWaveBreak) {
                console.log("Condition met: enemiesRemaining is 0 and not in wave break");
                console.log("Starting wave break");
                gameState.inWaveBreak = true;
                gameState.waveBreakTurns = CONFIG.WAVE_BREAK_TURNS;
                showNotification(`Wave ${gameState.wave} complete! Prepare for the next wave.`, CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
            }

            if (gameState.inWaveBreak) {
                console.log(`Wave break turns remaining: ${gameState.waveBreakTurns}`);
                gameState.waveBreakTurns--;
                console.log(`Decremented wave break turns: ${gameState.waveBreakTurns}`);
                if (gameState.waveBreakTurns <= 0) {
                    console.log("Spawning next wave");
                    spawnNextWave();
                } else {

                    if (window.waveBreakTimeout) {
                        clearTimeout(window.waveBreakTimeout);
                    }
                    window.waveBreakTimeout = setTimeout(processEnemyTurn, 1000);
                }
            }

            updateDisplay();
        }

        function updateDisplay() {
            document.getElementById('steel-count').textContent = gameState.resources.Steel;
            document.getElementById('coin-count').textContent = gameState.resources.coins;
            document.getElementById('gold-count').textContent = gameState.resources.gold;
            document.getElementById('oil-count').textContent = gameState.resources.oil;

            document.getElementById('turn-count').textContent = gameState.turn;
            document.getElementById('wave-count').textContent = gameState.wave;
            document.getElementById('enemies-remaining').textContent = gameState.enemiesRemaining;

            const instructions = document.getElementById('turn-instructions');
            if (gameState.inWaveBreak) {
                instructions.textContent = `Wave break: ${gameState.waveBreakTurns} turns until next wave`;
            } else if (gameState.placementMode) {
                instructions.textContent = 'Click on an empty cell to place the selected object';
            } else if (gameState.selectedUnit) {
                instructions.textContent = 'Click on a highlighted cell to move or attack';
            } else {
                instructions.textContent = 'Click an army unit to select it, then click a highlighted square to move';
            }

            document.querySelectorAll('.grid-cell').forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const obj = gameState.grid[y][x];

                cell.className = 'grid-cell';
                cell.innerHTML = '';

                if (obj === 'player') {
                    const sprite = document.createElement('div');
                    sprite.className = 'object-sprite';
                    const img = document.createElement('img');
                    img.src = CONFIG.SPRITES.player;
                    img.alt = 'player';
                    sprite.appendChild(img);
                    cell.appendChild(sprite);
                } else if (obj && obj.type) {
                    const sprite = document.createElement('div');
                    sprite.className = 'object-sprite';
                    const img = document.createElement('img');
                    img.src = obj.getSprite();
                    img.alt = obj.subtype;
                    sprite.appendChild(img);

                    if (obj.health < obj.maxHealth) {
                        const healthBar = document.createElement('div');
                        healthBar.className = 'health-bar';
                        const healthFill = document.createElement('div');
                        healthFill.className = 'health-fill';
                        healthFill.style.width = `${(obj.health / obj.maxHealth) * 100}%`;
                        healthBar.appendChild(healthFill);
                        cell.appendChild(healthBar);
                    }

                    cell.appendChild(sprite);
                }

                if (gameState.selectedUnit &&
                    gameState.selectedUnit.x === (x + gameState.cameraOffset.x) &&
                    gameState.selectedUnit.y === (y + gameState.cameraOffset.y)) {
                    cell.classList.add('selected');
                }
            });

            if (gameState.selectedUnit) {
                highlightValidMoves(gameState.selectedUnit);
            }

            reattachGridCellListeners();

            updateButtonStates();
            updateTechTreeDisplay();
            
            // Update module affordability if the popup is open
            if (document.getElementById('module-selection-popup').style.display === 'flex') {
                updateModuleAffordability();
            }
        }

        function updateTechTreeDisplay() {
            // Update the visual tech tree if it's visible
            const techTreeContent = document.getElementById('tech-tree-content');
            if (techTreeContent && techTreeContent.style.display !== 'none') {
                // Re-render the tech tree to reflect current game state
                renderTechTree();
            }
            // This function is called from updateDisplay() to refresh the tech tree UI
            // when game state changes (resources, researched techs, etc.)
        }

        function updateButtonStates() {
            document.querySelectorAll('.btn').forEach(btn => {
                btn.classList.remove('active');
            });

            if (gameState.placementMode) {
                const activeButton = document.querySelector(`[data-mode="${gameState.placementMode}"]`);
                if (activeButton) {
                    activeButton.classList.add('active');
                }
            }

            document.querySelectorAll('.btn[data-cost]').forEach(btn => {
                try {
                    const cost = JSON.parse(btn.dataset.cost);
                    if (gameState.canAfford(cost)) {
                        btn.classList.remove('disabled');
                    } else {
                        btn.classList.add('disabled');
                    }

                    const mode = btn.dataset.mode;
                    if (mode && isBuildingRestricted(mode)) {
                        btn.classList.add('disabled');
                        if (!btn.dataset.originalTitle) {
                            btn.dataset.originalTitle = btn.title || '';
                            btn.title = 'Research required: ' + getResearchRequirementName(mode);
                        }
                    } else if (btn.dataset.originalTitle !== undefined) {
                        btn.title = btn.dataset.originalTitle;
                        delete btn.dataset.originalTitle;
                    }
                } catch (e) {
                    console.warn('Error parsing cost for button:', btn, e);
                }
            });
        }

        function getResearchRequirementName(mode) {
            const buildingRequirements = {
                'wall-steel': 'Advanced Defense',
                'wall-spike': 'Spike Traps',
                'wall-fortress': 'Fortress',
                'tech-goldturret': 'Fortified Defense',
                'tech-turret': 'Basic Turret',
                'tech-bomb': 'Bomb Tech',
                'tech-supply': 'Supply Systems',
                'tech-goldminer': 'Advanced Mining',
                'tech-oilrig': 'Oil Rig Tech',
                'tech-coinmaker': 'Premium Mining',
                'tech-campfire': 'Campfire Tech',
                'army-tank': 'Elite Units',
                'army-siegetower': 'Siege Weapons',
                'army-king': 'Command Units',
                'army-barrack': 'Barrack Tech',
                'army-archer': 'Ranged Units',
                'army-knight': 'Advanced Army'
            };

            if (buildingRequirements[mode]) {
                return buildingRequirements[mode];
            }

            if (mode === 'wall') {
                return 'Fortress';
            }
            if (mode === 'army-scout') {
                return 'None';
            }

            if (mode === 'tech') {
                return 'None';
            }

            return 'Unknown Research';
        }

        function showNotification(message, x, y, type) {
            let container = document.querySelector('.notification-container');
            if (!container) {
                container = document.createElement('div');
                container.className = 'notification-container';
                document.body.appendChild(container);
            }

            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;

            container.insertBefore(notification, container.firstChild);

            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.3s ease forwards';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        function createParticleEffect(x, y, color, count = 15) {
            const effectContainer = document.createElement('div');
            effectContainer.className = 'particle-effect';
            effectContainer.style.left = x + 'px';
            effectContainer.style.top = y + 'px';
            document.body.appendChild(effectContainer);

            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.backgroundColor = color;
                effectContainer.appendChild(particle);

                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;

                const size = 2 + Math.random() * 4;
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';

                let posX = 0;
                let posY = 0;
                let opacity = 1;
                particle.style.opacity = opacity;

                const animate = () => {
                    posX += vx;
                    posY += vy;
                    opacity -= 0.02;

                    if (opacity <= 0) {
                        particle.remove();
                        return;
                    }

                    particle.style.transform = `translate(${posX}px, ${posY}px)`;
                    particle.style.opacity = opacity;

                    requestAnimationFrame(animate);
                };

                animate();
            }

            setTimeout(() => {
                if (effectContainer.parentNode) {
                    effectContainer.parentNode.removeChild(effectContainer);
                }
            }, 1000);
        }

        function createPlacementEffect(x, y) {
            const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
                const rect = cell.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                createParticleEffect(centerX, centerY, '#66d9ff', 20);
            }
        }

        function createEnemyDefeatEffect(x, y) {
            const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
                const rect = cell.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                createParticleEffect(centerX, centerY, '#ff5555', 25);
            }
        }

        let lastResourceEffectTime = 0;
        const RESOURCE_EFFECT_COOLDOWN = 2000;

        function createResourceCollectionEffect(x, y, resourceType) {
            const now = Date.now();
            if (now - lastResourceEffectTime < RESOURCE_EFFECT_COOLDOWN) {
                return;
            }
            lastResourceEffectTime = now;

            const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
                const rect = cell.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let color;
                switch (resourceType) {
                    case 'Steel': color = '#aaaaaa'; break;
                    case 'coins': color = '#d4af37'; break;
                    case 'gold': color = '#ffcc00'; break;
                    default: color = '#66d9ff';
                }

                createParticleEffect(centerX, centerY, color, 5);
            }
        }

        const BUTTONS = [
            { id: 'place-wall', mode: 'wall', cost: { Steel: 10 } },
            { id: 'place-steel-wall', mode: 'wall-steel', cost: { Steel: 20 } },
            { id: 'place-spike', mode: 'wall-spike', cost: { Steel: 15 } },
            { id: 'place-fortress', mode: 'wall-fortress', cost: { gold: 25 } },
            { id: 'place-tech', mode: 'tech', cost: { Steel: 20 } },
            { id: 'place-gold-miner', mode: 'tech-goldminer', cost: { Steel: 25 } },
            { id: 'place-coin-maker', mode: 'tech-coinmaker', cost: { Steel: 30 } },
            { id: 'place-oil-rig', mode: 'tech-oilrig', cost: { Steel: 35 } },
            { id: 'place-turret', mode: 'tech-turret', cost: { Steel: 40 } },
            { id: 'place-gold-turret', mode: 'tech-goldturret', cost: { gold: 200 } },
            { id: 'place-bomb', mode: 'tech-bomb', cost: { gold: 10 } },
            { id: 'place-supply', mode: 'tech-supply', cost: { gold: 35 } },
            { id: 'place-campfire', mode: 'tech-campfire', cost: { Steel: 30 } },
            { id: 'place-scout', mode: 'army-scout', cost: { coins: 15 } },
            { id: 'place-knight', mode: 'army-knight', cost: { coins: 25 } },
            { id: 'place-archer', mode: 'army-archer', cost: { coins: 20 } },
            { id: 'place-tank', mode: 'army-tank', cost: { coins: 50 } },
            { id: 'place-siege-tower', mode: 'army-siegetower', cost: { coins: 275 } },
            { id: 'place-king', mode: 'army-king', cost: { gold: 500 } },
            { id: 'place-barrack', mode: 'army-barrack', cost: { gold: 50 } }
        ];

        function setupEventListeners() {
            makeFoldersDraggable();

            document.querySelectorAll('[data-folder] .folder-title').forEach(function (title) {
                const clone = title.cloneNode(true);
                title.parentNode.replaceChild(clone, title);

                clone.addEventListener('click', function (e) {
                    e.stopPropagation();
                    const folder = clone.closest('.folder');
                    folder.classList.toggle('open');

                    if (folder.classList.contains('open')) {
                        const rect = clone.getBoundingClientRect();
                        const folderContent = folder.querySelector('.folder-content');
                        if (folderContent) {
                            folderContent.style.left = rect.left + 'px';
                            folderContent.style.top = (rect.bottom + 5) + 'px';
                        }
                    } else {
                        // Clear positioning when folder is closed
                        const folderContent = folder.querySelector('.folder-content');
                        if (folderContent) {
                            folderContent.style.left = '';
                            folderContent.style.top = '';
                        }
                    }
                });
            });

            const techTreeButton = document.getElementById('tech-tree-button');
            if (techTreeButton) {
                const clone = techTreeButton.cloneNode(true);
                techTreeButton.parentNode.replaceChild(clone, techTreeButton);

                clone.addEventListener('click', function (e) {
                    e.stopPropagation();
                    console.log('Tech tree button clicked');
                    const popup = document.getElementById('tech-tree-popup');
                    const overlay = document.getElementById('tech-tree-overlay');
                    if (popup && overlay) {
                        popup.style.display = 'flex';
                        overlay.style.display = 'block';
                        renderTechTree();
                        makeTechTreeDraggable();
                        console.log('Tech tree popup opened');
                    } else {
                        console.error('Tech tree popup or overlay not found');
                    }
                }, true); // Use capture phase to ensure it fires
            }
            
            // Add event listener for the new research tree button in the Research folder
            const openResearchTreeButton = document.getElementById('open-research-tree');
            if (openResearchTreeButton) {
                const clone = openResearchTreeButton.cloneNode(true);
                openResearchTreeButton.parentNode.replaceChild(clone, openResearchTreeButton);
                
                clone.addEventListener('click', function (e) {
                    e.stopPropagation();
                    console.log('Open research tree button clicked');
                    const popup = document.getElementById('tech-tree-popup');
                    const overlay = document.getElementById('tech-tree-overlay');
                    if (popup && overlay) {
                        popup.style.display = 'flex';
                        overlay.style.display = 'block';
                        renderTechTree();
                        makeTechTreeDraggable();
                        console.log('Tech tree popup opened from research folder');
                    } else {
                        console.error('Tech tree popup or overlay not found');
                    }
                });
            }

            const techTreeClose = document.getElementById('tech-tree-close');
            if (techTreeClose) {
                const clone = techTreeClose.cloneNode(true);
                techTreeClose.parentNode.replaceChild(clone, techTreeClose);

                clone.addEventListener('click', function () {
                    const popup = document.getElementById('tech-tree-popup');
                    const overlay = document.getElementById('tech-tree-overlay');
                    if (popup) popup.style.display = 'none';
                    if (overlay) overlay.style.display = 'none';
                });
            }

            const techTreeOverlay = document.getElementById('tech-tree-overlay');
            if (techTreeOverlay) {
                const clone = techTreeOverlay.cloneNode(true);
                techTreeOverlay.parentNode.replaceChild(clone, techTreeOverlay);

                clone.addEventListener('click', function () {
                    const popup = document.getElementById('tech-tree-popup');
                    const overlay = document.getElementById('tech-tree-overlay');
                    if (popup) popup.style.display = 'none';
                    if (overlay) overlay.style.display = 'none';
                });
            }

            document.querySelectorAll('.folder-close').forEach(function (button) {
                const clone = button.cloneNode(true);
                button.parentNode.replaceChild(clone, button);

                clone.addEventListener('click', function (e) {
                    e.stopPropagation();
                    const folder = clone.closest('.folder');
                    folder.classList.remove('open');
                });
            });

            document.querySelectorAll('.info-icon').forEach(function (icon) {
                const clone = icon.cloneNode(true);
                icon.parentNode.replaceChild(clone, icon);

                clone.addEventListener('click', function (e) {
                    e.stopPropagation();
                    showInfoPopup(clone.closest('.btn'));
                });
            });

            BUTTONS.forEach(function (buttonData) {
                const button = document.getElementById(buttonData.id);
                if (button) {
                    const clone = button.cloneNode(true);
                    button.parentNode.replaceChild(clone, button);

                    clone.dataset.mode = buttonData.mode;
                    clone.dataset.cost = JSON.stringify(buttonData.cost);
                    clone.addEventListener('click', function (e) {
                        e.stopPropagation();
                        if (isBuildingRestricted(buttonData.mode)) {
                            showNotification('You need to research the required technology first!', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'warning');
                            return;
                        }
                        gameState.placementMode = gameState.placementMode === buttonData.mode ? null : buttonData.mode;
                        
                        // Keep folder open when entering placement mode
                        if (gameState.placementMode === buttonData.mode) {
                            window.keepFoldersOpen = true;
                            console.log('Setting keepFoldersOpen = true for mode:', buttonData.mode);
                        } else {
                            window.keepFoldersOpen = false;
                            console.log('Setting keepFoldersOpen = false');
                        }
                        
                        updateButtonStates();
                        updateDisplay();
                    });
                }
            });

            const saveGameButton = document.getElementById('save-game');
            if (saveGameButton) {
                const clone = saveGameButton.cloneNode(true);
                saveGameButton.parentNode.replaceChild(clone, saveGameButton);
                clone.addEventListener('click', saveGame);
            }

            const loadGameButton = document.getElementById('load-game');
            if (loadGameButton) {
                const clone = loadGameButton.cloneNode(true);
                loadGameButton.parentNode.replaceChild(clone, loadGameButton);
                clone.addEventListener('click', function () {
                    const fileInput = document.getElementById('load-file');
                    if (fileInput) fileInput.click();
                });
            }

            const restartGameButton = document.getElementById('restart-game');
            if (restartGameButton) {
                const clone = restartGameButton.cloneNode(true);
                restartGameButton.parentNode.replaceChild(clone, restartGameButton);
                clone.addEventListener('click', restartGame);
            }

            document.addEventListener('click', function (e) {
                console.log('Global click handler - keepFoldersOpen:', window.keepFoldersOpen);
                console.log('Clicked target:', e.target);
                console.log('Is folder target:', !!e.target.closest('[data-folder]'));
                
                // Don't close folders if we're in placement mode and want to keep them open
                if (!window.keepFoldersOpen && !e.target.closest('[data-folder]')) {
                    console.log('Closing folders');
                    document.querySelectorAll('.folder.open').forEach(folder => {
                        folder.classList.remove('open');
                    });
                } else {
                    console.log('NOT closing folders - keepFoldersOpen:', window.keepFoldersOpen, 'isFolderTarget:', !!e.target.closest('[data-folder]'));
                }

                if (!e.target.closest('.info-popup') && !e.target.closest('.info-icon')) {
                    closeInfoPopup();
                }
            });

            if (!document.getElementById('load-file')) {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.id = 'load-file';
                fileInput.accept = '.coregrid';
                fileInput.style.display = 'none';
                fileInput.addEventListener('change', function (e) {
                    if (e.target.files.length > 0) {
                        loadGame(e.target.files[0]);
                    }
                });
                document.body.appendChild(fileInput);
            }

            // Building info window event listeners
            const buildingInfoClose = document.getElementById('building-info-close');
            if (buildingInfoClose) {
                const clone = buildingInfoClose.cloneNode(true);
                buildingInfoClose.parentNode.replaceChild(clone, buildingInfoClose);

                clone.addEventListener('click', function () {
                    closeBuildingInfo();
                });
            }

            const buildingInfoOverlay = document.getElementById('building-info-overlay');
            if (buildingInfoOverlay) {
                const clone = buildingInfoOverlay.cloneNode(true);
                buildingInfoOverlay.parentNode.replaceChild(clone, buildingInfoOverlay);

                clone.addEventListener('click', function () {
                    closeBuildingInfo();
                });
            }
        }

        function isBuildingRestricted(mode) {
            const buildingRequirements = {
                'wall-steel': 'advanced_defense',
                'wall-spike': 'spike_traps',
                'wall-fortress': 'fortress',

                'tech-goldturret': 'fortified_defense',
                'tech-turret': 'basic_turret',
                'tech-bomb': 'bomb_tech',
                'tech-supply': 'supply_systems',
                'tech-campfire': 'campfire_tech',
                'tech-goldminer': 'advanced_mining',
                'tech-oilrig': 'oil_rig_tech',
                'tech-coinmaker': 'premium_mining',

                'army-tank': 'elite_units',
                'army-siegetower': 'siege_weapons',
                'army-king': 'command_units',
                'army-barrack': 'barrack_tech',
                'army-archer': 'ranged_units',
                'army-knight': 'advanced_army'
            };

            const requiredTech = buildingRequirements[mode];
            if (requiredTech) {
                return !gameState.isTechResearched(requiredTech);
            }
            if (mode === 'wall') {
                return !gameState.isTechResearched('fortress');
            }
            if (mode === 'army-scout') {
                return false;
            }
            if (mode === 'tech') {
                return false;
            }
            return false;
        }

        function getResearchRequirementName(mode) {
            const buildingRequirements = {
                'wall-steel': 'Advanced Defense',
                'wall-spike': 'Spike Traps',
                'wall-fortress': 'Fortress',
                'tech-goldturret': 'Fortified Defense',
                'tech-turret': 'Basic Turret',
                'tech-bomb': 'Bomb Tech',
                'tech-supply': 'Supply Systems',
                'tech-goldminer': 'Advanced Mining',
                'tech-coinmaker': 'Premium Mining',
                'tech-campfire': 'Campfire Tech',
                'army-tank': 'Elite Units',
                'army-siegetower': 'Siege Weapons',
                'army-king': 'Command Units',
                'army-barrack': 'Barrack Tech',
                'army-archer': 'Ranged Units',
                'army-knight': 'Advanced Army'
            };

            if (buildingRequirements[mode]) {
                return buildingRequirements[mode];
            }

            if (mode === 'wall') {
                return 'Fortress';
            }
            if (mode === 'army-scout') {
                return 'None';
            }

            if (mode === 'tech') {
                return 'None';
            }

            return 'Unknown Research';
        }

        // Add this function for debugging
        function debugResearch() {
            console.log('=== DEBUG RESEARCH INFO ===');
            console.log('Researched techs:', Array.from(gameState.researchedTechs));
            console.log('Available techs:', Array.from(gameState.availableTechs));
            console.log('Tech tree loaded:', Object.keys(CONFIG.TECH_TREE).length > 0);
            console.log('Current resources:', gameState.resources);
            
            // Check some specific techs
            const testTechs = ['fortress', 'module_research', 'basic_defense'];
            testTechs.forEach(techId => {
                const canResearch = gameState.canResearchTech(techId);
                const isResearched = gameState.isTechResearched(techId);
                console.log(`${techId}: canResearch=${canResearch}, isResearched=${isResearched}`);
            });
        }
        
        // Call this when needed for debugging
        // debugResearch();

        function renderTechTree() {
            const techTreeContent = document.getElementById('tech-tree-content');
            const techTreeMain = document.getElementById('tech-tree-main');
            const techInfoPanel = document.getElementById('tech-info-panel');
            
            if (!techTreeContent || !techTreeMain) {
                console.error('Tech tree elements not found');
                return;
            }

            // Clear only the main area, preserve the info panel
            techTreeMain.innerHTML = '';
            
            // Check if we have tech tree data
            if (!CONFIG.TECH_TREE || Object.keys(CONFIG.TECH_TREE).length === 0) {
                techTreeMain.innerHTML = `
                    <div style="text-align: center; padding: 50px;">
                        <h3>Tech Tree Not Loaded</h3>
                        <p>Unable to load tech tree data. Please check the console for errors.</p>
                        <button onclick="loadTechTree().then(() => renderTechTree())" 
                                style="padding: 10px 20px; margin-top: 20px;">
                            Reload Tech Tree
                        </button>
                    </div>
                `;
                return;
            }

            // Create connections first (so they appear behind nodes)
            for (const techId in CONFIG.TECH_TREE) {
                const tech = CONFIG.TECH_TREE[techId];
                const fromPos = NODE_POSITIONS[techId];

                if (fromPos && tech.prerequisites) {
                    tech.prerequisites.forEach(prereqId => {
                        const toPos = NODE_POSITIONS[prereqId];
                        if (toPos) {
                            const isResearched = gameState.isTechResearched(techId) && gameState.isTechResearched(prereqId);
                            const isLocked = !gameState.isTechResearched(techId) && !gameState.isTechResearched(prereqId) &&
                                !gameState.availableTechs.has(techId) && !gameState.availableTechs.has(prereqId);
                            createConnectionLine(techTreeMain, fromPos, toPos, isResearched, isLocked);
                        }
                    });
                }
            }

            // Create nodes
            for (const techId in CONFIG.TECH_TREE) {
                const tech = CONFIG.TECH_TREE[techId];
                const pos = NODE_POSITIONS[techId];

                if (pos) {
                    createTechNode(techTreeMain, techId, tech, pos);
                } else {
                    console.warn(`No position found for tech: ${techId}`);
                }
            }
        }

        function createConnectionLine(container, fromPos, toPos, isResearched, isLocked) {
            const line = document.createElement('div');
            line.className = 'tech-connection';
            if (isResearched) {
                line.classList.add('researched');
            } else if (isLocked) {
                line.classList.add('locked');
            }

            const dx = toPos.x - fromPos.x;
            const dy = toPos.y - fromPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

            line.style.width = distance + 'px';
            line.style.height = '4px';
            line.style.left = (fromPos.x + 45) + 'px';
            line.style.top = (fromPos.y + 45) + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.transformOrigin = '0 0';
            line.style.transition = 'all 0.3s ease';

            container.appendChild(line);
        }
        
        function updateTechInfoPanel(techId, tech) {
            const infoPanel = document.getElementById('tech-info-panel');
            if (!infoPanel) return;
            
            // Get tech state
            let state = 'locked';
            let stateText = 'LOCKED';
            if (gameState.isTechResearched(techId)) {
                state = 'researched';
                stateText = 'RESEARCHED';
            } else if (gameState.availableTechs.has(techId)) {
                state = 'available';
                stateText = 'AVAILABLE';
            }
            
            // Format cost display
            let costHtml = '';
            if (tech.cost) {
                const costs = [];
                if (tech.cost.Steel) costs.push(`<span class="tech-cost-item tech-cost-steel">${tech.cost.Steel} STEEL</span>`);
                if (tech.cost.coins) costs.push(`<span class="tech-cost-item tech-cost-coins">${tech.cost.coins} COINS</span>`);
                if (tech.cost.gold) costs.push(`<span class="tech-cost-item tech-cost-gold">${tech.cost.gold} GOLD</span>`);
                if (tech.cost.oil) costs.push(`<span class="tech-cost-item tech-cost-oil">${tech.cost.oil} OIL</span>`);
                costHtml = costs.join('');
            }
            
            // Update panel content
            infoPanel.innerHTML = `
                <div class="tech-info-title">${tech.name}</div>
                <div class="tech-info-description">${tech.description}</div>
                <div class="tech-info-cost">${costHtml}</div>
                <div class="tech-info-status" style="margin-top: 10px; font-weight: bold; color: ${state === 'researched' ? '#7a977b' : state === 'available' ? '#66d9ff' : '#888'}">
                    ${stateText}
                </div>
            `;
            
            // Remove hidden class
            infoPanel.classList.remove('hidden');
        }
        
        function resetTechInfoPanel() {
            const infoPanel = document.getElementById('tech-info-panel');
            if (!infoPanel) return;
            
            // Show default message
            infoPanel.innerHTML = '<div class="tech-info-default">Hover over a technology to see details</div>';
            infoPanel.classList.add('hidden');
        }

        function createTechNode(container, techId, tech, pos) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'tech-node';
            nodeDiv.dataset.techId = techId;
            nodeDiv.style.left = pos.x + 'px';
            nodeDiv.style.top = pos.y + 'px';

            // Determine node state
            if (gameState.isTechResearched(techId)) {
                nodeDiv.classList.add('researched');
            } else if (gameState.availableTechs.has(techId)) {
                nodeDiv.classList.add('available');
            } else {
                nodeDiv.classList.add('locked');
            }

            const iconDiv = document.createElement('div');
            iconDiv.className = 'tech-node-icon';

            const img = document.createElement('img');
            const iconPath = `./sprites/${tech.icon || 'research.png'}`;
            img.src = iconPath;
            img.alt = tech.name;
            img.onerror = function () {
                this.src = './sprites/research.png';
            };
            iconDiv.appendChild(img);
            nodeDiv.appendChild(iconDiv);

            // Add click handler for researchable nodes
            if (!gameState.isTechResearched(techId) && gameState.availableTechs.has(techId)) {
                nodeDiv.style.cursor = 'pointer';
                nodeDiv.addEventListener('click', function () {
                    console.log(`Attempting to research: ${techId}`);
                    if (gameState.researchTech(techId)) {
                        showNotification(`${tech.name} researched!`, CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
                        renderTechTree();
                        updateButtonStates(); // Update building availability
                    } else {
                        showNotification(`Cannot research ${tech.name}. Check requirements.`, 
                            CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'warning');
                    }
                });
            }

            // Add hover event listeners for info panel
            nodeDiv.addEventListener('mouseenter', function() {
                updateTechInfoPanel(techId, tech);
            });
            
            nodeDiv.addEventListener('mouseleave', function() {
                resetTechInfoPanel();
            });

            // Add hover tooltip
            nodeDiv.title = `${tech.name}\n${tech.description}`;

            container.appendChild(nodeDiv);
            return nodeDiv;
        }

        function makeTechTreeDraggable() {
            const popup = document.getElementById('tech-tree-popup');
            const header = document.querySelector('.tech-tree-header');

            if (!popup || !header) return;

            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;

            header.addEventListener('mousedown', dragStart);
            document.addEventListener('mouseup', dragEnd);
            document.addEventListener('mousemove', drag);

            function dragStart(e) {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;

                isDragging = true;
                header.style.cursor = 'grabbing';
            }

            function dragEnd() {
                initialX = currentX;
                initialY = currentY;

                isDragging = false;
                header.style.cursor = 'move';
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;

                    xOffset = currentX;
                    yOffset = currentY;

                    popup.style.transform = `translate(${currentX}px, ${currentY}px)`;
                }
            }
        }

        function showInfoPopup(button) {
            const infoData = button.dataset.info.split(',');
            const title = infoData[0];
            const description = infoData[1];
            const stats = infoData.slice(2);

            let overlay = document.querySelector('.info-popup-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'info-popup-overlay';
                document.body.appendChild(overlay);
            }

            let popup = document.querySelector('.info-popup');
            if (!popup) {
                popup = document.createElement('div');
                popup.className = 'info-popup';
                document.body.appendChild(popup);
            }

            let statsHtml = '';
            stats.forEach(function (stat) {
                statsHtml += '<div class="info-popup-stat">' + stat + '</div>';
            });

            popup.innerHTML = `
                <div class="info-popup-header">
                    <div class="info-popup-title">${title}</div>
                    <button class="info-popup-close">×</button>
                </div>
                <div class="info-popup-content">
                    <p>${description}</p>
                    <div class="info-popup-stats">
                        ${statsHtml}
                    </div>
                </div>
            `;

            popup.querySelector('.info-popup-close').addEventListener('click', closeInfoPopup);

            overlay.style.display = 'block';
            popup.style.display = 'block';
        }

        function closeInfoPopup() {
            const overlay = document.querySelector('.info-popup-overlay');
            const popup = document.querySelector('.info-popup');

            if (overlay) overlay.style.display = 'none';
            if (popup) popup.style.display = 'none';
        }

        function showBuildingInfo(building) {
            const buildingInfoPopup = document.getElementById('building-info-popup');
            const buildingInfoOverlay = document.getElementById('building-info-overlay');
            
            // Set building title
            document.getElementById('building-info-title').textContent = getBuildingName(building);
            
            // Set building icon
            document.getElementById('building-icon').src = building.getSprite();
            
            // Set building description
            document.getElementById('building-description').textContent = getBuildingDescription(building);
            
            // Set up module slots (will be hidden if no module research)
            setupModuleSlots(building);
            
            // Show the popup
            buildingInfoPopup.style.display = 'flex';
            buildingInfoOverlay.style.display = 'block';
            
            // Store reference to the selected building
            window.currentBuilding = building;
        }
        
        function canBuildingHaveModules(building) {
            // Walls cannot have modules
            if (building.type === 'wall') {
                return false;
            }
            
            // All other building types (tech, army) can have modules
            return true;
        }
        
        function hasModuleResearch() {
            // Player needs to research either module_research or both speed_module and defense_module
            return gameState.isTechResearched('module_research') || 
                   (gameState.isTechResearched('speed_module') && gameState.isTechResearched('defense_module'));
        }

        function getBuildingName(building) {
            switch(building.type) {
                case 'wall':
                    switch(building.subtype) {
                        case 'stone': return 'Wall';
                        case 'steel': return 'Steel Wall';
                        case 'spike': return 'Spike';
                        case 'fortress': return 'Fortress';
                        default: return building.subtype.charAt(0).toUpperCase() + building.subtype.slice(1);
                    }
                case 'tech':
                    switch(building.subtype) {
                        case 'miner': return 'Steel Mine';
                        case 'goldminer': return 'Gold Mine';
                        case 'coinmaker': return 'Bank';
                        case 'oilrig': return 'Oil Rig';
                        case 'turret': return 'Turret';
                        case 'goldturret': return 'Gold Turret';
                        case 'bomb': return 'Bomb';
                        case 'supply': return 'Supply Drop';
                        case 'campfire': return 'Campfire';
                        default: return building.subtype.charAt(0).toUpperCase() + building.subtype.slice(1);
                    }
                case 'army':
                    switch(building.subtype) {
                        case 'scout': return 'Soldier';
                        case 'knight': return 'Knight';
                        case 'archer': return 'Archer';
                        case 'tank': return 'Tank';
                        case 'siegetower': return 'Siege Tower';
                        case 'king': return 'King';
                        case 'barrack': return 'Barrack';
                        default: return building.subtype.charAt(0).toUpperCase() + building.subtype.slice(1);
                    }
                default: return building.subtype ? building.subtype.charAt(0).toUpperCase() + building.subtype.slice(1) : 'Building';
            }
        }

        function getBuildingDescription(building) {
            switch(building.type) {
                case 'wall':
                    switch(building.subtype) {
                        case 'stone': return 'Basic defensive structure to block enemy movement. Health: 1.';
                        case 'steel': return 'Stronger wall with increased durability. Health: 3.';
                        case 'spike': return 'Damages enemies that walk over it. Health: 3.';
                        case 'fortress': return 'Your main base that must be protected. Health: 5.';
                        default: return 'Wall structure.';
                    }
                case 'tech':
                    switch(building.subtype) {
                        case 'miner': return 'Generates 5 steel per turn. Health: 2.';
                        case 'goldminer': return 'Generates 1 gold per turn. Health: 2.';
                        case 'coinmaker': return 'Generates 5 coins per turn. Health: 2.';
                        case 'oilrig': return 'Generates 1 oil per turn. Health: 2.';
                        case 'turret': return 'Attacks enemies within range 3. Health: 2, Shots: 8.';
                        case 'goldturret': return 'Powerful turret with range 3. Health: 2, Shots: 10.';
                        case 'bomb': return 'Explodes when enemy approaches damaging area. Health: 1.';
                        case 'supply': return 'Randomly generates resources. Health: 1.';
                        case 'campfire': return 'Boosts nearby resource buildings by 50%. Health: 1.';
                        default: return 'Technology building.';
                    }
                case 'army':
                    switch(building.subtype) {
                        case 'scout': return 'Basic unit with balanced stats. Health: 1, Range: 1, Movement: 1.';
                        case 'knight': return 'Fast-moving unit with high mobility. Health: 1, Range: 1, Movement: 5.';
                        case 'archer': return 'Ranged unit that can attack from a distance. Health: 1, Range: 4, Movement: 1.';
                        case 'tank': return 'Heavy unit with high health. Health: 5, Range: 1, Movement: 1.';
                        case 'siegetower': return 'Powerful siege unit with long range. Health: 1, Range: 4, Movement: 1.';
                        case 'king': return 'Command unit that boosts nearby army. Health: 25, Range: 2, Movement: 2.';
                        case 'barrack': return 'Automatically spawns soldier units. Health: 2.';
                        default: return 'Army unit.';
                    }
                default: return 'Building structure.';
            }
        }

        function setupModuleSlots(building) {
            const moduleSlotsContainer = document.querySelector('.module-slots-container');
            
            // Check if building can have modules and if player has researched module tech
            if (!canBuildingHaveModules(building) || !hasModuleResearch()) {
                // Hide module slots and show locked message
                if (moduleSlotsContainer) {
                    moduleSlotsContainer.style.display = 'none';
                    
                    // Check if locked message already exists
                    let lockedMessage = moduleSlotsContainer.querySelector('.modules-locked-message');
                    if (!lockedMessage) {
                        lockedMessage = document.createElement('div');
                        lockedMessage.className = 'modules-locked-message';
                        lockedMessage.innerHTML = '<strong>🔒 Modules Locked</strong><br>Research <em>Module Research</em> in the Tech Tree to unlock modules for this building.';
                        moduleSlotsContainer.parentNode.insertBefore(lockedMessage, moduleSlotsContainer.nextSibling);
                    }
                    lockedMessage.style.display = 'block';
                }
                return;
            }
            
            // Show module slots and hide locked message
            if (moduleSlotsContainer) {
                moduleSlotsContainer.style.display = 'flex';
                
                // Hide locked message if it exists
                const lockedMessage = moduleSlotsContainer.parentNode.querySelector('.modules-locked-message');
                if (lockedMessage) {
                    lockedMessage.style.display = 'none';
                }
            }
            
            // Set up module slot 1
            const moduleSlot1 = document.getElementById('module-slot-1');
            
            // Set up module slot 2
            const moduleSlot2 = document.getElementById('module-slot-2');
            
            // Clear any previous event listeners by cloning elements
            const newModuleSlot1 = moduleSlot1.cloneNode(true);
            const newModuleSlot2 = moduleSlot2.cloneNode(true);
            moduleSlot1.parentNode.replaceChild(newModuleSlot1, moduleSlot1);
            moduleSlot2.parentNode.replaceChild(newModuleSlot2, moduleSlot2);
            
            // Update module slot displays
            updateModuleSlotDisplay(building, 1);
            updateModuleSlotDisplay(building, 2);
            
            // Set up event listeners for module slots
            newModuleSlot1.addEventListener('click', () => showModuleSelectionPopup(building, 1));
            newModuleSlot2.addEventListener('click', () => showModuleSelectionPopup(building, 2));
            
            // Set up event listeners for module selection popup
            setupModuleSelectionPopup(building);
        }

        function updateModuleSlotDisplay(building, slotNumber) {
            const slotElement = document.getElementById(`module-slot-${slotNumber}`);
            const iconElement = slotElement.querySelector('.module-slot-icon');
            const tierElement = slotElement.querySelector('.module-slot-tier');
            
            // Reset classes
            slotElement.classList.remove('equipped', 'empty');
            
            if (building.modules && building.modules.length >= slotNumber && building.modules[slotNumber - 1]) {
                const module = building.modules[slotNumber - 1];
                const moduleInfo = module.split('-'); // Format: type-tier (e.g., speed-2)
                const type = moduleInfo[0];
                const tier = moduleInfo[1] || '1'; // Default to tier 1 if not specified
                
                // Add equipped class
                slotElement.classList.add('equipped');
                
                // Set icon based on module type
                if (type === 'speed') {
                    iconElement.innerHTML = '<img src="./sprites/speedmod.png" alt="Speed Module">';
                } else if (type === 'defense') {
                    iconElement.innerHTML = '<img src="./sprites/defensemod.png" alt="Defense Module">';
                }
                
                // Set tier indicator
                tierElement.textContent = tier;
                
                // Show tier indicator
                tierElement.style.display = 'flex';
            } else {
                // No module equipped
                slotElement.classList.add('empty');
                iconElement.innerHTML = '';
                tierElement.style.display = 'none';
            }
        }
        
        function showModuleSelectionPopup(building, slotNumber) {
            const popup = document.getElementById('module-selection-popup');
            const overlay = document.getElementById('module-selection-overlay');
            
            // Store the current building and slot number
            window.currentBuilding = building;
            window.currentSlot = slotNumber;
            
            // Update affordability for each module option
            updateModuleAffordability();
            
            // Show the popup
            popup.style.display = 'flex';
            overlay.style.display = 'block';
        }
        
        function setupModuleSelectionPopup(building) {
            // Close button
            const closeBtn = document.getElementById('module-close-btn');
            const overlay = document.getElementById('module-selection-overlay');
            
            if (closeBtn) {
                closeBtn.onclick = closeModuleSelectionPopup;
            }
            
            if (overlay) {
                overlay.onclick = closeModuleSelectionPopup;
            }
            
            // Check if player has researched module tech
            const hasSpeedModuleTech = gameState.isTechResearched('speed_module') || gameState.isTechResearched('module_research');
            const hasDefenseModuleTech = gameState.isTechResearched('defense_module') || gameState.isTechResearched('module_research');
            
            // Update visibility of module options
            document.querySelectorAll('.module-option').forEach(option => {
                const moduleType = option.dataset.module;
                
                if ((moduleType === 'speed' && !hasSpeedModuleTech) || 
                    (moduleType === 'defense' && !hasDefenseModuleTech)) {
                    option.style.display = 'none';
                } else {
                    option.style.display = 'flex';
                }
            });
            
            // Module option click handlers
            document.querySelectorAll('.module-option').forEach(option => {
                option.onclick = function() {
                    if (this.classList.contains('unaffordable')) {
                        showNotification('Not enough resources!', building.x, building.y, 'warning');
                        return;
                    }
                    
                    const moduleType = this.dataset.module;
                    const moduleTier = this.dataset.tier;
                    
                    if (window.currentBuilding && window.currentSlot) {
                        equipModule(window.currentBuilding, window.currentSlot, moduleType, moduleTier);
                    }
                    
                    closeModuleSelectionPopup();
                };
            });
        }
        
        function closeModuleSelectionPopup() {
            const popup = document.getElementById('module-selection-popup');
            const overlay = document.getElementById('module-selection-overlay');
            
            popup.style.display = 'none';
            overlay.style.display = 'none';
            
            // Reset all module options to visible
            document.querySelectorAll('.module-option').forEach(option => {
                option.style.display = 'flex';
            });
            
            // Clear references
            window.currentBuilding = null;
            window.currentSlot = null;
        }
        
        function updateModuleAffordability() {
            const options = document.querySelectorAll('.module-option');
            
            options.forEach(option => {
                // Check if the option is visible first
                if (window.getComputedStyle(option).display === 'none') {
                    return;
                }
                
                const cost = parseInt(option.querySelector('.module-cost').textContent);
                
                // Check if player has enough iron (steel)
                if (gameState.resources.Steel >= cost) {
                    option.classList.remove('unaffordable');
                } else {
                    option.classList.add('unaffordable');
                }
            });
        }
        
        function updateModuleSelectOptions(selectElement) {
            // Clear existing options except the first one (No Module)
            while (selectElement.children.length > 1) {
                selectElement.removeChild(selectElement.lastChild);
            }
            
            // Add options based on researched modules
            if (gameState.isTechResearched('speed_module')) {
                const speedOption = document.createElement('option');
                speedOption.value = 'speed';
                speedOption.textContent = 'Speed Module';
                selectElement.appendChild(speedOption);
            }
            
            if (gameState.isTechResearched('defense_module')) {
                const defenseOption = document.createElement('option');
                defenseOption.value = 'defense';
                defenseOption.textContent = 'Defense Module';
                selectElement.appendChild(defenseOption);
            }
        }

        function equipModule(building, slotNumber, moduleType, moduleTier) {
            // Check if player has enough resources
            let cost;
            if (moduleType === 'speed') {
                switch(moduleTier) {
                    case '1': cost = 145; break;
                    case '2': cost = 290; break;
                    case '3': cost = 580; break;
                    default: cost = 145; break;
                }
            } else if (moduleType === 'defense') {
                switch(moduleTier) {
                    case '1': cost = 50; break;
                    case '2': cost = 100; break;
                    case '3': cost = 200; break;
                    default: cost = 50; break;
                }
            }
            
            if (gameState.resources.Steel < cost) {
                showNotification('Not enough steel to equip this module!', building.x, building.y, 'warning');
                return;
            }
            
            // Create module string in format: type-tier (e.g., speed-2)
            const moduleString = `${moduleType}-${moduleTier}`;
            
            // Check if this slot already has a module and remove its effect
            if (building.modules && building.modules.length >= slotNumber && building.modules[slotNumber - 1]) {
                const oldModule = building.modules[slotNumber - 1];
                const oldModuleParts = oldModule.split('-');
                building.removeModule(oldModuleParts[0]);
            }
            
            // Add the new module to the appropriate slot
            if (!building.modules) building.modules = [];
            
            // Set the module in the correct slot
            building.modules[slotNumber - 1] = moduleString;
            
            // Apply the module effect
            building.applyModuleEffect(moduleType);
            
            // Spend the resources
            gameState.spendResources({ Steel: cost });
            
            showNotification(`${moduleType === 'speed' ? 'Speed' : 'Defense'} Module (T${moduleTier}) equipped!`, building.x, building.y, 'success');
            
            // Update the UI
            setupModuleSlots(building);
            updateDisplay();
        }

        function unequipModule(building, slotNumber) {
            // Check if this slot has a module
            if (building.modules && building.modules.length >= slotNumber && building.modules[slotNumber - 1]) {
                const module = building.modules[slotNumber - 1];
                const moduleParts = module.split('-');
                const moduleType = moduleParts[0];
                
                // Remove the module effect
                building.removeModuleEffect(moduleType);
                
                // Remove the module from the slot
                building.modules[slotNumber - 1] = null;
                
                // Clean up null modules from the end
                while (building.modules.length > 0 && building.modules[building.modules.length - 1] === null) {
                    building.modules.pop();
                }
                
                showNotification(`${moduleType === 'speed' ? 'Speed' : 'Defense'} Module unequipped!`, building.x, building.y, 'success');
                
                // Update the UI
                setupModuleSlots(building);
                updateDisplay();
            } else {
                showNotification('No module to unequip in this slot!', building.x, building.y, 'warning');
            }
        }

        function closeBuildingInfo() {
            const buildingInfoPopup = document.getElementById('building-info-popup');
            const buildingInfoOverlay = document.getElementById('building-info-overlay');
            
            buildingInfoPopup.style.display = 'none';
            buildingInfoOverlay.style.display = 'none';
            
            // Also close the module selection popup if it's open
            closeModuleSelectionPopup();
            
            // Clear the reference
            window.currentBuilding = null;
        }

        function showTooltip(element, text) {
            hideTooltip();

            const tooltip = document.createElement('div');
            tooltip.className = 'tech-tooltip';
            tooltip.innerHTML = text;
            tooltip.id = 'tech-tree-tooltip';

            tooltip.style.opacity = '0';

            document.querySelector('.tech-tree-content').appendChild(tooltip);

            setTimeout(() => {
                if (tooltip.parentNode) {
                    tooltip.style.opacity = '1';
                }
            }, 50);
        }

        function updateTooltipPosition(e) {
            const tooltip = document.getElementById('tech-tree-tooltip');
            if (!tooltip) return;

            const techTreeContent = document.querySelector('.tech-tree-content');
            const techTreeRect = techTreeContent.getBoundingClientRect();

            let left = e.clientX - techTreeRect.left + 10;
            let top = e.clientY - techTreeRect.top + 10;

            if (tooltip.offsetWidth) {
                if (left + tooltip.offsetWidth > techTreeRect.width - 10) {
                    left = techTreeRect.width - tooltip.offsetWidth - 10;
                }
                if (top + tooltip.offsetHeight > techTreeRect.height - 10) {
                    top = techTreeRect.height - tooltip.offsetHeight - 10;
                }
                if (left < 10) {
                    left = 10;
                }
                if (top < 10) {
                    top = 10;
                }
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tech-tree-tooltip');
            if (tooltip) {
                tooltip.style.opacity = '0';
                setTimeout(() => {
                    if (tooltip.parentNode) {
                        tooltip.parentNode.removeChild(tooltip);
                    }
                }, 200);
            }
        }

        function makeFoldersDraggable() {
            document.querySelectorAll('.folder-content').forEach(function (folderContent) {
                const header = folderContent.querySelector('.folder-header');
                if (!header) return;

                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                let xOffset = 0;
                let yOffset = 0;

                header.addEventListener('mousedown', dragStart);
                document.addEventListener('mouseup', dragEnd);
                document.addEventListener('mousemove', drag);

                function dragStart(e) {
                    if (e.target.closest('.folder-close')) return;

                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;

                    isDragging = true;
                    header.style.cursor = 'grabbing';
                }

                function dragEnd() {
                    initialX = currentX;
                    initialY = currentY;

                    isDragging = false;
                    header.style.cursor = 'move';
                }

                function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;

                        xOffset = currentX;
                        yOffset = currentY;

                        setTranslate(currentX, currentY, folderContent);
                    }
                }

                function setTranslate(xPos, yPos, el) {
                    el.style.transform = 'translate3d(' + xPos + 'px, ' + yPos + 'px, 0)';
                }
            });
        }

        function restartGame() {
            if (confirm('Are you sure you want to restart the game?')) {
                gameState.reset();
                initGame();
            }
        }

        function saveGame() {
            const gameData = {
                resources: gameState.resources,
                turn: gameState.turn,
                wave: gameState.wave,
                waveBreakTurns: gameState.waveBreakTurns,
                inWaveBreak: gameState.inWaveBreak,
                enemiesRemaining: gameState.enemiesRemaining,
                researchedTechs: Array.from(gameState.researchedTechs),
                grid: serializeGrid()
            };

            const blob = new Blob([JSON.stringify(gameData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `coregrid_save_${new Date().toISOString().slice(0, 10)}.coregrid`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('Game saved successfully!', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
        }

        function loadGame(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const gameData = JSON.parse(e.target.result);

                    if (!gameData.resources || !gameData.grid) {
                        throw new Error('Invalid save file');
                    }

                    gameState.resources = gameData.resources;
                    gameState.turn = gameData.turn;
                    gameState.wave = gameData.wave;
                    gameState.waveBreakTurns = gameData.waveBreakTurns || 0;
                    gameState.inWaveBreak = gameData.inWaveBreak || false;
                    gameState.enemiesRemaining = gameData.enemiesRemaining || 0;

                    gameState.researchedTechs = new Set(gameData.researchedTechs || []);
                    gameState.updateAvailableTechs();

                    deserializeGrid(gameData.grid);

                    showNotification('Game loaded successfully!', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
                    updateDisplay();
                } catch (error) {
                    showNotification('Error loading game: Invalid save file', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'danger');
                    console.error('Error loading game:', error);
                }
            };
            reader.readAsText(file);
        }

        function serializeGrid() {
            const gridData = [];
            for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                const row = [];
                for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                    const obj = gameState.grid[y][x];
                    if (obj === 'player') {
                        row.push('player');
                    } else if (obj && obj.type) {
                        row.push({
                            type: obj.type,
                            subtype: obj.subtype,
                            health: obj.health,
                            maxHealth: obj.maxHealth,
                            modules: obj.modules || [],
                            ...(obj.type === 'tech' && (obj.subtype === 'turret' || obj.subtype === 'goldturret') ? { shotsLeft: obj.shotsLeft } : {}),
                            ...(obj.type === 'army' && obj.subtype === 'barrack' ? { spawnCounter: obj.spawnCounter } : {})
                        });
                    } else {
                        row.push(null);
                    }
                }
                gridData.push(row);
            }
            return gridData;
        }

        function deserializeGrid(gridData) {
            gameState.grid = Array(CONFIG.GRID_SIZE_Y).fill().map(() => Array(CONFIG.GRID_SIZE_X).fill(null));
            gameState.objects.clear();

            for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                    const objData = gridData[y][x];
                    if (objData === 'player') {
                        gameState.grid[y][x] = 'player';
                    } else if (objData && objData.type) {
                        let obj;
                        switch (objData.type) {
                            case 'wall':
                                obj = new Wall(x, y, objData.subtype);
                                break;
                            case 'tech':
                                obj = new Tech(x, y, objData.subtype);
                                break;
                            case 'army':
                                obj = new Army(x, y, objData.subtype);
                                break;

                            case 'enemy':
                                obj = new Enemy(x, y, objData.subtype);
                                break;
                            default:
                                continue;
                        }

                        obj.health = objData.health;
                        obj.maxHealth = objData.maxHealth;
                        
                        // Restore modules
                        if (objData.modules && objData.modules.length > 0) {
                            obj.modules = [...objData.modules];
                            // Re-apply module effects
                            objData.modules.forEach(module => {
                                obj.applyModuleEffect(module);
                            });
                        }

                        if (objData.type === 'tech' && (objData.subtype === 'turret' || objData.subtype === 'goldturret') && objData.shotsLeft) {
                            obj.shotsLeft = objData.shotsLeft;
                        }

                        if (objData.type === 'army' && objData.subtype === 'barrack' && objData.spawnCounter) {
                            obj.spawnCounter = objData.spawnCounter;
                        }

                        gameState.grid[y][x] = obj;
                        gameState.objects.set(obj.id, obj);
                    }
                }
            }
        }

        document.addEventListener('keydown', function (event) {
            // Handle module selection popup close with Escape key
            if (event.key === 'Escape') {
                closeModuleSelectionPopup();
                closeBuildingInfo();
                return;
            }
            
            if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                return;
            }

            event.preventDefault();

            switch (event.key) {
                case 'ArrowUp':
                    moveCamera(0, -1);
                    break;
                case 'ArrowDown':
                    moveCamera(0, 1);
                    break;
                case 'ArrowLeft':
                    moveCamera(-1, 0);
                    break;
                case 'ArrowRight':
                    moveCamera(1, 0);
                    break;
            }

            updateDisplay();
        });

        function moveCamera(dx, dy) {
            gameState.cameraOffset.x += dx;
            gameState.cameraOffset.y += dy;

            updateGridFromWorldObjects();
        }

        function updateGridFromWorldObjects() {
            gameState.grid = Array(CONFIG.GRID_SIZE_Y).fill().map(() => Array(CONFIG.GRID_SIZE_X).fill(null));

            gameState.worldObjects.forEach(obj => {
                const gridX = obj.x - gameState.cameraOffset.x;
                const gridY = obj.y - gameState.cameraOffset.y;

                if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X &&
                    gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                    gameState.grid[gridY][gridX] = obj;
                }
            });

            const playerWorldX = CONFIG.PLAYER_START.x;
            const playerWorldY = CONFIG.PLAYER_START.y;
            const playerGridX = playerWorldX - gameState.cameraOffset.x;
            const playerGridY = playerWorldY - gameState.cameraOffset.y;

            if (playerGridX >= 0 && playerGridX < CONFIG.GRID_SIZE_X &&
                playerGridY >= 0 && playerGridY < CONFIG.GRID_SIZE_Y) {
                gameState.grid[playerGridY][playerGridX] = 'player';
            }
        }

        function addObjectToWorld(obj) {
            gameState.worldObjects.set(obj.id, obj);

            const gridX = obj.x - gameState.cameraOffset.x;
            const gridY = obj.y - gameState.cameraOffset.y;

            if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X &&
                gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                gameState.objects.set(obj.id, obj);
                gameState.grid[gridY][gridX] = obj;
            }
        }

        function debugNextWave() {
            console.log("Debug: Manually triggering next wave");
            spawnNextWave();
        }

        let cheatSequence = [];
        const targetSequence = ['i', 'l', 'i', 'k', 'e', 'f', 'e', 'm', 'b', 'o', 'y', 's'];

        document.addEventListener('keydown', (event) => {
            cheatSequence.push(event.key.toLowerCase());

            if (cheatSequence.length > 12) {
                cheatSequence.shift();
            }

            if (cheatSequence.length === 12 &&
                cheatSequence[0] === targetSequence[0] &&
                cheatSequence[1] === targetSequence[1] &&
                cheatSequence[2] === targetSequence[2] &&
                cheatSequence[3] === targetSequence[3] &&
                cheatSequence[4] === targetSequence[4] &&
                cheatSequence[5] === targetSequence[5] &&
                cheatSequence[6] === targetSequence[6] &&
                cheatSequence[7] === targetSequence[7] &&
                cheatSequence[8] === targetSequence[8] &&
                cheatSequence[9] === targetSequence[9] &&
                cheatSequence[10] === targetSequence[10] &&
                cheatSequence[11] === targetSequence[11]) {

                gameState.resources.Steel += 7000;
                gameState.resources.coins += 7000;
                gameState.resources.gold += 7000;

                updateDisplay();

                showNotification('hell yeah! +7000 Steel, Coins, and Gold', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');

                cheatSequence = [];
            }
        });

        document.addEventListener('DOMContentLoaded', async function() {
            await loadTechTree();
            initGame();
        });
    </script>
</body>

</html>