<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoreGrid - Strategy Defense Game</title>
    <link rel="icon" href="./sprites/tower.png">
    <meta name="description"
        content="CoreGrid - a strategy game where you build and defend your base against waves of enemies">
    <meta name="keywords" content="grid, game, management, resource, online game, strategy game">
    <meta name="author" content="A_I_X">
    <meta name="theme-color" content="#121212">

    <style>
        :root {
            --bg-primary: #2b2b2b;
            --bg-secondary: #3a3a3a;
            --bg-tertiary: #404040;
            --border-color: #555;
            --text-primary: #e0e0e0;
            --text-secondary: #c0c0c0;
            --accent-primary: #66d9ff;
            --accent-secondary: #99ecff;
            --danger: #dd7e77;
            --success: #7a977b;
            --warning: #ceab77;
            --cell-size: 42px;
            --grid-gap: 6px;
            --border-radius: 4px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', sans-serif;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            padding: 30px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            max-width: 900px;
            width: 100%;
            text-align: center;
        }

        .game-header {
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--accent-primary);
            text-align: center;
            border-bottom: 4px solid var(--border-color);
            padding-bottom: 10px;
            letter-spacing: 1px;
        }

        .game-subtitle {
            color: var(--text-secondary);
            margin-bottom: 20px;
            text-align: center;
        }

        .ui-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding: 20px;
            background: #353535;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            box-shadow: 0 6px 0 rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .resources {
            display: flex;
            gap: 20px;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: var(--text-primary);
            padding: 10px 15px;
            background: #353535;
            border-radius: var(--border-radius);
            border: 2px solid #7a7a7a;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .resource img {
            width: 24px;
            height: 24px;
        }

        .controls-folder {
            display: flex;
            gap: 15px;
        }

        .folder {
            background: var(--bg-tertiary);
            border-radius: var(--border-radius);
            border: 3px solid #7a7a7a;
            min-width: 100px;
            position: relative;
            z-index: 100;
            transition: all 0.2s ease;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
            display: inline-block;
        }

        .folder-title {
            padding: 10px 12px;
            background: #353535;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #ddd;
            border-radius: var(--border-radius);
            border: 3px solid #7a7a7a;
            display: flex;
            align-items: center;
            gap: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: inset 0 -3px 0 rgba(0, 0, 0, 0.2);
            font-size: 12px;
            user-select: none;
        }

        .folder-title img {
            width: 24px;
            height: 24px;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
        }

        .folder-content {
            display: none;
            flex-direction: column;
            gap: 8px;
            padding: 0;
            position: fixed;
            background: var(--bg-tertiary);
            border-radius: var(--border-radius);
            border: 3px solid #7a7a7a;
            width: 200px;
            z-index: 1000;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
            min-width: 140px;
        }

        .folder-header {
            padding: 8px 12px;
            background: #3a3a3a;
            font-weight: bold;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid #7a7a7a;
            user-select: none;
        }

        .folder-header-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .folder-close {
            background: none;
            border: none;
            color: #ddd;
            cursor: pointer;
            font-size: 16px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }

        .folder-close:hover {
            background: #ff5555;
        }

        .folder-content.draggable {
            position: fixed;
        }

        .folder-buttons {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .folder.open .folder-content {
            display: block;
            animation: dropdownFade 0.2s ease;
        }

        @keyframes dropdownFade {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .folder-content .btn {
            width: 100%;
            height: auto;
            min-height: 50px;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            background-color: #353535;
            color: #ddd;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            font-size: 11px;
            text-align: left;
            padding: 6px 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .folder-content .btn:hover {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
            transform: translateX(5px);
        }

        .folder-content .btn img {
            width: 20px;
            height: 20px;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
            margin: 0;
            max-width: 20px;
            max-height: 20px;
        }

        .btn-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-right {
            display: flex;
            align-items: center;
        }

        .btn-left img {
            width: 20px;
            height: 20px;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .btn-left span {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .btn-right .lowcol {
            font-weight: bold;
            color: #aaa;
        }

        .btn {
            width: 100px;
            height: 80px;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            background-color: #353535;
            color: #ddd;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            font-size: 11px;
            text-align: center;
            padding: 5px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .info-icon {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 16px;
            height: 16px;
            background-color: #444;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: #ddd;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
            border: 1px solid #7a7a7a;
        }

        .btn:hover .info-icon {
            opacity: 1;
        }

        .info-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            padding: 15px;
            width: auto;
            min-width: 250px;
            max-width: 350px;
            z-index: 2000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
            font-size: 12px;
        }

        .info-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #555;
        }

        .info-popup-title {
            font-weight: bold;
            font-size: 14px;
            text-transform: uppercase;
        }

        .info-popup-close {
            background: none;
            border: none;
            color: #ddd;
            cursor: pointer;
            font-size: 18px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }

        .info-popup-close:hover {
            background: #ff5555;
        }

        .info-popup-content {
            font-size: 12px;
            line-height: 1.5;
        }

        .info-popup-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 10px 0;
        }

        .info-popup-stat {
            background: #444;
            padding: 5px 8px;
            border-radius: 3px;
            font-size: 11px;
            white-space: nowrap;
        }

        .info-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1999;
            display: none;
        }

        .btn:hover {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
            transform: translateY(-2px);
        }

        .btn img {
            width: 16px;
            height: 16px;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
            margin: 0 auto;
            max-width: 16px;
            max-height: 16px;
        }

        .btn.active {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
        }

        .btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn.disabled:hover {
            transform: none;
            background: var(--bg-tertiary);
        }

        .btn.researched {
            background-color: #7a977b;
            border-color: #5a775b;
        }

        .btn.researched:hover {
            background-color: #8aac8b;
            border-color: #6a8c6b;
        }

        .btn.available {
            background-color: #66d9ff;
            border-color: #46b9df;
            color: #111;
        }

        .btn.available:hover {
            background-color: #76e9ff;
            border-color: #56c9ef;
        }

        .game-grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(25, 1fr);
            grid-template-rows: repeat(15, 1fr);
            gap: var(--grid-gap);
            background: #353535;
            border: 2px solid #7a7a7a;
            padding: 15px;
            border-radius: var(--border-radius);
            justify-content: center;
            align-content: center;
            min-height: 650px;
            aspect-ratio: 25 / 15;
            box-shadow: 0 6px 0 rgba(0, 0, 0, 0.2);
        }

        .grid-cell {
            background: #2f811b;
            border: 3px solid #398d24;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #ccc;
            border-radius: var(--border-radius);
            aspect-ratio: 1 / 1;
        }

        .grid-cell:hover {
            background: #3ea326;
            border: 3px solid #4cb72f;
            transform: translateY(-2px);
            border-radius: var(--border-radius);
            z-index: 2;
        }

        .grid-cell.selected {
            box-shadow: 0 0 8px var(--accent-secondary);
            border-color: var(--accent-secondary);
            background: rgba(255, 215, 0, 0.2);
        }

        .grid-cell.valid-move {
            background: rgba(76, 175, 80, 0.3);
            border-color: var(--accent-primary);
            cursor: pointer;
        }

        .grid-cell.valid-attack {
            background: rgba(244, 67, 54, 0.3);
            border-color: var(--danger);
            cursor: crosshair;
        }

        .grid-cell.valid-attack:hover {
            background: rgba(244, 67, 54, 0.5);
        }

        .grid-cell .object-sprite {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            border-radius: 2px;
        }

        .grid-cell .object-sprite img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
        }

        .game-info {
            display: flex;
            gap: 25px;
            margin-bottom: 25px;
        }

        .turn-info,
        .wave-info {
            padding: 20px;
            background: #353535;
            border-radius: var(--border-radius);
            border: 2px solid #7a7a7a;
            text-align: center;
            color: var(--text-primary);
            flex: 1;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .info-panel {
            padding: 20px;
            background: #353535;
            border-radius: var(--border-radius);
            border: 2px solid #7a7a7a;
            text-align: left;
            color: var(--text-primary);
            margin-bottom: 25px;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .info-panel h3 {
            margin-bottom: 10px;
            color: var(--accent-primary);
            border-left: 5px solid var(--accent-primary);
            padding-left: 10px;
        }

        .info-panel p {
            color: var(--text-secondary);
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .floating-sidebar {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
            background: #353535;
            border-radius: var(--border-radius);
            border: 2px solid #7a7a7a;
            z-index: 1000;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        .control-btn {
            padding: 12px 20px;
            border: 2px solid #7a7a7a;
            background-color: #353535;
            color: #ddd;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .control-btn:hover {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
            transform: translateY(-2px);
        }

        .control-btn.primary {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
        }

        .control-btn.warning {
            background: var(--warning);
            color: white;
            border-color: #7a7a7a;
        }

        .health-bar {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            height: 3px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            border: 1px solid #555;
        }

        .health-fill {
            height: 100%;
            background: var(--success);
            transition: width 0.3s ease;
        }

        .notification {
            padding: 15px 20px;
            background: #353535;
            color: var(--text-primary);
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            animation: slideIn 0.3s ease;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
            width: 300px;
            margin-bottom: 10px;
        }

        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }

        .lowcol {
            color: #858585;
        }

        .card {
            background: #353535;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            padding: 25px;
            margin-bottom: 25px;
            transition: transform 0.15s ease, border-color 0.2s ease;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .card:hover {
            transform: scale(1.01);
            border-color: var(--accent-primary);
        }

        .card h2 {
            margin-bottom: 10px;
            color: #e8e8e8;
            font-size: 1.4rem;
        }

        .card p {
            color: var(--text-secondary);
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .text-section h2 {
            color: #eee;
            border-left: 5px solid var(--accent-primary);
            padding-left: 10px;
            margin-bottom: 15px;
        }

        .highlight {
            background-color: #353535;
            border: 2px solid #7a7a7a;
            padding: 20px;
            color: #ddd;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 25px 0;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #111111;
            color: #fff;
            text-align: left;
            border-radius: 4px;
            padding: 8px;
            position: absolute;
            z-index: 1001;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 11px;
            line-height: 1.4;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #303030 transparent transparent transparent;
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 0;
            pointer-events: none;
            opacity: 0;
        }

        .particle-effect {
            position: absolute;
            pointer-events: none;
            z-index: 999;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .folder-buttons .btn {
            position: relative;
        }

        .tech-tree-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #353535;
            border: 3px solid #7a7a7a;
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 1000px;
            height: 80vh;
            z-index: 2000;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .tech-tree-header {
            padding: 15px 20px;
            background: #3a3a3a;
            border-bottom: 2px solid #7a7a7a;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }

        .tech-tree-header h2 {
            margin: 0;
            color: var(--accent-primary);
            font-size: 1.5rem;
        }

        .tech-tree-close {
            background: none;
            border: none;
            color: #ddd;
            cursor: pointer;
            font-size: 24px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }

        .tech-tree-close:hover {
            background: #ff5555;
        }

        .tech-tree-content {
            padding: 25px;
            overflow: auto;
            flex-grow: 1;
            position: relative;
            background: #2b2b2b;
            min-height: 700px;
            background-image:
                radial-gradient(circle at 10px 10px, rgba(100, 100, 100, 0.1) 1px, transparent 0);
            background-size: 30px 30px;
        }

        .tech-tree-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1999;
            display: none;
        }

        .tech-node {
            position: absolute;
            width: 90px;
            height: 90px;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            background: linear-gradient(145deg, #3a3a3a, #2d2d2d);
            color: #ddd;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.15);
            text-align: center;
            z-index: 10;
            font-size: 12px;
            overflow: hidden;
        }

        .tech-node::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: #7a7a7a;
            border-radius: var(--border-radius) var(--border-radius) 0 0;
        }

        .tech-node:hover {
            transform: translateY(-5px) scale(1.15);
            z-index: 20;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border-color: var(--accent-primary);
            background: linear-gradient(145deg, #4a4a4a, #3a3a3a);
        }

        .tech-node.researched {
            background: linear-gradient(145deg, #7a977b, #6a876b);
            border-color: #5a775b;
        }

        .tech-node.researched::before {
            background: #5a775b;
        }

        .tech-node.available {
            background: linear-gradient(145deg, #66d9ff, #56c9ef);
            border-color: #46b9df;
            color: #111;
        }

        .tech-node.available::before {
            background: #46b9df;
        }

        .tech-node.available:hover {
            background: linear-gradient(145deg, #76e9ff, #66d9ff);
            border-color: #56c9ef;
        }

        .tech-node.locked {
            background: linear-gradient(145deg, #4a4a4a, #3a3a3a);
            border-color: #555;
            opacity: 1;
            cursor: not-allowed;
        }

        .tech-node.locked::before {
            background: #555;
        }

        .tech-node.locked:hover {
            transform: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border-color: #555;
        }

        .tech-tooltip {
            position: absolute;
            background: #66d9ff;
            outline: 3px solid #64d1f5;
            color: #111;
            padding: 8px 12px;
            border-radius: 4px 24px 24px 24px;
            font-size: 13px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transform: translate(0, 0);
        }

        .tech-node-icon {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.25);
            padding: 10px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .tech-node-icon img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .tech-node-name {
            display: none;
        }

        .tech-node-cost {
            display: none;
        }

        .tech-node-status {
            display: none;
        }

        .tech-node.researched .tech-node-status {
            background: #5a775b;
            color: #e0ffe0;
        }

        .tech-node.available .tech-node-status {
            background: #46b9df;
            color: #111;
        }

        .tech-node.locked .tech-node-status {
            background: #666;
            color: #bbb;
        }

        .tech-connection {
            position: absolute;
            background: #7a7a7a;
            transform-origin: 0 0;
            z-index: 5;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
            height: 4px;
        }

        .tech-connection.researched {
            background: #5a775b;
            box-shadow: 0 0 5px #5a775b;
        }

        .tech-connection.locked {
            background: #555;
            opacity: 0.6;
        }
    </style>
</head>

<body>
    <div class="game-container">

        <div class="ui-panel">
            <div class="resources">
                <div class="resource">
                    <img src="./sprites/ironin.png" alt="Steel">
                    <span id="steel-count">100</span>
                </div>
                <div class="resource">
                    <img src="./sprites/coin.png" alt="Coins">
                    <span id="coin-count">50</span>
                </div>
                <div class="resource">
                    <img src="./sprites/goldin.png" alt="Gold">
                    <span id="gold-count">25</span>
                </div>
                <div class="resource">
                    <img src="./sprites/Oil.png" alt="Oil">
                    <span id="oil-count">0</span>
                </div>
            </div>

            <div class="controls-folder">
                <div class="folder" data-folder>
                    <div class="folder-title">
                        <img src="./sprites/wall.png" alt="Walls"> Walls
                    </div>
                    <div class="folder-content">
                        <div class="folder-header">
                            <div class="folder-header-title">Walls</div>
                            <button class="folder-close">×</button>
                        </div>
                        <div class="folder-buttons">
                            <button class="btn" id="place-wall"
                                data-info="Wall,Basic defensive structure to block enemy movement,Health: 1">
                                <div class="btn-left">
                                    <img src="./sprites/wall.png" alt="Wall">
                                    <span>Wall</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">10S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-steel-wall"
                                data-info="Steel Wall,Stronger wall with increased durability,Health: 3,Requires: Advanced Defense">
                                <div class="btn-left">
                                    <img src="./sprites/wallsteel.png" alt="Steel Wall">
                                    <span>Steel</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">20S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-spike"
                                data-info="Spike,Damages enemies that walk over it,Health: 3,Requires: Spike Traps">
                                <div class="btn-left">
                                    <img src="./sprites/spike.png" alt="Spike">
                                    <span>Spike</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">15S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-fortress"
                                data-info="Fortress,Your main base that must be protected,Health: 5,Requires: Fortress">
                                <div class="btn-left">
                                    <img src="./sprites/spawn.png" alt="Fortress">
                                    <span>Fortress</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">25G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                        </div>
                    </div>
                </div>

                <div class="folder" data-folder>
                    <div class="folder-title">
                        <img src="./sprites/turret.png" alt="Tech"> Tech
                    </div>
                    <div class="folder-content">
                        <div class="folder-header">
                            <div class="folder-header-title">Tech</div>
                            <button class="folder-close">×</button>
                        </div>
                        <div class="folder-buttons">
                            <button class="btn" id="place-tech"
                                data-info="Steel Mine,Generates 5 steel per turn,Health: 2,Requires: Fortress">
                                <div class="btn-left">
                                    <img src="./sprites/iron.png" alt="Steel Mine">
                                    <span>Steel Mine</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">20S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-gold-miner"
                                data-info="Gold Mine,Generates 1 gold per turn,Health: 2,Requires: Advanced Mining">
                                <div class="btn-left">
                                    <img src="./sprites/gold.png" alt="Gold Mine">
                                    <span>Gold Mine</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">25S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-coin-maker"
                                data-info="Bank,Generates 5 coins per turn,Health: 2,Requires: Advanced Mining">
                                <div class="btn-left">
                                    <img src="./sprites/bank.png" alt="Bank">
                                    <span>Bank</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">30S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-turret"
                                data-info="Turret,Attacks enemies within range 3,Health: 2,Shots: 8,Requires: Fortress">
                                <div class="btn-left">
                                    <img src="./sprites/turret.png" alt="Turret">
                                    <span>Turret</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">40S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-gold-turret"
                                data-info="Gold Turret,Powerful turret with range 3,Health: 2,Shots: 10,Requires: Fortified Defense">
                                <div class="btn-left">
                                    <img src="./sprites/goldturret.png" alt="Gold Turret">
                                    <span>Gold Turret</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">200G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-bomb"
                                data-info="Bomb,Explodes when enemy approaches damaging area,Health: 1,Requires: Spike Traps">
                                <div class="btn-left">
                                    <img src="./sprites/bomb.png" alt="Bomb">
                                    <span>Bomb</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">10G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-supply"
                                data-info="Supply Drop,Randomly generates resources,Health: 1,Requires: Supply Systems">
                                <div class="btn-left">
                                    <img src="./sprites/supply.gif" alt="Supply Drop">
                                    <span>Supply Drop</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">35G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-oil-rig"
                                data-info="Oil Rig,Generates 1 oil per turn,Health: 2,Requires: Oil Rig Tech">
                                <div class="btn-left">
                                    <img src="./sprites/oilrig.png" alt="Oil Rig">
                                    <span>Oil Rig</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">35S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-campfire"
                                data-info="Campfire,Boosts nearby resource buildings by 50%,Health: 1,Requires: Resource Management">
                                <div class="btn-left">
                                    <img src="./sprites/campfire.gif" alt="Campfire">
                                    <span>Campfire</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">30S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                        </div>
                    </div>
                </div>

                <div class="folder" data-folder>
                    <div class="folder-title">
                        <img src="./sprites/Tank.png" alt="Army"> Army
                    </div>
                    <div class="folder-content">
                        <div class="folder-header">
                            <div class="folder-header-title">Army</div>
                            <button class="folder-close">×</button>
                        </div>
                        <div class="folder-buttons">
                            <button class="btn" id="place-scout"
                                data-info="Soldier,Basic unit with balanced stats,Health: 1,Range: 1,Movement: 1,Requires: Fortress">
                                <div class="btn-left">
                                    <img src="./sprites/soldier.png" alt="Soldier">
                                    <span>Soldier</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">15C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-knight"
                                data-info="Knight,Fast-moving unit with high mobility,Health: 1,Range: 1,Movement: 5,Requires: Basic Army">
                                <div class="btn-left">
                                    <img src="./sprites/knight.png" alt="Knight">
                                    <span>Knight</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">25C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-archer"
                                data-info="Archer,Ranged unit that can attack from a distance,Health: 1,Range: 4,Movement: 1,Requires: Basic Army">
                                <div class="btn-left">
                                    <img src="./sprites/Archer.png" alt="Archer">
                                    <span>Archer</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">20C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-tank"
                                data-info="Tank,Heavy unit with high health,Health: 5,Range: 1,Movement: 1,Requires: Elite Units">
                                <div class="btn-left">
                                    <img src="./sprites/Tank.png" alt="Tank">
                                    <span>Tank</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">50C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-siege-tower"
                                data-info="Siege Tower,Powerful siege unit with long range,Health: 1,Range: 4,Movement: 1,Requires: Siege Weapons">
                                <div class="btn-left">
                                    <img src="./sprites/siegetower.png" alt="Siege Tower">
                                    <span>Siege Tower</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">275C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-king"
                                data-info="King,Command unit that boosts nearby army,Health: 25,Range: 2,Movement: 2,Requires: Elite Units">
                                <div class="btn-left">
                                    <img src="./sprites/king.png" alt="King">
                                    <span>King</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">500G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-barrack"
                                data-info="Barrack,Automatically spawns soldier units,Health: 2,Requires: Advanced Army">
                                <div class="btn-left">
                                    <img src="./sprites/barrack.png" alt="Barrack">
                                    <span>Barrack</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">50G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="tech-tree-popup" id="tech-tree-popup">
            <div class="tech-tree-header">
                <h2>Tech Tree</h2>
                <button class="tech-tree-close" id="tech-tree-close">×</button>
            </div>
            <div class="tech-tree-content" id="tech-tree-content">
            </div>
        </div>

        <div class="tech-tree-overlay" id="tech-tree-overlay"></div>

        <div class="game-grid-container">
            <div class="game-grid" id="game-grid"></div>
        </div>

        <div class="game-info">
            <div class="turn-info">
                <h3>Information</h3>
                <p>Turn: <span id="turn-count">1</span></p>
                <p id="turn-instructions"></p>
            </div>
            <div class="wave-info">
                <h3>Wave Information</h3>
                <p>Wave: <span id="wave-count">1</span></p>
                <p id="wave-status">Enemies remaining: <span id="enemies-remaining">3</span></p>
            </div>
        </div>

        <div class="info-panel">
            <h3>Game Instructions</h3>
            <p><strong>Combat:</strong> Move your army units into enemy squares to attack! Different units have
                different movement ranges and attacks.</p>
            <p><strong>Defense:</strong> Use walls and fortresses to protect your units and resources.</p>
            <p><strong>Resources:</strong> Place miner buildings to generate resources.</p>
            <p><strong>Waves:</strong> Defend against waves of different enemies.</p>
        </div>

        <div class="floating-sidebar">
            <h1 class="game-title">CoreGrid</h1>
            <p class="game-subtitle">Build, Defend, and Conquer</p>
            <button class="control-btn" id="save-game">Save Game</button>
            <button class="control-btn" id="load-game">Load Game</button>
            <button class="control-btn" id="restart-game">Restart Game</button>
            <button class="control-btn" id="tech-tree-button">Research</button>
        </div>
    </div>

    <script>
        const CONFIG = {
            GRID_SIZE_X: 25,
            GRID_SIZE_Y: 15,
            PLAYER_START: { x: 12, y: 7 },
            WAVE_BREAK_TURNS: 3,
            INITIAL_RESOURCES: {
                Steel: 100,
                coins: 50,
                gold: 25,
                oil: 0
            },
            TECH_TREE: {
                'fortress': {
                    name: 'Fortress',
                    description: 'Your main base that must be protected',
                    cost: { Steel: 0 },
                    tier: 0,
                    prerequisites: [],
                    unlocks: ['basic_defense', 'basic_army'],
                    icon: 'spawn.png'
                },
                'basic_defense': {
                    name: 'Basic Defense',
                    description: 'Unlock Steel Wall',
                    cost: { Steel: 75 },
                    tier: 1,
                    prerequisites: ['fortress'],
                    unlocks: ['advanced_defense'],
                    icon: 'wall.png'
                },
                'basic_army': {
                    name: 'Basic Army',
                    description: 'Unlock Soldier unit',
                    cost: { coins: 75 },
                    tier: 1,
                    prerequisites: ['fortress'],
                    unlocks: ['advanced_army'],
                    icon: 'soldier.png'
                },
                'advanced_defense': {
                    name: 'Advanced Defense',
                    description: 'Unlock Steel Wall',
                    cost: { Steel: 150, coins: 75 },
                    tier: 2,
                    prerequisites: ['basic_defense'],
                    unlocks: ['fortified_defense'],
                    icon: 'wallsteel.png'
                },
                'spike_traps': {
                    name: 'Spike Traps',
                    description: 'Unlock Spike',
                    cost: { Steel: 100 },
                    tier: 2,
                    prerequisites: ['basic_defense'],
                    unlocks: ['bomb_tech'],
                    icon: 'spike.png'
                },
                'bomb_tech': {
                    name: 'Bomb Tech',
                    description: 'Unlock Bomb',
                    cost: { gold: 20 },
                    tier: 3,
                    prerequisites: ['spike_traps'],
                    unlocks: [],
                    icon: 'bomb.png'
                },
                'advanced_army': {
                    name: 'Advanced Army',
                    description: 'Unlock Knight unit',
                    cost: { coins: 150, gold: 20 },
                    tier: 2,
                    prerequisites: ['basic_army'],
                    unlocks: ['elite_units', 'barrack_tech'],
                    icon: 'knight.png'
                },
                'ranged_units': {
                    name: 'Ranged Units',
                    description: 'Unlock Archer unit',
                    cost: { coins: 125 },
                    tier: 2,
                    prerequisites: ['basic_army'],
                    unlocks: ['siege_weapons'],
                    icon: 'Archer.png'
                },
                'siege_weapons': {
                    name: 'Siege Weapons',
                    description: 'Unlock Siege Tower unit',
                    cost: { coins: 200 },
                    tier: 2,
                    prerequisites: ['ranged_units'],
                    unlocks: [],
                    icon: 'siegetower.png'
                },
                'advanced_mining': {
                    name: 'Advanced Mining',
                    description: 'Unlock Gold Mine',
                    cost: { Steel: 200 },
                    tier: 2,
                    prerequisites: ['fortress'],
                    unlocks: ['premium_mining', 'supply_systems'],
                    icon: 'gold.png'
                },
                'supply_systems': {
                    name: 'Supply Systems',
                    description: 'Unlock Supply Drop',
                    cost: { gold: 250, Steel: 250 },
                    tier: 3,
                    prerequisites: ['advanced_mining'],
                    unlocks: ['campfire_tech'],
                    icon: 'supply.gif'
                },
                'basic_turret': {
                    name: 'Basic Turret',
                    description: 'Unlock Turret',
                    cost: { Steel: 200 },
                    tier: 2,
                    prerequisites: ['basic_defense'],
                    unlocks: ['fortified_defense'],
                    icon: 'turret.png'
                },
                'fortified_defense': {
                    name: 'Fortified Defense',
                    description: 'Unlock Gold Turret',
                    cost: { Steel: 200, gold: 500 },
                    tier: 3,
                    prerequisites: ['advanced_defense', 'basic_turret', 'bomb_tech'],
                    unlocks: [],
                    icon: 'goldturret.png'
                },
                'elite_units': {
                    name: 'Elite Units',
                    description: 'Unlock Tank unit',
                    cost: { coins: 400, gold: 75 },
                    tier: 3,
                    prerequisites: ['advanced_army'],
                    unlocks: ['command_units'],
                    icon: 'Tank.png'
                },
                'command_units': {
                    name: 'Command Units',
                    description: 'Unlock King unit',
                    cost: { gold: 1000 },
                    tier: 3,
                    prerequisites: ['elite_units'],
                    unlocks: [],
                    icon: 'king.png'
                },
                'barrack_tech': {
                    name: 'Barrack Tech',
                    description: 'Unlock Barrack unit',
                    cost: { gold: 275 },
                    tier: 3,
                    prerequisites: ['advanced_army'],
                    unlocks: [],
                    icon: 'barrack.png'
                },
                'premium_mining': {
                    name: 'Premium Mining',
                    description: 'Unlock Bank',
                    cost: { Steel: 350, gold: 75 },
                    tier: 3,
                    prerequisites: ['advanced_mining'],
                    unlocks: [],
                    icon: 'bank.png'
                },
                'campfire_tech': {
                    name: 'Campfire Tech',
                    description: 'Unlock Campfire',
                    cost: { Steel: 50 },
                    tier: 3,
                    prerequisites: ['supply_systems'],
                    unlocks: ['oil_rig_tech'],
                    icon: 'campfire.gif'
                },
                'oil_rig_tech': {
                    name: 'Oil Rig Tech',
                    description: 'Unlock Oil Rig',
                    cost: { Steel: 60 },
                    tier: 3,
                    prerequisites: ['campfire_tech'],
                    unlocks: [],
                    icon: 'oilrig.png'
                },
            },
            SPRITES: {
                player: './sprites/spawn.png',
                wall: {
                    stone: './sprites/wall.png',
                    steel: './sprites/wallsteel.png',
                    spike: './sprites/spike.png',
                    fortress: './sprites/spawn.png'
                },
                tech: {
                    miner: './sprites/iron.png',
                    goldminer: './sprites/gold.png',
                    coinmaker: './sprites/bank.png',
                    oilrig: './sprites/oilrig.png',
                    turret: './sprites/turret.png',
                    goldturret: './sprites/goldturret.png',
                    bomb: './sprites/bomb.png',
                    supply: './sprites/supply.gif',
                    campfire: './sprites/campfire.gif'
                },
                army: {
                    scout: './sprites/soldier.png',
                    knight: './sprites/knight.png',
                    archer: './sprites/Archer.png',
                    tank: './sprites/Tank.png',
                    king: './sprites/king.png',
                    barrack: './sprites/barrack.png',
                    siegetower: './sprites/siegetower.png'
                },
                enemy: {
                    basic: './sprites/defaultbad.png',
                    fast: './sprites/badfast.png',
                    tank: './sprites/badheavy.png',
                    ranged: './sprites/badarcher.png',
                    healer: './sprites/badhealer.png'
                }
            }
        };

        class GameState {
            constructor() {
                this.reset();
            }

            reset() {
                if (window.waveBreakTimeout) {
                    clearTimeout(window.waveBreakTimeout);
                    window.waveBreakTimeout = null;
                }

                this.resources = { ...CONFIG.INITIAL_RESOURCES };
                this.turn = 1;
                this.selectedUnit = null;
                this.placementMode = null;

                this.cameraOffset = { x: 0, y: 0 };
                this.worldObjects = new Map();
                this.grid = Array(CONFIG.GRID_SIZE_Y).fill().map(() => Array(CONFIG.GRID_SIZE_X).fill(null));
                this.objects = new Map();
                this.wave = 1;
                this.waveBreakTurns = 0;
                this.inWaveBreak = false;
                this.enemiesRemaining = 0;
                this.researchedTechs = new Set();
                this.availableTechs = new Set();
                this.updateAvailableTechs();
            }

            canAfford(cost) {
                return this.resources.Steel >= (cost.Steel || 0) &&
                    this.resources.coins >= (cost.coins || 0) &&
                    this.resources.gold >= (cost.gold || 0) &&
                    this.resources.oil >= (cost.oil || 0);
            }

            spendResources(cost) {
                if (cost.Steel) this.resources.Steel -= cost.Steel;
                if (cost.coins) this.resources.coins -= cost.coins;
                if (cost.gold) this.resources.gold -= cost.gold;
                if (cost.oil) this.resources.oil -= cost.oil;
            }

            addResources(resources) {
                if (resources.Steel) this.resources.Steel += resources.Steel;
                if (resources.coins) this.resources.coins += resources.coins;
                if (resources.gold) this.resources.gold += resources.gold;
                if (resources.oil) this.resources.oil += resources.oil;
            }

            isTechResearched(techId) {
                return this.researchedTechs.has(techId);
            }

            canResearchTech(techId) {
                const tech = CONFIG.TECH_TREE[techId];
                if (!tech) return false;
                if (this.isTechResearched(techId)) return false;

                return tech.prerequisites.every(prereq => this.isTechResearched(prereq)) &&
                    this.canAfford(tech.cost);
            }

            researchTech(techId) {
                if (!this.canResearchTech(techId)) return false;

                const tech = CONFIG.TECH_TREE[techId];
                this.spendResources(tech.cost);
                this.researchedTechs.add(techId);
                this.updateAvailableTechs();
                return true;
            }

            updateAvailableTechs() {
                this.availableTechs.clear();
                for (const techId in CONFIG.TECH_TREE) {
                    const tech = CONFIG.TECH_TREE[techId];
                    if (!this.isTechResearched(techId) &&
                        tech.prerequisites.every(prereq => this.isTechResearched(prereq))) {
                        this.availableTechs.add(techId);
                    }
                }
            }

            getResourceMultiplier() {
                let multiplier = 1.0;
                if (this.isTechResearched('advanced_mining')) {
                    multiplier += 0.25;
                }
                if (this.isTechResearched('premium_mining')) {
                    multiplier += 0.5;
                }
                return multiplier;
            }

            countEnemies() {
                let count = 0;
                this.worldObjects.forEach(obj => {
                    if (obj.type === 'enemy') count++;
                });
                console.log(`countEnemies: calculated ${count}, previous value was ${this.enemiesRemaining}`);
                this.enemiesRemaining = count;
                return count;
            }
        }

        class GameObject {
            constructor(x, y, type, subtype) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.subtype = subtype;
                this.id = `${type}_${subtype}_${x}_${y}_${Date.now()}`;
            }

            getSprite() {
                return CONFIG.SPRITES[this.type]?.[this.subtype] || 'sprites/missing.png';
            }
        }

        class Wall extends GameObject {
            constructor(x, y, subtype = 'stone') {
                super(x, y, 'wall', subtype);
                this.health = this.getMaxHealth();
                this.maxHealth = this.health;
                this.blocksMovement = true;
            }

            getMaxHealth() {
                switch (this.subtype) {
                    case 'steel': return 3;
                    case 'spike': return 3;
                    case 'fortress': return 5;
                    default: return 1;
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        class Tech extends GameObject {
            constructor(x, y, subtype = 'miner') {
                super(x, y, 'tech', subtype);
                this.cost = this.getCost();
                this.health = 2;
                this.maxHealth = 2;

                if (subtype === 'turret') {
                    this.shotsLeft = 8;
                    this.range = 3;
                } else if (subtype === 'goldturret') {
                    this.shotsLeft = 10;
                    this.range = 3;
                }
            }

            getCost() {
                const costs = {
                    miner: { Steel: 20 },
                    goldminer: { Steel: 25 },
                    coinmaker: { Steel: 30 },
                    oilrig: { Steel: 35 },
                    turret: { Steel: 40 },
                    goldturret: { gold: 200 },
                    bomb: { gold: 10 },
                    supply: { gold: 35 },
                    campfire: { Steel: 30 }
                };
                return costs[this.subtype] || { Steel: 20 };
            }

            onTurn() {
                const multiplier = gameState.getResourceMultiplier();

                const campfireBonus = 1 + (0.5 * this.getNearbyCampfires());

                switch (this.subtype) {
                    case 'miner':
                        gameState.addResources({ Steel: Math.floor(5 * campfireBonus * multiplier) });
                        createResourceCollectionEffect(this.x, this.y, 'Steel');
                        break;
                    case 'goldminer':
                        gameState.addResources({ gold: Math.ceil(1 * campfireBonus * multiplier) });
                        createResourceCollectionEffect(this.x, this.y, 'gold');
                        break;
                    case 'coinmaker':
                        gameState.addResources({ coins: Math.floor(5 * campfireBonus * multiplier) });
                        createResourceCollectionEffect(this.x, this.y, 'coins');
                        break;
                    case 'oilrig':
                        gameState.addResources({ oil: Math.ceil(1 * campfireBonus * multiplier) });
                        createResourceCollectionEffect(this.x, this.y, 'oil');
                        break;
                    case 'supply':
                        this.handleSupplyDrop();
                        break;
                    case 'turret':
                    case 'goldturret':
                        this.attackNearbyEnemies();
                        break;
                    case 'bomb':
                        this.handleBomb();
                        break;
                }
            }

            getNearbyCampfires() {
                let count = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const worldX = this.x + dx;
                        const worldY = this.y + dy;

                        const gridX = worldX - gameState.cameraOffset.x;
                        const gridY = worldY - gameState.cameraOffset.y;

                        if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X && gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                            const obj = gameState.grid[gridY][gridX];
                            if (obj && obj.type === 'tech' && obj.subtype === 'campfire') {
                                count++;
                            }
                        }
                    }
                }
                return count;
            }

            handleSupplyDrop() {
                if (Math.random() < 0.33) {
                    const resources = ['coins', 'Steel', 'gold'];
                    const resource = resources[Math.floor(Math.random() * resources.length)];
                    const amount = 5 + Math.floor(Math.random() * 6);
                    gameState.addResources({ [resource]: amount });
                    showNotification(`+${amount} ${resource} from Supply Drop!`, this.x, this.y);
                    createResourceCollectionEffect(this.x, this.y, resource);
                }
            }

            attackNearbyEnemies() {
                if (this.shotsLeft <= 0) return false;

                for (let dy = -this.range; dy <= this.range; dy++) {
                    for (let dx = -this.range; dx <= this.range; dx++) {
                        if (Math.max(Math.abs(dx), Math.abs(dy)) > this.range) continue;
                        const worldX = this.x + dx;
                        const worldY = this.y + dy;

                        const gridX = worldX - gameState.cameraOffset.x;
                        const gridY = worldY - gameState.cameraOffset.y;

                        if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X && gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                            const target = gameState.grid[gridY][gridX];
                            if (target && target.type === 'enemy') {
                                if (gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y &&
                                    gridX >= 0 && gridX < CONFIG.GRID_SIZE_X) {
                                    gameState.grid[gridY][gridX] = null;
                                }

                                gameState.objects.delete(target.id);
                                gameState.worldObjects.delete(target.id);
                                this.shotsLeft--;
                                if (this.shotsLeft <= 0) {
                                    const selfGridX = this.x - gameState.cameraOffset.x;
                                    const selfGridY = this.y - gameState.cameraOffset.y;
                                    if (selfGridY >= 0 && selfGridY < CONFIG.GRID_SIZE_Y &&
                                        selfGridX >= 0 && selfGridX < CONFIG.GRID_SIZE_X) {
                                        gameState.grid[selfGridY][selfGridX] = null;
                                    }

                                    gameState.objects.delete(this.id);
                                    gameState.worldObjects.delete(this.id);
                                }
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            handleBomb() {
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const worldX = this.x + dx;
                        const worldY = this.y + dy;

                        const gridX = worldX - gameState.cameraOffset.x;
                        const gridY = worldY - gameState.cameraOffset.y;

                        if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X && gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                            const target = gameState.grid[gridY][gridX];
                            if (target && target.type === 'enemy') {
                                for (let dy2 = -2; dy2 <= 2; dy2++) {
                                    for (let dx2 = -2; dx2 <= 2; dx2++) {
                                        const worldX2 = this.x + dx2;
                                        const worldY2 = this.y + dy2;

                                        const gridX2 = worldX2 - gameState.cameraOffset.x;
                                        const gridY2 = worldY2 - gameState.cameraOffset.y;

                                        if (gridX2 >= 0 && gridX2 < CONFIG.GRID_SIZE_X && gridY2 >= 0 && gridY2 < CONFIG.GRID_SIZE_Y) {
                                            const target2 = gameState.grid[gridY2][gridX2];
                                            if (target2 && target2.type === 'enemy') {
                                                if (gridY2 >= 0 && gridY2 < CONFIG.GRID_SIZE_Y &&
                                                    gridX2 >= 0 && gridX2 < CONFIG.GRID_SIZE_X) {
                                                    gameState.grid[gridY2][gridX2] = null;
                                                }

                                                gameState.objects.delete(target2.id);
                                                gameState.worldObjects.delete(target2.id);
                                            }
                                        }
                                    }
                                }

                                const selfGridX = this.x - gameState.cameraOffset.x;
                                const selfGridY = this.y - gameState.cameraOffset.y;
                                if (selfGridY >= 0 && selfGridY < CONFIG.GRID_SIZE_Y &&
                                    selfGridX >= 0 && selfGridX < CONFIG.GRID_SIZE_X) {
                                    gameState.grid[selfGridY][selfGridX] = null;
                                }

                                gameState.objects.delete(this.id);
                                gameState.worldObjects.delete(this.id);
                                return;
                            }
                        }
                    }
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        class Army extends GameObject {
            constructor(x, y, subtype = 'scout') {
                super(x, y, 'army', subtype);
                this.cost = this.getCost();
                this.health = this.getMaxHealth();
                this.maxHealth = this.health;
                this.range = this.getRange();
                this.movement = this.getMovement();

                if (subtype === 'barrack') {
                    this.spawnCounter = 0;
                }
            }

            getCost() {
                const costs = {
                    scout: { coins: 15 },
                    knight: { coins: 25 },
                    archer: { coins: 20 },
                    tank: { coins: 50 },
                    siegetower: { coins: 275 },
                    king: { gold: 500 },
                    barrack: { gold: 50 }
                };
                return costs[this.subtype] || { coins: 15 };
            }

            getMaxHealth() {
                switch (this.subtype) {
                    case 'tank': return 5;
                    case 'king': return 25;
                    default: return 1;
                }
            }

            getRange() {
                switch (this.subtype) {
                    case 'archer':
                    case 'siegetower': return 4;
                    case 'king': return 2;
                    default: return 1;
                }
            }

            getMovement() {
                switch (this.subtype) {
                    case 'knight': return 5;
                    case 'archer': return 1;
                    case 'tank': return 1;
                    case 'king': return 2;
                    default: return 1;
                }
            }

            getValidMoves() {
                const moves = [];
                const attacks = [];

                const directions = this.subtype === 'knight' ?
                    [[-1, -1], [-1, 1], [1, -1], [1, 1]] :
                    [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];

                directions.forEach(([dx, dy]) => {
                    for (let i = 1; i <= this.movement; i++) {
                        const worldX = this.x + dx * i;
                        const worldY = this.y + dy * i;

                        const gridX = worldX - gameState.cameraOffset.x;
                        const gridY = worldY - gameState.cameraOffset.y;

                        if (gridX < 0 || gridX >= CONFIG.GRID_SIZE_X || gridY < 0 || gridY >= CONFIG.GRID_SIZE_Y) break;

                        const target = gameState.grid[gridY][gridX];
                        if (target === null) {
                            moves.push({ x: worldX, y: worldY });
                        } else if (target.type === 'enemy') {
                            attacks.push({ x: worldX, y: worldY });
                            break;
                        } else {
                            break;
                        }
                    }
                });

                if (this.subtype === 'archer' || this.subtype === 'siegetower') {
                    const allDirections = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];
                    allDirections.forEach(([dx, dy]) => {
                        for (let i = 1; i <= this.range; i++) {
                            const worldX = this.x + dx * i;
                            const worldY = this.y + dy * i;

                            const gridX = worldX - gameState.cameraOffset.x;
                            const gridY = worldY - gameState.cameraOffset.y;

                            if (gridX < 0 || gridX >= CONFIG.GRID_SIZE_X || gridY < 0 || gridY >= CONFIG.GRID_SIZE_Y) break;

                            const target = gameState.grid[gridY][gridX];
                            if (target && target.type === 'enemy') {
                                attacks.push({ x: worldX, y: worldY });
                            }
                        }
                    });
                }

                return { moves, attacks };
            }

            onTurn() {
                if (this.subtype === 'barrack') {
                    this.spawnCounter = (this.spawnCounter || 0) + 1;
                    if (this.spawnCounter >= 2) {
                        this.spawnCounter = 0;
                        const worldX = this.x - 1;
                        const worldY = this.y;

                        const gridX = worldX - gameState.cameraOffset.x;
                        const gridY = worldY - gameState.cameraOffset.y;

                        if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X && gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y && gameState.grid[gridY][gridX] === null) {
                            const scout = new Army(worldX, worldY, 'scout');
                            addObjectToWorld(scout);
                            showNotification('Barrack spawned a Soldier!', gridX, gridY);
                        }
                    }
                }
            }

            moveTo(x, y) {
                const oldX = this.x;
                const oldY = this.y;

                this.x = x;
                this.y = y;

                gameState.worldObjects.set(this.id, this);

                const oldGridX = oldX - gameState.cameraOffset.x;
                const oldGridY = oldY - gameState.cameraOffset.y;
                if (oldGridX >= 0 && oldGridX < CONFIG.GRID_SIZE_X &&
                    oldGridY >= 0 && oldGridY < CONFIG.GRID_SIZE_Y) {
                    gameState.grid[oldGridY][oldGridX] = null;
                }

                const gridX = x - gameState.cameraOffset.x;
                const gridY = y - gameState.cameraOffset.y;

                if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X && gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                    gameState.grid[gridY][gridX] = this;
                    gameState.objects.set(this.id, this);
                } else {
                    gameState.objects.delete(this.id);
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        class Enemy extends GameObject {
            constructor(x, y, subtype = 'basic') {
                super(x, y, 'enemy', subtype);
                this.health = this.getMaxHealth();
                this.maxHealth = this.health;
            }

            getMaxHealth() {
                switch (this.subtype) {
                    case 'tank': return 100;
                    case 'fast': return 30;
                    case 'ranged': return 40;
                    case 'healer': return 25;
                    default: return 50;
                }
            }

            onTurn() {
                const playerGridX = CONFIG.PLAYER_START.x - gameState.cameraOffset.x;
                const playerGridY = CONFIG.PLAYER_START.y - gameState.cameraOffset.y;

                const playerWorldX = CONFIG.PLAYER_START.x;
                const playerWorldY = CONFIG.PLAYER_START.y;

                if (this.x === playerWorldX && this.y === playerWorldY) {
                    gameOver();
                    return;
                }

                const attacks = this.getValidAttacks();
                if (attacks.length > 0) {
                    const target = attacks[0].target;
                    this.attackTarget(target);
                    return;
                }

                this.moveTowardsPlayer();
            }

            getValidAttacks() {
                const attacks = [];
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];

                directions.forEach(([dx, dy]) => {
                    const worldX = this.x + dx;
                    const worldY = this.y + dy;

                    const gridX = worldX - gameState.cameraOffset.x;
                    const gridY = worldY - gameState.cameraOffset.y;

                    let target = null;

                    if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X && gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                        target = gameState.grid[gridY][gridX];
                    } else {
                        for (const [id, obj] of gameState.worldObjects) {
                            if (obj.x === worldX && obj.y === worldY) {
                                target = obj;
                                break;
                            }
                        }

                        if (worldX === CONFIG.PLAYER_START.x && worldY === CONFIG.PLAYER_START.y) {
                            target = 'player';
                        }
                    }

                    if (target && (
                        (target.type === 'army' && target.owner === 'player') ||
                        target.type === 'wall' ||
                        target.type === 'tech' ||
                        target === 'player'
                    )) {
                        attacks.push({ x: worldX, y: worldY, target });
                    }
                });

                return attacks;
            }

            moveTowardsPlayer() {
                const playerGridX = CONFIG.PLAYER_START.x - gameState.cameraOffset.x;
                const playerGridY = CONFIG.PLAYER_START.y - gameState.cameraOffset.y;

                const playerWorldX = CONFIG.PLAYER_START.x;
                const playerWorldY = CONFIG.PLAYER_START.y;

                let dx = Math.sign(playerWorldX - this.x);
                let dy = Math.sign(playerWorldY - this.y);

                let newX = this.x + dx;
                let newY = this.y + dy;

                let newGridX = newX - gameState.cameraOffset.x;
                let newGridY = newY - gameState.cameraOffset.y;

                let canMove = true;
                if (newGridX >= 0 && newGridX < CONFIG.GRID_SIZE_X &&
                    newGridY >= 0 && newGridY < CONFIG.GRID_SIZE_Y) {
                    canMove = gameState.grid[newGridY][newGridX] === null;
                }

                if (canMove) {
                    const oldGridX = this.x - gameState.cameraOffset.x;
                    const oldGridY = this.y - gameState.cameraOffset.y;
                    if (oldGridY >= 0 && oldGridY < CONFIG.GRID_SIZE_Y &&
                        oldGridX >= 0 && oldGridX < CONFIG.GRID_SIZE_X) {
                        gameState.grid[oldGridY][oldGridX] = null;
                    }

                    this.x = newX;
                    this.y = newY;

                    if (newGridX >= 0 && newGridX < CONFIG.GRID_SIZE_X &&
                        newGridY >= 0 && newGridY < CONFIG.GRID_SIZE_Y) {
                        gameState.grid[newGridY][newGridX] = this;
                    }

                    gameState.worldObjects.set(this.id, this);
                    gameState.objects.set(this.id, this);
                }
            }

            attackTarget(target) {
                if (target.type === 'army' || target.type === 'tech') {
                    const isDestroyed = target.takeDamage(1);
                    if (isDestroyed) {
                        if (target.y >= gameState.cameraOffset.y && target.y < gameState.cameraOffset.y + CONFIG.GRID_SIZE_Y &&
                            target.x >= gameState.cameraOffset.x && target.x < gameState.cameraOffset.x + CONFIG.GRID_SIZE_X) {
                            const gridY = target.y - gameState.cameraOffset.y;
                            const gridX = target.x - gameState.cameraOffset.x;
                            gameState.grid[gridY][gridX] = null;
                        }

                        gameState.objects.delete(target.id);
                        gameState.worldObjects.delete(target.id);

                        if (gameState.selectedUnit && gameState.selectedUnit.id === target.id) {
                            clearSelection();
                        }
                    }
                } else if (target.type === 'wall') {
                    const isDestroyed = target.takeDamage(1);
                    if (isDestroyed) {
                        if (target.y >= gameState.cameraOffset.y && target.y < gameState.cameraOffset.y + CONFIG.GRID_SIZE_Y &&
                            target.x >= gameState.cameraOffset.x && target.x < gameState.cameraOffset.x + CONFIG.GRID_SIZE_X) {
                            const gridY = target.y - gameState.cameraOffset.y;
                            const gridX = target.x - gameState.cameraOffset.x;
                            gameState.grid[gridY][gridX] = null;
                        }

                        gameState.objects.delete(target.id);
                        gameState.worldObjects.delete(target.id);
                    }
                } else if (target === 'player') {
                    gameOver();
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        const gameState = new GameState();

        function initGame() {
            if (window.waveBreakTimeout) {
                clearTimeout(window.waveBreakTimeout);
                window.waveBreakTimeout = null;
            }

            createGrid();

            if (typeof gameState.cameraOffset === 'undefined') {
                gameState.cameraOffset = { x: 0, y: 0 };
            }

            gameState.cameraOffset.x = Math.floor(CONFIG.GRID_SIZE_X / 2) - CONFIG.PLAYER_START.x;
            gameState.cameraOffset.y = Math.floor(CONFIG.GRID_SIZE_Y / 2) - CONFIG.PLAYER_START.y;

            const playerWorldX = CONFIG.PLAYER_START.x;
            const playerWorldY = CONFIG.PLAYER_START.y;
            const playerGridX = playerWorldX - gameState.cameraOffset.x;
            const playerGridY = playerWorldY - gameState.cameraOffset.y;

            if (playerGridX >= 0 && playerGridX < CONFIG.GRID_SIZE_X &&
                playerGridY >= 0 && playerGridY < CONFIG.GRID_SIZE_Y) {
                gameState.grid[playerGridY][playerGridX] = 'player';
            }

            if (typeof gameState.enemiesRemaining === 'undefined') {
                gameState.enemiesRemaining = 0;
            }

            spawnEnemy(5, 5);
            spawnEnemy(10, 2);
            spawnEnemy(2, 10);

            console.log(`Initial enemies spawned, count: ${gameState.enemiesRemaining}`);
            gameState.countEnemies();
            console.log(`After countEnemies, enemies remaining: ${gameState.enemiesRemaining}`);
            updateDisplay();
            setupEventListeners();

            if (window.buttonStateInterval) {
                clearInterval(window.buttonStateInterval);
            }
            window.buttonStateInterval = setInterval(updateButtonStates, 2000);
        }

        function createGrid() {
            const gridElement = document.getElementById('game-grid');
            if (!gridElement) {
                console.error('Game grid element not found');
                return;
            }

            gridElement.innerHTML = '';

            for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    cell.addEventListener('click', (function (x, y) {
                        return function (e) {
                            e.stopPropagation();
                            handleCellClick(x, y);
                        };
                    })(x, y));

                    gridElement.appendChild(cell);
                }
            }
        }

        function reattachGridCellListeners() {
            document.querySelectorAll('.grid-cell').forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const newCell = cell.cloneNode(true);
                cell.parentNode.replaceChild(newCell, cell);
                newCell.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleCellClick(x, y);
                });
            });
        }

        function handleCellClick(x, y) {
            const worldX = x + gameState.cameraOffset.x;
            const worldY = y + gameState.cameraOffset.y;

            const cell = gameState.grid[y][x];
            let actionTaken = false;

            if (gameState.placementMode) {
                if (cell === null) {
                    const [type, subtype] = parsePlacementMode(gameState.placementMode);
                    const placed = placeObject(x, y, type, subtype);
                    if (placed) {
                        actionTaken = true;
                        // Reset folder open flag after successful placement
                        window.keepFoldersOpen = false;
                        console.log('Resetting keepFoldersOpen = false after placement');
                    }
                }
                updateDisplay();
                if (actionTaken) {
                    processEnemyTurn();
                }
                return;
            }

            if (cell && cell.type === 'army') {
                clearSelection();
                gameState.selectedUnit = cell;
                highlightValidMoves(cell);
                updateDisplay();
                return;
            }

            if (gameState.selectedUnit) {
                const { moves, attacks } = gameState.selectedUnit.getValidMoves();

                const isValidMove = moves.some(move => move.x === worldX && move.y === worldY);
                const isValidAttack = attacks.some(attack => attack.x === worldX && attack.y === worldY);

                if (isValidMove && cell === null) {
                    gameState.selectedUnit.moveTo(worldX, worldY);
                    actionTaken = true;
                } else if (isValidAttack && cell && cell.type === 'enemy') {
                    attackEnemy(cell);
                    actionTaken = true;
                } else {
                    clearSelection();
                }

                clearSelection();
                updateDisplay();
                if (actionTaken) {
                    processEnemyTurn();
                }
            }
        }

        function parsePlacementMode(mode) {
            if (mode.includes('-')) {
                const parts = mode.split('-');
                return [parts[0], parts[1]];
            }
            return [mode, null];
        }

        function placeObject(x, y, type, subtype = null) {
            const worldX = x + gameState.cameraOffset.x;
            const worldY = y + gameState.cameraOffset.y;

            if (type === 'tech' && subtype === 'oilrig') {
                if (isAdjacentToCampfire(x, y)) {
                    showNotification('Oil rigs cannot be placed beside campfires!', x, y, 'warning');
                    return false;
                }
            }

            if (type === 'tech' && subtype === 'campfire') {
                if (isAdjacentToOilRig(x, y)) {
                    showNotification('Campfires cannot be placed beside oil rigs!', x, y, 'warning');
                    return false;
                }
            }

            let obj;
            let cost;

            switch (type) {
                case 'wall':
                    obj = new Wall(worldX, worldY, subtype || 'stone');
                    cost = getWallCost(subtype);
                    break;
                case 'tech':
                    obj = new Tech(worldX, worldY, subtype || 'miner');
                    cost = obj.cost;
                    break;
                case 'army':
                    obj = new Army(worldX, worldY, subtype || 'scout');
                    cost = obj.cost;
                    break;
                default:
                    return false;
            }

            if (!gameState.canAfford(cost)) {
                showNotification('Not enough resources!', x, y, 'warning');
                return false;
            }

            gameState.spendResources(cost);
            addObjectToWorld(obj);

            if (type === 'tech') {
                obj.onTurn();
            }

            showNotification(`${subtype || type} placed!`, x, y, 'success');
            createPlacementEffect(x, y);
            return true;
        }

        function isAdjacentToCampfire(x, y) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const checkX = x + dx;
                    const checkY = y + dy;

                    if (checkX >= 0 && checkX < CONFIG.GRID_SIZE_X && checkY >= 0 && checkY < CONFIG.GRID_SIZE_Y) {
                        const obj = gameState.grid[checkY][checkX];
                        if (obj && obj.type === 'tech' && obj.subtype === 'campfire') {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function isAdjacentToOilRig(x, y) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const checkX = x + dx;
                    const checkY = y + dy;

                    if (checkX >= 0 && checkX < CONFIG.GRID_SIZE_X && checkY >= 0 && checkY < CONFIG.GRID_SIZE_Y) {
                        const obj = gameState.grid[checkY][checkX];
                        if (obj && obj.type === 'tech' && obj.subtype === 'oilrig') {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function getWallCost(subtype) {
            switch (subtype) {
                case 'steel': return { Steel: 20 };
                case 'spike': return { Steel: 15 };
                case 'fortress': return { gold: 25 };
                default: return { Steel: 10 };
            }
        }

        function spawnEnemy(x, y, subtype = null) {
            console.log(`spawnEnemy called with x=${x}, y=${y}`);
            const worldX = x + gameState.cameraOffset.x;
            const worldY = y + gameState.cameraOffset.y;

            if (y >= 0 && y < CONFIG.GRID_SIZE_Y && x >= 0 && x < CONFIG.GRID_SIZE_X && gameState.grid[y][x] === null) {
                if (!subtype) {
                    const enemyTypes = [
                        { type: 'basic', weight: 5 },
                        { type: 'fast', weight: 3 },
                        { type: 'tank', weight: 2 },
                        { type: 'ranged', weight: 3 },
                        { type: 'healer', weight: 2 }
                    ];

                    const totalWeight = enemyTypes.reduce((sum, type) => sum + type.weight, 0);
                    let random = Math.random() * totalWeight;

                    for (const enemyType of enemyTypes) {
                        random -= enemyType.weight;
                        if (random <= 0) {
                            subtype = enemyType.type;
                            break;
                        }
                    }
                }

                const enemy = new Enemy(worldX, worldY, subtype || 'basic');
                addObjectToWorld(enemy);
                gameState.enemiesRemaining++;
                console.log(`Enemy spawned, enemies remaining: ${gameState.enemiesRemaining}`);
            } else {
                console.log(`Failed to spawn enemy at ${x},${y} - cell not empty or out of bounds`);
            }
        }

        function clearSelection() {
            gameState.selectedUnit = null;
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.classList.remove('selected', 'valid-move', 'valid-attack');
            });
        }

        function attackEnemy(enemy) {
            const gridX = enemy.x - gameState.cameraOffset.x;
            const gridY = enemy.y - gameState.cameraOffset.y;

            if (gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y &&
                gridX >= 0 && gridX < CONFIG.GRID_SIZE_X) {
                gameState.grid[gridY][gridX] = null;
            }

            gameState.objects.delete(enemy.id);
            gameState.worldObjects.delete(enemy.id);
            gameState.enemiesRemaining--;
            console.log(`Enemy attacked, enemies remaining: ${gameState.enemiesRemaining}`);

            gameState.addResources({ coins: 5 });
            createEnemyDefeatEffect(enemy.x, enemy.y);
        }

        function gameOver() {
            showNotification('Game Over! The enemies have reached your base!', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'danger');
            setTimeout(() => {
                if (confirm('Game Over! Would you like to restart?')) {
                    restartGame();
                }
            }, 1000);
        }

        function highlightValidMoves(unit) {
            const { moves, attacks } = unit.getValidMoves();

            moves.forEach(move => {
                const gridX = move.x - gameState.cameraOffset.x;
                const gridY = move.y - gameState.cameraOffset.y;

                if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X &&
                    gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                    const cell = document.querySelector(`[data-x="${gridX}"][data-y="${gridY}"]`);
                    if (cell) {
                        cell.classList.add('valid-move');
                    }
                }
            });

            attacks.forEach(attack => {
                const gridX = attack.x - gameState.cameraOffset.x;
                const gridY = attack.y - gameState.cameraOffset.y;

                if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X &&
                    gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                    const cell = document.querySelector(`[data-x="${gridX}"][data-y="${gridY}"]`);
                    if (cell) {
                        cell.classList.add('valid-attack');
                    }
                }
            });

            const unitGridX = unit.x - gameState.cameraOffset.x;
            const unitGridY = unit.y - gameState.cameraOffset.y;

            if (unitGridX >= 0 && unitGridX < CONFIG.GRID_SIZE_X &&
                unitGridY >= 0 && unitGridY < CONFIG.GRID_SIZE_Y) {
                const unitCell = document.querySelector(`[data-x="${unitGridX}"][data-y="${unitGridY}"]`);
                if (unitCell) {
                    unitCell.classList.add('selected');
                }
            }
        }

        function spawnNextWave() {
            console.log("spawnNextWave called");
            if (window.waveBreakTimeout) {
                clearTimeout(window.waveBreakTimeout);
                window.waveBreakTimeout = null;
            }
            gameState.wave++;
            console.log(`Wave incremented to ${gameState.wave}`);
            gameState.inWaveBreak = false;
            console.log("Wave break reset to false");

            let numEnemies = 3 + gameState.wave * 2;

            const emptyCells = [];
            for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                    const playerGridX = CONFIG.PLAYER_START.x - gameState.cameraOffset.x;
                    const playerGridY = CONFIG.PLAYER_START.y - gameState.cameraOffset.y;

                    if (x === playerGridX && y === playerGridY) continue;

                    if (gameState.grid[y][x] === null) {
                        emptyCells.push({ x, y });
                    }
                }
            }

            for (let i = emptyCells.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [emptyCells[i], emptyCells[j]] = [emptyCells[j], emptyCells[i]];
            }

            const enemiesToSpawn = Math.min(numEnemies, emptyCells.length);

            console.log(`Spawning wave ${gameState.wave}: ${enemiesToSpawn} enemies`);

            for (let i = 0; i < enemiesToSpawn; i++) {
                const { x, y } = emptyCells[i];
                spawnEnemy(x, y);
            }

            gameState.countEnemies();
            showNotification(`Wave ${gameState.wave} incoming!`, CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'warning');
            updateDisplay();
        }

        function processEnemyTurn() {
            gameState.objects.forEach(obj => {
                if (obj.type === 'army' && obj.onTurn) {
                    obj.onTurn();
                }
            });

            gameState.objects.forEach(obj => {
                if (obj.type === 'tech' && obj.onTurn) {
                    obj.onTurn();
                }
            });

            const enemies = [];
            gameState.objects.forEach(obj => {
                if (obj.type === 'enemy') {
                    enemies.push(obj);
                }
            });

            enemies.forEach(enemy => {
                enemy.onTurn();
            });

            gameState.turn++;
            gameState.countEnemies();

            console.log(`Enemies remaining: ${gameState.enemiesRemaining}, In wave break: ${gameState.inWaveBreak}`);

            if (gameState.enemiesRemaining === 0 && !gameState.inWaveBreak) {
                console.log("Condition met: enemiesRemaining is 0 and not in wave break");
                console.log("Starting wave break");
                gameState.inWaveBreak = true;
                gameState.waveBreakTurns = CONFIG.WAVE_BREAK_TURNS;
                showNotification(`Wave ${gameState.wave} complete! Prepare for the next wave.`, CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
            }

            if (gameState.inWaveBreak) {
                console.log(`Wave break turns remaining: ${gameState.waveBreakTurns}`);
                gameState.waveBreakTurns--;
                console.log(`Decremented wave break turns: ${gameState.waveBreakTurns}`);
                if (gameState.waveBreakTurns <= 0) {
                    console.log("Spawning next wave");
                    spawnNextWave();
                } else {

                    if (window.waveBreakTimeout) {
                        clearTimeout(window.waveBreakTimeout);
                    }
                    window.waveBreakTimeout = setTimeout(processEnemyTurn, 1000);
                }
            }

            updateDisplay();
        }

        function updateDisplay() {
            document.getElementById('steel-count').textContent = gameState.resources.Steel;
            document.getElementById('coin-count').textContent = gameState.resources.coins;
            document.getElementById('gold-count').textContent = gameState.resources.gold;
            document.getElementById('oil-count').textContent = gameState.resources.oil;

            document.getElementById('turn-count').textContent = gameState.turn;
            document.getElementById('wave-count').textContent = gameState.wave;
            document.getElementById('enemies-remaining').textContent = gameState.enemiesRemaining;

            const instructions = document.getElementById('turn-instructions');
            if (gameState.inWaveBreak) {
                instructions.textContent = `Wave break: ${gameState.waveBreakTurns} turns until next wave`;
            } else if (gameState.placementMode) {
                instructions.textContent = 'Click on an empty cell to place the selected object';
            } else if (gameState.selectedUnit) {
                instructions.textContent = 'Click on a highlighted cell to move or attack';
            } else {
                instructions.textContent = 'Click an army unit to select it, then click a highlighted square to move';
            }

            document.querySelectorAll('.grid-cell').forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const obj = gameState.grid[y][x];

                cell.className = 'grid-cell';
                cell.innerHTML = '';

                if (obj === 'player') {
                    const sprite = document.createElement('div');
                    sprite.className = 'object-sprite';
                    const img = document.createElement('img');
                    img.src = CONFIG.SPRITES.player;
                    img.alt = 'player';
                    sprite.appendChild(img);
                    cell.appendChild(sprite);
                } else if (obj && obj.type) {
                    const sprite = document.createElement('div');
                    sprite.className = 'object-sprite';
                    const img = document.createElement('img');
                    img.src = obj.getSprite();
                    img.alt = obj.subtype;
                    sprite.appendChild(img);

                    if (obj.health < obj.maxHealth) {
                        const healthBar = document.createElement('div');
                        healthBar.className = 'health-bar';
                        const healthFill = document.createElement('div');
                        healthFill.className = 'health-fill';
                        healthFill.style.width = `${(obj.health / obj.maxHealth) * 100}%`;
                        healthBar.appendChild(healthFill);
                        cell.appendChild(healthBar);
                    }

                    cell.appendChild(sprite);
                }

                if (gameState.selectedUnit &&
                    gameState.selectedUnit.x === (x + gameState.cameraOffset.x) &&
                    gameState.selectedUnit.y === (y + gameState.cameraOffset.y)) {
                    cell.classList.add('selected');
                }
            });

            if (gameState.selectedUnit) {
                highlightValidMoves(gameState.selectedUnit);
            }

            reattachGridCellListeners();

            updateButtonStates();
            updateTechTreeDisplay();
        }

        function updateTechTreeDisplay() {
            const techTreeButtons = document.getElementById('tech-tree-buttons');
            if (!techTreeButtons) return;

            techTreeButtons.innerHTML = '';

            for (const techId in CONFIG.TECH_TREE) {
                const tech = CONFIG.TECH_TREE[techId];
                const button = document.createElement('button');
                button.className = 'btn';
                button.dataset.techId = techId;

                if (gameState.isTechResearched(techId)) {
                    button.classList.add('researched');
                } else if (gameState.availableTechs.has(techId)) {
                    button.classList.add('available');
                } else {
                    button.classList.add('disabled');
                }

                const btnLeft = document.createElement('div');
                btnLeft.className = 'btn-left';

                const img = document.createElement('img');
                img.src = './sprites/research.png';
                img.alt = tech.name;
                btnLeft.appendChild(img);

                const span = document.createElement('span');
                span.textContent = tech.name;
                btnLeft.appendChild(span);

                const btnRight = document.createElement('div');
                btnRight.className = 'btn-right';

                const costContainer = document.createElement('div');
                costContainer.className = 'btn-right';

                if (tech.cost.Steel) {
                    const steelCost = document.createElement('div');
                    steelCost.className = 'lowcol';
                    steelCost.innerHTML = `<img src="./sprites/ironin.png" style="width: 12px; height: 12px; vertical-align: middle; margin-right: 2px;">${tech.cost.Steel}`;
                    costContainer.appendChild(steelCost);
                }
                if (tech.cost.coins) {
                    const coinCost = document.createElement('div');
                    coinCost.className = 'lowcol';
                    coinCost.innerHTML = `<img src="./sprites/coin.png" style="width: 12px; height: 12px; vertical-align: middle; margin-right: 2px;">${tech.cost.coins}`;
                    costContainer.appendChild(coinCost);
                }
                if (tech.cost.gold) {
                    const goldCost = document.createElement('div');
                    goldCost.className = 'lowcol';
                    goldCost.innerHTML = `<img src="./sprites/goldin.png" style="width: 12px; height: 12px; vertical-align: middle; margin-right: 2px;">${tech.cost.gold}`;
                    costContainer.appendChild(goldCost);
                }

                btnRight.appendChild(costContainer);

                const infoIcon = document.createElement('div');
                infoIcon.className = 'info-icon';
                infoIcon.textContent = 'i';

                button.appendChild(btnLeft);
                button.appendChild(btnRight);
                button.appendChild(infoIcon);

                button.addEventListener('click', () => {
                    if (gameState.isTechResearched(techId)) {
                        showNotification(`${tech.name} already researched!`, CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y);
                    } else if (gameState.canResearchTech(techId)) {
                        if (gameState.researchTech(techId)) {
                            showNotification(`${tech.name} researched!`, CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
                            updateDisplay();
                        }
                    } else {
                        showNotification(`Cannot research ${tech.name} yet!`, CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'warning');
                    }
                });

                const prereqText = tech.prerequisites.length > 0 ?
                    `Prerequisites: ${tech.prerequisites.map(id => CONFIG.TECH_TREE[id].name).join(', ')}` :
                    'No prerequisites';
                button.dataset.info = `${tech.name},${tech.description},${prereqText}`;

                infoIcon.addEventListener('click', function (e) {
                    e.stopPropagation();
                    showInfoPopup(button);
                });

                techTreeButtons.appendChild(button);
            }
        }

        function updateTechTreeDisplay() {
            return;
        }

        function updateButtonStates() {
            document.querySelectorAll('.btn').forEach(btn => {
                btn.classList.remove('active');
            });

            if (gameState.placementMode) {
                const activeButton = document.querySelector(`[data-mode="${gameState.placementMode}"]`);
                if (activeButton) {
                    activeButton.classList.add('active');
                }
            }

            document.querySelectorAll('.btn[data-cost]').forEach(btn => {
                try {
                    const cost = JSON.parse(btn.dataset.cost);
                    if (gameState.canAfford(cost)) {
                        btn.classList.remove('disabled');
                    } else {
                        btn.classList.add('disabled');
                    }

                    const mode = btn.dataset.mode;
                    if (mode && isBuildingRestricted(mode)) {
                        btn.classList.add('disabled');
                        if (!btn.dataset.originalTitle) {
                            btn.dataset.originalTitle = btn.title || '';
                            btn.title = 'Research required: ' + getResearchRequirementName(mode);
                        }
                    } else if (btn.dataset.originalTitle !== undefined) {
                        btn.title = btn.dataset.originalTitle;
                        delete btn.dataset.originalTitle;
                    }
                } catch (e) {
                    console.warn('Error parsing cost for button:', btn, e);
                }
            });
        }

        function getResearchRequirementName(mode) {
            const buildingRequirements = {
                'wall-steel': 'Advanced Defense',
                'wall-spike': 'Spike Traps',
                'wall-fortress': 'Fortress',
                'tech-goldturret': 'Fortified Defense',
                'tech-turret': 'Basic Turret',
                'tech-bomb': 'Bomb Tech',
                'tech-supply': 'Supply Systems',
                'tech-goldminer': 'Advanced Mining',
                'tech-oilrig': 'Oil Rig Tech',
                'tech-coinmaker': 'Premium Mining',
                'tech-campfire': 'Campfire Tech',
                'army-tank': 'Elite Units',
                'army-siegetower': 'Siege Weapons',
                'army-king': 'Command Units',
                'army-barrack': 'Barrack Tech',
                'army-archer': 'Ranged Units',
                'army-knight': 'Advanced Army'
            };

            if (buildingRequirements[mode]) {
                return buildingRequirements[mode];
            }

            if (mode === 'wall') {
                return 'Fortress';
            }
            if (mode === 'army-scout') {
                return 'None';
            }

            if (mode === 'tech') {
                return 'None';
            }

            return 'Unknown Research';
        }

        function showNotification(message, x, y, type) {
            let container = document.querySelector('.notification-container');
            if (!container) {
                container = document.createElement('div');
                container.className = 'notification-container';
                document.body.appendChild(container);
            }

            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;

            container.insertBefore(notification, container.firstChild);

            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.3s ease forwards';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        function createParticleEffect(x, y, color, count = 15) {
            const effectContainer = document.createElement('div');
            effectContainer.className = 'particle-effect';
            effectContainer.style.left = x + 'px';
            effectContainer.style.top = y + 'px';
            document.body.appendChild(effectContainer);

            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.backgroundColor = color;
                effectContainer.appendChild(particle);

                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;

                const size = 2 + Math.random() * 4;
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';

                let posX = 0;
                let posY = 0;
                let opacity = 1;
                particle.style.opacity = opacity;

                const animate = () => {
                    posX += vx;
                    posY += vy;
                    opacity -= 0.02;

                    if (opacity <= 0) {
                        particle.remove();
                        return;
                    }

                    particle.style.transform = `translate(${posX}px, ${posY}px)`;
                    particle.style.opacity = opacity;

                    requestAnimationFrame(animate);
                };

                animate();
            }

            setTimeout(() => {
                if (effectContainer.parentNode) {
                    effectContainer.parentNode.removeChild(effectContainer);
                }
            }, 1000);
        }

        function createPlacementEffect(x, y) {
            const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
                const rect = cell.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                createParticleEffect(centerX, centerY, '#66d9ff', 20);
            }
        }

        function createEnemyDefeatEffect(x, y) {
            const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
                const rect = cell.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                createParticleEffect(centerX, centerY, '#ff5555', 25);
            }
        }

        let lastResourceEffectTime = 0;
        const RESOURCE_EFFECT_COOLDOWN = 2000;

        function createResourceCollectionEffect(x, y, resourceType) {
            const now = Date.now();
            if (now - lastResourceEffectTime < RESOURCE_EFFECT_COOLDOWN) {
                return;
            }
            lastResourceEffectTime = now;

            const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
                const rect = cell.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let color;
                switch (resourceType) {
                    case 'Steel': color = '#aaaaaa'; break;
                    case 'coins': color = '#d4af37'; break;
                    case 'gold': color = '#ffcc00'; break;
                    default: color = '#66d9ff';
                }

                createParticleEffect(centerX, centerY, color, 5);
            }
        }

        const BUTTONS = [
            { id: 'place-wall', mode: 'wall', cost: { Steel: 10 } },
            { id: 'place-steel-wall', mode: 'wall-steel', cost: { Steel: 20 } },
            { id: 'place-spike', mode: 'wall-spike', cost: { Steel: 15 } },
            { id: 'place-fortress', mode: 'wall-fortress', cost: { gold: 25 } },
            { id: 'place-tech', mode: 'tech', cost: { Steel: 20 } },
            { id: 'place-gold-miner', mode: 'tech-goldminer', cost: { Steel: 25 } },
            { id: 'place-coin-maker', mode: 'tech-coinmaker', cost: { Steel: 30 } },
            { id: 'place-oil-rig', mode: 'tech-oilrig', cost: { Steel: 35 } },
            { id: 'place-turret', mode: 'tech-turret', cost: { Steel: 40 } },
            { id: 'place-gold-turret', mode: 'tech-goldturret', cost: { gold: 200 } },
            { id: 'place-bomb', mode: 'tech-bomb', cost: { gold: 10 } },
            { id: 'place-supply', mode: 'tech-supply', cost: { gold: 35 } },
            { id: 'place-campfire', mode: 'tech-campfire', cost: { Steel: 30 } },
            { id: 'place-scout', mode: 'army-scout', cost: { coins: 15 } },
            { id: 'place-knight', mode: 'army-knight', cost: { coins: 25 } },
            { id: 'place-archer', mode: 'army-archer', cost: { coins: 20 } },
            { id: 'place-tank', mode: 'army-tank', cost: { coins: 50 } },
            { id: 'place-siege-tower', mode: 'army-siegetower', cost: { coins: 275 } },
            { id: 'place-king', mode: 'army-king', cost: { gold: 500 } },
            { id: 'place-barrack', mode: 'army-barrack', cost: { gold: 50 } }
        ];

        function setupEventListeners() {
            makeFoldersDraggable();

            document.querySelectorAll('[data-folder] .folder-title').forEach(function (title) {
                const clone = title.cloneNode(true);
                title.parentNode.replaceChild(clone, title);

                clone.addEventListener('click', function (e) {
                    e.stopPropagation();
                    const folder = clone.closest('.folder');
                    folder.classList.toggle('open');

                    if (folder.classList.contains('open')) {
                        const rect = clone.getBoundingClientRect();
                        const folderContent = folder.querySelector('.folder-content');
                        if (folderContent) {
                            folderContent.style.left = rect.left + 'px';
                            folderContent.style.top = (rect.bottom + 5) + 'px';
                        }
                    }
                });
            });

            const techTreeButton = document.getElementById('tech-tree-button');
            if (techTreeButton) {
                const clone = techTreeButton.cloneNode(true);
                techTreeButton.parentNode.replaceChild(clone, techTreeButton);

                clone.addEventListener('click', function (e) {
                    e.stopPropagation();
                    const popup = document.getElementById('tech-tree-popup');
                    const overlay = document.getElementById('tech-tree-overlay');
                    if (popup) popup.style.display = 'flex';
                    if (overlay) overlay.style.display = 'block';
                    renderTechTree();
                    makeTechTreeDraggable();
                });
            }

            const techTreeClose = document.getElementById('tech-tree-close');
            if (techTreeClose) {
                const clone = techTreeClose.cloneNode(true);
                techTreeClose.parentNode.replaceChild(clone, techTreeClose);

                clone.addEventListener('click', function () {
                    const popup = document.getElementById('tech-tree-popup');
                    const overlay = document.getElementById('tech-tree-overlay');
                    if (popup) popup.style.display = 'none';
                    if (overlay) overlay.style.display = 'none';
                });
            }

            const techTreeOverlay = document.getElementById('tech-tree-overlay');
            if (techTreeOverlay) {
                const clone = techTreeOverlay.cloneNode(true);
                techTreeOverlay.parentNode.replaceChild(clone, techTreeOverlay);

                clone.addEventListener('click', function () {
                    const popup = document.getElementById('tech-tree-popup');
                    const overlay = document.getElementById('tech-tree-overlay');
                    if (popup) popup.style.display = 'none';
                    if (overlay) overlay.style.display = 'none';
                });
            }

            document.querySelectorAll('.folder-close').forEach(function (button) {
                const clone = button.cloneNode(true);
                button.parentNode.replaceChild(clone, button);

                clone.addEventListener('click', function (e) {
                    e.stopPropagation();
                    const folder = clone.closest('.folder');
                    folder.classList.remove('open');
                });
            });

            document.querySelectorAll('.info-icon').forEach(function (icon) {
                const clone = icon.cloneNode(true);
                icon.parentNode.replaceChild(clone, icon);

                clone.addEventListener('click', function (e) {
                    e.stopPropagation();
                    showInfoPopup(clone.closest('.btn'));
                });
            });

            BUTTONS.forEach(function (buttonData) {
                const button = document.getElementById(buttonData.id);
                if (button) {
                    const clone = button.cloneNode(true);
                    button.parentNode.replaceChild(clone, button);

                    clone.dataset.mode = buttonData.mode;
                    clone.dataset.cost = JSON.stringify(buttonData.cost);
                    clone.addEventListener('click', function (e) {
                        e.stopPropagation();
                        if (isBuildingRestricted(buttonData.mode)) {
                            showNotification('You need to research the required technology first!', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'warning');
                            return;
                        }
                        gameState.placementMode = gameState.placementMode === buttonData.mode ? null : buttonData.mode;
                        
                        // Keep folder open when entering placement mode
                        if (gameState.placementMode === buttonData.mode) {
                            window.keepFoldersOpen = true;
                            console.log('Setting keepFoldersOpen = true for mode:', buttonData.mode);
                        } else {
                            window.keepFoldersOpen = false;
                            console.log('Setting keepFoldersOpen = false');
                        }
                        
                        updateButtonStates();
                        updateDisplay();
                    });
                }
            });

            const saveGameButton = document.getElementById('save-game');
            if (saveGameButton) {
                const clone = saveGameButton.cloneNode(true);
                saveGameButton.parentNode.replaceChild(clone, saveGameButton);
                clone.addEventListener('click', saveGame);
            }

            const loadGameButton = document.getElementById('load-game');
            if (loadGameButton) {
                const clone = loadGameButton.cloneNode(true);
                loadGameButton.parentNode.replaceChild(clone, loadGameButton);
                clone.addEventListener('click', function () {
                    const fileInput = document.getElementById('load-file');
                    if (fileInput) fileInput.click();
                });
            }

            const restartGameButton = document.getElementById('restart-game');
            if (restartGameButton) {
                const clone = restartGameButton.cloneNode(true);
                restartGameButton.parentNode.replaceChild(clone, restartGameButton);
                clone.addEventListener('click', restartGame);
            }

            document.addEventListener('click', function (e) {
                console.log('Global click handler - keepFoldersOpen:', window.keepFoldersOpen);
                console.log('Clicked target:', e.target);
                console.log('Is folder target:', !!e.target.closest('[data-folder]'));
                
                // Don't close folders if we're in placement mode and want to keep them open
                if (!window.keepFoldersOpen && !e.target.closest('[data-folder]')) {
                    console.log('Closing folders');
                    document.querySelectorAll('.folder.open').forEach(folder => {
                        folder.classList.remove('open');
                    });
                } else {
                    console.log('NOT closing folders - keepFoldersOpen:', window.keepFoldersOpen, 'isFolderTarget:', !!e.target.closest('[data-folder]'));
                }

                if (!e.target.closest('.info-popup') && !e.target.closest('.info-icon')) {
                    closeInfoPopup();
                }
            });

            if (!document.getElementById('load-file')) {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.id = 'load-file';
                fileInput.accept = '.coregrid';
                fileInput.style.display = 'none';
                fileInput.addEventListener('change', function (e) {
                    if (e.target.files.length > 0) {
                        loadGame(e.target.files[0]);
                    }
                });
                document.body.appendChild(fileInput);
            }
        }

        function isBuildingRestricted(mode) {
            const buildingRequirements = {
                'wall-steel': 'advanced_defense',
                'wall-spike': 'spike_traps',
                'wall-fortress': 'fortress',

                'tech-goldturret': 'fortified_defense',
                'tech-turret': 'basic_turret',
                'tech-bomb': 'bomb_tech',
                'tech-supply': 'supply_systems',
                'tech-campfire': 'campfire_tech',
                'tech-goldminer': 'advanced_mining',
                'tech-oilrig': 'oil_rig_tech',
                'tech-coinmaker': 'premium_mining',

                'army-tank': 'elite_units',
                'army-siegetower': 'siege_weapons',
                'army-king': 'command_units',
                'army-barrack': 'barrack_tech',
                'army-archer': 'ranged_units',
                'army-knight': 'advanced_army'
            };

            const requiredTech = buildingRequirements[mode];
            if (requiredTech) {
                return !gameState.isTechResearched(requiredTech);
            }
            if (mode === 'wall') {
                return !gameState.isTechResearched('fortress');
            }
            if (mode === 'army-scout') {
                return false;
            }
            if (mode === 'tech') {
                return false;
            }
            return false;
        }

        function getResearchRequirementName(mode) {
            const buildingRequirements = {
                'wall-steel': 'Advanced Defense',
                'wall-spike': 'Spike Traps',
                'wall-fortress': 'Fortress',
                'tech-goldturret': 'Fortified Defense',
                'tech-turret': 'Basic Turret',
                'tech-bomb': 'Bomb Tech',
                'tech-supply': 'Supply Systems',
                'tech-goldminer': 'Advanced Mining',
                'tech-coinmaker': 'Premium Mining',
                'tech-campfire': 'Campfire Tech',
                'army-tank': 'Elite Units',
                'army-siegetower': 'Siege Weapons',
                'army-king': 'Command Units',
                'army-barrack': 'Barrack Tech',
                'army-archer': 'Ranged Units',
                'army-knight': 'Advanced Army'
            };

            if (buildingRequirements[mode]) {
                return buildingRequirements[mode];
            }

            if (mode === 'wall') {
                return 'Fortress';
            }
            if (mode === 'army-scout') {
                return 'None';
            }

            if (mode === 'tech') {
                return 'None';
            }

            return 'Unknown Research';
        }

        function updateTechTreeDisplay() {
            return;
        }

        function renderTechTree() {
            const techTreeContent = document.getElementById('tech-tree-content');
            if (!techTreeContent) {
                console.error('Tech tree content element not found');
                return;
            }

            techTreeContent.innerHTML = '';

            const nodePositions = {
                'fortress': { x: 400, y: 30 },
                'basic_defense': { x: 200, y: 180 },
                'basic_army': { x: 600, y: 180 },
                'advanced_mining': { x: 750, y: 180 },
                'advanced_defense': { x: 100, y: 320 },
                'spike_traps': { x: 200, y: 320 },
                'basic_turret': { x: 300, y: 320 },
                'advanced_army': { x: 500, y: 320 },
                'ranged_units': { x: 600, y: 320 },
                'premium_mining': { x: 850, y: 320 },
                'supply_systems': { x: 750, y: 320 },
                'siege_weapons': { x: 600, y: 460 },
                'elite_units': { x: 500, y: 460 },
                'command_units': { x: 400, y: 460 },
                'barrack_tech': { x: 500, y: 560 },
                'bomb_tech': { x: 200, y: 460 },
                'campfire_tech': { x: 750, y: 460 },
                'fortified_defense': { x: 200, y: 600 },
                'oil_rig_tech': { x: 850, y: 460 }
            };

            for (const techId in CONFIG.TECH_TREE) {
                const tech = CONFIG.TECH_TREE[techId];
                const fromPos = nodePositions[techId];

                if (fromPos && tech.prerequisites) {
                    tech.prerequisites.forEach(prereqId => {
                        const toPos = nodePositions[prereqId];
                        if (toPos) {
                            const isResearched = gameState.isTechResearched(techId) && gameState.isTechResearched(prereqId);
                            const isLocked = !gameState.isTechResearched(techId) && !gameState.isTechResearched(prereqId) &&
                                !gameState.availableTechs.has(techId) && !gameState.availableTechs.has(prereqId);
                            createConnectionLine(techTreeContent, fromPos, toPos, isResearched, isLocked);
                        }
                    });
                }
            }

            for (const techId in CONFIG.TECH_TREE) {
                const tech = CONFIG.TECH_TREE[techId];
                const pos = nodePositions[techId];

                if (pos) {
                    createTechNode(techTreeContent, techId, tech, pos);
                }
            }
        }

        function createConnectionLine(container, fromPos, toPos, isResearched, isLocked) {
            const line = document.createElement('div');
            line.className = 'tech-connection';
            if (isResearched) {
                line.classList.add('researched');
            } else if (isLocked) {
                line.classList.add('locked');
            }

            const dx = toPos.x - fromPos.x;
            const dy = toPos.y - fromPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

            line.style.width = distance + 'px';
            line.style.height = '4px';
            line.style.left = (fromPos.x + 45) + 'px';
            line.style.top = (fromPos.y + 45) + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.transformOrigin = '0 0';
            line.style.transition = 'all 0.3s ease';

            container.appendChild(line);
        }

        function createTechNode(container, techId, tech, pos) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'tech-node';
            nodeDiv.dataset.techId = techId;
            nodeDiv.style.left = pos.x + 'px';
            nodeDiv.style.top = pos.y + 'px';

            if (gameState.isTechResearched(techId)) {
                nodeDiv.classList.add('researched');
            } else if (gameState.availableTechs.has(techId)) {
                nodeDiv.classList.add('available');
            } else {
                nodeDiv.classList.add('locked');
            }

            const iconDiv = document.createElement('div');
            iconDiv.className = 'tech-node-icon';

            const img = document.createElement('img');
            const iconPath = `./sprites/${tech.icon || 'research.png'}`;
            img.src = iconPath;
            img.alt = tech.name;
            img.onerror = function () {
                this.src = './sprites/research.png';
            };
            iconDiv.appendChild(img);
            nodeDiv.appendChild(iconDiv);

            let costHtml = '';
            if (tech.cost.Steel || tech.cost.coins || tech.cost.gold) {
                const costs = [];
                if (tech.cost.Steel) costs.push(`${tech.cost.Steel} Steel`);
                if (tech.cost.coins) costs.push(`${tech.cost.coins} Coins`);
                if (tech.cost.gold) costs.push(`${tech.cost.gold} Gold`);
                costHtml = `\nCost: ${costs.join(', ')}`;
            }

            nodeDiv.title = `${tech.name}\n${tech.description}${costHtml}`;

            if (!gameState.isTechResearched(techId) && gameState.availableTechs.has(techId)) {
                nodeDiv.addEventListener('click', function () {
                    if (gameState.researchTech(techId)) {
                        showNotification(`${tech.name} researched!`, CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
                        renderTechTree();
                    }
                });
            }

            container.appendChild(nodeDiv);
            return nodeDiv;
        }

        function makeTechTreeDraggable() {
            const popup = document.getElementById('tech-tree-popup');
            const header = document.querySelector('.tech-tree-header');

            if (!popup || !header) return;

            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;

            header.addEventListener('mousedown', dragStart);
            document.addEventListener('mouseup', dragEnd);
            document.addEventListener('mousemove', drag);

            function dragStart(e) {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;

                isDragging = true;
                header.style.cursor = 'grabbing';
            }

            function dragEnd() {
                initialX = currentX;
                initialY = currentY;

                isDragging = false;
                header.style.cursor = 'move';
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;

                    xOffset = currentX;
                    yOffset = currentY;

                    popup.style.transform = `translate(${currentX}px, ${currentY}px)`;
                }
            }
        }

        function showInfoPopup(button) {
            const infoData = button.dataset.info.split(',');
            const title = infoData[0];
            const description = infoData[1];
            const stats = infoData.slice(2);

            let overlay = document.querySelector('.info-popup-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'info-popup-overlay';
                document.body.appendChild(overlay);
            }

            let popup = document.querySelector('.info-popup');
            if (!popup) {
                popup = document.createElement('div');
                popup.className = 'info-popup';
                document.body.appendChild(popup);
            }

            let statsHtml = '';
            stats.forEach(function (stat) {
                statsHtml += '<div class="info-popup-stat">' + stat + '</div>';
            });

            popup.innerHTML = `
                <div class="info-popup-header">
                    <div class="info-popup-title">${title}</div>
                    <button class="info-popup-close">×</button>
                </div>
                <div class="info-popup-content">
                    <p>${description}</p>
                    <div class="info-popup-stats">
                        ${statsHtml}
                    </div>
                </div>
            `;

            popup.querySelector('.info-popup-close').addEventListener('click', closeInfoPopup);

            overlay.style.display = 'block';
            popup.style.display = 'block';
        }

        function closeInfoPopup() {
            const overlay = document.querySelector('.info-popup-overlay');
            const popup = document.querySelector('.info-popup');

            if (overlay) overlay.style.display = 'none';
            if (popup) popup.style.display = 'none';
        }

        function showTooltip(element, text) {
            hideTooltip();

            const tooltip = document.createElement('div');
            tooltip.className = 'tech-tooltip';
            tooltip.innerHTML = text;
            tooltip.id = 'tech-tree-tooltip';

            tooltip.style.opacity = '0';

            document.querySelector('.tech-tree-content').appendChild(tooltip);

            setTimeout(() => {
                if (tooltip.parentNode) {
                    tooltip.style.opacity = '1';
                }
            }, 50);
        }

        function updateTooltipPosition(e) {
            const tooltip = document.getElementById('tech-tree-tooltip');
            if (!tooltip) return;

            const techTreeContent = document.querySelector('.tech-tree-content');
            const techTreeRect = techTreeContent.getBoundingClientRect();

            let left = e.clientX - techTreeRect.left + 10;
            let top = e.clientY - techTreeRect.top + 10;

            if (tooltip.offsetWidth) {
                if (left + tooltip.offsetWidth > techTreeRect.width - 10) {
                    left = techTreeRect.width - tooltip.offsetWidth - 10;
                }
                if (top + tooltip.offsetHeight > techTreeRect.height - 10) {
                    top = techTreeRect.height - tooltip.offsetHeight - 10;
                }
                if (left < 10) {
                    left = 10;
                }
                if (top < 10) {
                    top = 10;
                }
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function hideTooltip() {
            const tooltip = document.getElementById('tech-tree-tooltip');
            if (tooltip) {
                tooltip.style.opacity = '0';
                setTimeout(() => {
                    if (tooltip.parentNode) {
                        tooltip.parentNode.removeChild(tooltip);
                    }
                }, 200);
            }
        }

        function makeFoldersDraggable() {
            document.querySelectorAll('.folder-content').forEach(function (folderContent) {
                const header = folderContent.querySelector('.folder-header');
                if (!header) return;

                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                let xOffset = 0;
                let yOffset = 0;

                header.addEventListener('mousedown', dragStart);
                document.addEventListener('mouseup', dragEnd);
                document.addEventListener('mousemove', drag);

                function dragStart(e) {
                    if (e.target.closest('.folder-close')) return;

                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;

                    isDragging = true;
                    header.style.cursor = 'grabbing';
                }

                function dragEnd() {
                    initialX = currentX;
                    initialY = currentY;

                    isDragging = false;
                    header.style.cursor = 'move';
                }

                function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;

                        xOffset = currentX;
                        yOffset = currentY;

                        setTranslate(currentX, currentY, folderContent);
                    }
                }

                function setTranslate(xPos, yPos, el) {
                    el.style.transform = 'translate3d(' + xPos + 'px, ' + yPos + 'px, 0)';
                }
            });
        }

        function restartGame() {
            if (confirm('Are you sure you want to restart the game?')) {
                gameState.reset();
                initGame();
            }
        }

        function saveGame() {
            const gameData = {
                resources: gameState.resources,
                turn: gameState.turn,
                wave: gameState.wave,
                waveBreakTurns: gameState.waveBreakTurns,
                inWaveBreak: gameState.inWaveBreak,
                enemiesRemaining: gameState.enemiesRemaining,
                researchedTechs: Array.from(gameState.researchedTechs),
                grid: serializeGrid()
            };

            const blob = new Blob([JSON.stringify(gameData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `coregrid_save_${new Date().toISOString().slice(0, 10)}.coregrid`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('Game saved successfully!', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
        }

        function loadGame(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const gameData = JSON.parse(e.target.result);

                    if (!gameData.resources || !gameData.grid) {
                        throw new Error('Invalid save file');
                    }

                    gameState.resources = gameData.resources;
                    gameState.turn = gameData.turn;
                    gameState.wave = gameData.wave;
                    gameState.waveBreakTurns = gameData.waveBreakTurns || 0;
                    gameState.inWaveBreak = gameData.inWaveBreak || false;
                    gameState.enemiesRemaining = gameData.enemiesRemaining || 0;

                    gameState.researchedTechs = new Set(gameData.researchedTechs || []);
                    gameState.updateAvailableTechs();

                    deserializeGrid(gameData.grid);

                    showNotification('Game loaded successfully!', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
                    updateDisplay();
                } catch (error) {
                    showNotification('Error loading game: Invalid save file', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'danger');
                    console.error('Error loading game:', error);
                }
            };
            reader.readAsText(file);
        }

        function serializeGrid() {
            const gridData = [];
            for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                const row = [];
                for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                    const obj = gameState.grid[y][x];
                    if (obj === 'player') {
                        row.push('player');
                    } else if (obj && obj.type) {
                        row.push({
                            type: obj.type,
                            subtype: obj.subtype,
                            health: obj.health,
                            maxHealth: obj.maxHealth,
                            ...(obj.type === 'tech' && (obj.subtype === 'turret' || obj.subtype === 'goldturret') ? { shotsLeft: obj.shotsLeft } : {}),
                            ...(obj.type === 'army' && obj.subtype === 'barrack' ? { spawnCounter: obj.spawnCounter } : {})
                        });
                    } else {
                        row.push(null);
                    }
                }
                gridData.push(row);
            }
            return gridData;
        }

        function deserializeGrid(gridData) {
            gameState.grid = Array(CONFIG.GRID_SIZE_Y).fill().map(() => Array(CONFIG.GRID_SIZE_X).fill(null));
            gameState.objects.clear();

            for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                    const objData = gridData[y][x];
                    if (objData === 'player') {
                        gameState.grid[y][x] = 'player';
                    } else if (objData && objData.type) {
                        let obj;
                        switch (objData.type) {
                            case 'wall':
                                obj = new Wall(x, y, objData.subtype);
                                break;
                            case 'tech':
                                obj = new Tech(x, y, objData.subtype);
                                break;
                            case 'army':
                                obj = new Army(x, y, objData.subtype);
                                break;

                            case 'enemy':
                                obj = new Enemy(x, y, objData.subtype);
                                break;
                            default:
                                continue;
                        }

                        obj.health = objData.health;
                        obj.maxHealth = objData.maxHealth;

                        if (objData.type === 'tech' && (objData.subtype === 'turret' || objData.subtype === 'goldturret') && objData.shotsLeft) {
                            obj.shotsLeft = objData.shotsLeft;
                        }

                        if (objData.type === 'army' && objData.subtype === 'barrack' && objData.spawnCounter) {
                            obj.spawnCounter = objData.spawnCounter;
                        }

                        gameState.grid[y][x] = obj;
                        gameState.objects.set(obj.id, obj);
                    }
                }
            }
        }

        document.addEventListener('keydown', function (event) {
            if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                return;
            }

            event.preventDefault();

            switch (event.key) {
                case 'ArrowUp':
                    moveCamera(0, -1);
                    break;
                case 'ArrowDown':
                    moveCamera(0, 1);
                    break;
                case 'ArrowLeft':
                    moveCamera(-1, 0);
                    break;
                case 'ArrowRight':
                    moveCamera(1, 0);
                    break;
            }

            updateDisplay();
        });

        function moveCamera(dx, dy) {
            gameState.cameraOffset.x += dx;
            gameState.cameraOffset.y += dy;

            updateGridFromWorldObjects();
        }

        function updateGridFromWorldObjects() {
            gameState.grid = Array(CONFIG.GRID_SIZE_Y).fill().map(() => Array(CONFIG.GRID_SIZE_X).fill(null));

            gameState.worldObjects.forEach(obj => {
                const gridX = obj.x - gameState.cameraOffset.x;
                const gridY = obj.y - gameState.cameraOffset.y;

                if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X &&
                    gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                    gameState.grid[gridY][gridX] = obj;
                }
            });

            const playerWorldX = CONFIG.PLAYER_START.x;
            const playerWorldY = CONFIG.PLAYER_START.y;
            const playerGridX = playerWorldX - gameState.cameraOffset.x;
            const playerGridY = playerWorldY - gameState.cameraOffset.y;

            if (playerGridX >= 0 && playerGridX < CONFIG.GRID_SIZE_X &&
                playerGridY >= 0 && playerGridY < CONFIG.GRID_SIZE_Y) {
                gameState.grid[playerGridY][playerGridX] = 'player';
            }
        }

        function addObjectToWorld(obj) {
            gameState.worldObjects.set(obj.id, obj);

            const gridX = obj.x - gameState.cameraOffset.x;
            const gridY = obj.y - gameState.cameraOffset.y;

            if (gridX >= 0 && gridX < CONFIG.GRID_SIZE_X &&
                gridY >= 0 && gridY < CONFIG.GRID_SIZE_Y) {
                gameState.objects.set(obj.id, obj);
                gameState.grid[gridY][gridX] = obj;
            }
        }

        function debugNextWave() {
            console.log("Debug: Manually triggering next wave");
            spawnNextWave();
        }

        let cheatSequence = [];
        const targetSequence = ['i', 'l', 'f'];

        document.addEventListener('keydown', (event) => {
            cheatSequence.push(event.key.toLowerCase());

            if (cheatSequence.length > 3) {
                cheatSequence.shift();
            }

            if (cheatSequence.length === 3 &&
                cheatSequence[0] === targetSequence[0] &&
                cheatSequence[1] === targetSequence[1] &&
                cheatSequence[2] === targetSequence[2]) {

                gameState.resources.Steel += 7000;
                gameState.resources.coins += 7000;
                gameState.resources.gold += 7000;

                updateDisplay();

                showNotification('Cheat activated! +7000 Steel, Coins, and Gold', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');

                cheatSequence = [];
            }
        });

        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>

</html>