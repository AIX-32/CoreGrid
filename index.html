<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoreGrid - Strategy Defense Game</title>
    <link rel="icon" href="./sprites/tower.png">
    <meta name="description"
        content="CoreGrid - a strategy game where you build and defend your base against waves of enemies">
    <meta name="keywords" content="grid, game, management, resource, online game, strategy game">
    <meta name="author" content="A_I_X">
    <meta name="theme-color" content="#121212">

    <style>
        :root {
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-tertiary: #262626;
            --border-color: #2e2e2e;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --accent-primary: #4caf50;
            --accent-secondary: #d4af37;
            --danger: #f44336;
            --success: #4caf50;
            --warning: #ff9800;
            --cell-size: 42px;
            --grid-gap: 6px;
            --border-radius: 10px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            max-width: 900px;
            width: 100%;
            text-align: center;
        }

        .game-header {
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--accent-secondary);
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .game-subtitle {
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        .ui-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .resources {
            display: flex;
            gap: 20px;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: var(--text-primary);
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border: 1px solid #3a3a3a;
        }

        .resource img {
            width: 24px;
            height: 24px;
        }

        .controls-folder {
            display: flex;
            gap: 10px;
        }

        .folder {
            background: var(--bg-tertiary);
            border-radius: var(--border-radius);
            border: 1px solid #3a3a3a;
            min-width: 120px;
            position: relative;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: all 0.3s ease;
        }

        .folder:hover {
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
        }

        .folder-title {
            padding: 10px;
            background: #2a2a2a;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s ease;
            color: #ddd;
            border-radius: var(--border-radius);
            border: 1px solid #3a3a3a;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .folder-title:hover {
            background: #3a3a3a;
        }

        .folder-title img {
            width: 20px;
            height: 20px;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .folder-content {
            display: none;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            position: absolute;
            top: 100%;
            left: 0;
            background: #222;
            border-radius: 0 0 var(--border-radius) var(--border-radius);
            border: 1px solid #333;
            width: max-content;
            z-index: 101;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .folder.open .folder-content {
            display: flex;
        }

        .btn {
            width: 100px;
            height: 80px;
            border: 1px solid #3a3a3a;
            border-radius: 5px;
            background: var(--bg-tertiary);
            color: #ccc;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            font-size: 12px;
            text-align: center;
            padding: 5px;
        }

        .btn span:first-child {
            font-size: 32px;
        }

        .btn:hover {
            background: #333;
            border-color: #555;
            color: #fff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .btn img {
            width: 16px;
            height: 16px;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
            margin: 0 auto;
            max-width: 16px;
            max-height: 16px;
        }

        .btn.active {
            background: #3a2f1a;
            border-color: var(--accent-secondary);
            color: #fff3c2;
            box-shadow: 0 0 8px rgba(212, 175, 55, 0.6);
        }

        .btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn.disabled:hover {
            transform: none;
            box-shadow: none;
            background: var(--bg-tertiary);
        }

        .game-grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(25, 1fr);
            grid-template-rows: repeat(15, 1fr);
            gap: var(--grid-gap);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            justify-content: center;
            align-content: center;
            min-height: 650px;
            aspect-ratio: 25 / 15;
        }

        .grid-cell {
            background: #2f811b;
            border: 1px solid #398d24;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #ccc;
            border-radius: 5px;
            aspect-ratio: 1 / 1;
        }

        .grid-cell:hover {
            background: #3ea326;
            border: 1px solid #4cb72f;
            transform: translateY(-5px);
            border-radius: 5px;
            z-index: 2;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .grid-cell.selected {
            box-shadow: 0 0 8px var(--accent-secondary);
            border-color: var(--accent-secondary);
            background: rgba(255, 215, 0, 0.2);
        }

        .grid-cell.valid-move {
            background: rgba(76, 175, 80, 0.3);
            border-color: var(--accent-primary);
            cursor: pointer;
        }

        .grid-cell.valid-attack {
            background: rgba(244, 67, 54, 0.3);
            border-color: var(--danger);
            cursor: crosshair;
        }

        .grid-cell.valid-attack:hover {
            background: rgba(244, 67, 54, 0.5);
        }

        .grid-cell .object-sprite {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            border-radius: 2px;
        }

        .grid-cell .object-sprite img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
        }

        .game-info {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .turn-info,
        .wave-info {
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            text-align: center;
            color: var(--text-primary);
            flex: 1;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .info-panel {
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            text-align: left;
            color: var(--text-primary);
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .info-panel h3 {
            margin-bottom: 10px;
            color: var(--accent-secondary);
        }

        .info-panel p {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .control-btn {
            padding: 10px 20px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid #3a3a3a;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .control-btn:hover {
            background: #333;
            border-color: #555;
            transform: translateY(-2px);
        }

        .control-btn.primary {
            background: var(--accent-primary);
            color: white;
        }

        .control-btn.warning {
            background: var(--warning);
            color: white;
        }

        .health-bar {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            height: 3px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: var(--success);
            transition: width 0.3s ease;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            background: var(--success);
            color: white;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            animation: slideIn 0.3s ease, fadeOut 0.3s ease 2.7s forwards;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }


        .lowcol {
            color: #858585;
        }
    </style>
</head>

<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">CoreGrid</h1>
            <p class="game-subtitle">Build, Defend, and Conquer</p>
        </div>

        <div class="ui-panel">
            <div class="resources">
                <div class="resource">
                    <img src="./sprites/ironin.png" alt="Steel">
                    <span id="steel-count">100</span> Steel
                </div>
                <div class="resource">
                    <img src="./sprites/coin.png" alt="Coins">
                    <span id="coin-count">50</span> Coins
                </div>
                <div class="resource">
                    <img src="./sprites/goldin.png" alt="Gold">
                    <span id="gold-count">25</span> Gold
                </div>
            </div>

            <div class="controls-folder">
                <div class="folder" data-folder>
                    <div class="folder-title">
                        <img src="./sprites/wall.png" alt="Walls"> Walls
                    </div>
                    <div class="folder-content">
                        <button class="btn" id="place-wall">
                            <img src="./sprites/wall.png" alt="Wall"> Wall <span class="lowcol">10S</span>
                        </button>
                        <button class="btn" id="place-steel-wall">
                            <img src="./sprites/wallsteel.png" alt="Steel Wall"> Steel <span class="lowcol">20S</span>
                        </button>
                        <button class="btn" id="place-spike">
                            <img src="./sprites/spike.png" alt="Spike"> Spike <span class="lowcol">15S</span>
                        </button>
                        <button class="btn" id="place-fortress">
                            <img src="./sprites/spawn.png" alt="Fortress"> Fortress <span class="lowcol">25G</span>
                        </button>
                    </div>
                </div>

                <div class="folder" data-folder>
                    <div class="folder-title">
                        <img src="./sprites/turret.png" alt="Tech"> Tech
                    </div>
                    <div class="folder-content">
                        <button class="btn" id="place-tech">
                            <img src="./sprites/iron.png" alt="Steel Mine"> Steel Mine <span class="lowcol">20S</span>
                        </button>
                        <button class="btn" id="place-gold-miner">
                            <img src="./sprites/gold.png" alt="Gold Mine"> Gold Mine <span class="lowcol">25S</span>
                        </button>
                        <button class="btn" id="place-coin-maker">
                            <img src="./sprites/bank.png" alt="Bank"> Bank <span class="lowcol">30S</span>
                        </button>
                        <button class="btn" id="place-turret">
                            <img src="./sprites/turret.png" alt="Turret"> Turret <span class="lowcol">40S</span>
                        </button>
                        <button class="btn" id="place-bomb">
                            <img src="./sprites/bomb.png" alt="Bomb"> Bomb <span class="lowcol">10G</span>
                        </button>
                        <button class="btn" id="place-supply">
                            <img src="./sprites/supply.gif" alt="Supply Drop"> Supply Drop <span
                                class="lowcol">35G</span>
                        </button>
                        <button class="btn" id="place-campfire">
                            <img src="./sprites/campfire.gif" alt="Campfire"> Campfire <span class="lowcol">30S</span>
                        </button>
                    </div>
                </div>

                <div class="folder" data-folder>
                    <div class="folder-title">
                        <img src="./sprites/Tank.png" alt="Army"> Army
                    </div>
                    <div class="folder-content">
                        <button class="btn" id="place-scout">
                            <img src="./sprites/soldier.png" alt="Soldier"> Soldier <span class="lowcol">15C</span>
                        </button>
                        <button class="btn" id="place-knight">
                            <img src="./sprites/knight.png" alt="Knight"> Knight <span class="lowcol">25C</span>
                        </button>
                        <button class="btn" id="place-archer">
                            <img src="./sprites/Archer.png" alt="Archer"> Archer <span class="lowcol">20C</span>
                        </button>
                        <button class="btn" id="place-tank">
                            <img src="./sprites/Tank.png" alt="Tank"> Tank <span class="lowcol">50C</span>
                        </button>
                        <button class="btn" id="place-siege-tower">
                            <img src="./sprites/siegetower.png" alt="Siege Tower"> Siege Tower <span
                                class="lowcol">275C</span>
                        </button>
                        <button class="btn" id="place-king">
                            <img src="./sprites/king.png" alt="King"> King <span class="lowcol">500G</span>
                        </button>
                        <button class="btn" id="place-barrack">
                            <img src="./sprites/barrack.png" alt="Barrack"> Barrack <span class="lowcol">50G</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="game-grid-container">
            <div class="game-grid" id="game-grid"></div>
        </div>

        <div class="game-info">
            <div class="turn-info">
                <h3>Turn Information</h3>
                <p>Turn: <span id="turn-count">1</span></p>
                <p id="turn-instructions"></p>
            </div>
            <div class="wave-info">
                <h3>Wave Information</h3>
                <p>Wave: <span id="wave-count">1</span></p>
                <p id="wave-status">Enemies remaining: <span id="enemies-remaining">3</span></p>
            </div>
        </div>

        <div class="info-panel">
            <h3>Game Instructions</h3>
            <p><strong>Combat:</strong> Move your army units into enemy squares to attack! Different units have
                different movement ranges and attacks.</p>
            <p><strong>Defense:</strong> Use walls and fortresses to protect your units and resources.</p>
            <p><strong>Resources:</strong> Place miner buildings to generate resources.</p>
            <p><strong>Waves:</strong> Defend against waves of different enemies.</p>
        </div>

        <div class="controls">
            <button class="control-btn primary" id="save-game">Save Game</button>
            <button class="control-btn" id="load-game">Load Game</button>
            <button class="control-btn warning" id="restart-game">Restart Game</button>
        </div>
    </div>

    <script>
        const CONFIG = {
            GRID_SIZE_X: 25,
            GRID_SIZE_Y: 15,
            PLAYER_START: { x: 12, y: 7 },
            WAVE_BREAK_TURNS: 3,
            INITIAL_RESOURCES: {
                Steel: 100,
                coins: 50,
                gold: 25
            },
            SPRITES: {
                player: './sprites/spawn.png',
                wall: {
                    stone: './sprites/wall.png',
                    steel: './sprites/wallsteel.png',
                    spike: './sprites/spike.png',
                    fortress: './sprites/spawn.png'
                },
                tech: {
                    miner: './sprites/iron.png',
                    goldminer: './sprites/gold.png',
                    coinmaker: './sprites/bank.png',
                    turret: './sprites/turret.png',
                    bomb: './sprites/bomb.png',
                    supply: './sprites/supply.gif',
                    campfire: './sprites/campfire.gif'
                },
                army: {
                    scout: './sprites/soldier.png',
                    knight: './sprites/knight.png',
                    archer: './sprites/Archer.png',
                    tank: './sprites/Tank.png',
                    king: './sprites/king.png',
                    barrack: './sprites/barrack.png',
                    siegetower: './sprites/siegetower.png'
                },
                enemy: {
                    basic: './sprites/defaultbad.png',
                    fast: './sprites/badfast.png',
                    tank: './sprites/badheavy.png',
                    ranged: './sprites/badarcher.png',
                    healer: './sprites/badhealer.png'
                }
            }
        };

        class GameState {
            constructor() {
                this.reset();
            }

            reset() {
                this.resources = { ...CONFIG.INITIAL_RESOURCES };
                this.turn = 1;
                this.selectedUnit = null;
                this.placementMode = null;
                this.grid = Array(CONFIG.GRID_SIZE_Y).fill().map(() => Array(CONFIG.GRID_SIZE_X).fill(null));
                this.objects = new Map();
                this.wave = 1;
                this.waveBreakTurns = 0;
                this.inWaveBreak = false;
                this.enemiesRemaining = 0;
            }

            canAfford(cost) {
                return this.resources.Steel >= (cost.Steel || 0) &&
                    this.resources.coins >= (cost.coins || 0) &&
                    this.resources.gold >= (cost.gold || 0);
            }

            spendResources(cost) {
                if (cost.Steel) this.resources.Steel -= cost.Steel;
                if (cost.coins) this.resources.coins -= cost.coins;
                if (cost.gold) this.resources.gold -= cost.gold;
            }

            addResources(resources) {
                if (resources.Steel) this.resources.Steel += resources.Steel;
                if (resources.coins) this.resources.coins += resources.coins;
                if (resources.gold) this.resources.gold += resources.gold;
            }

            countEnemies() {
                let count = 0;
                for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                    for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                        const obj = this.grid[y][x];
                        if (obj && obj.type === 'enemy') count++;
                    }
                }
                this.enemiesRemaining = count;
                return count;
            }
        }

        class GameObject {
            constructor(x, y, type, subtype) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.subtype = subtype;
                this.id = `${type}_${subtype}_${x}_${y}_${Date.now()}`;
            }

            getSprite() {
                return CONFIG.SPRITES[this.type]?.[this.subtype] || 'sprites/missing.png';
            }
        }

        class Wall extends GameObject {
            constructor(x, y, subtype = 'stone') {
                super(x, y, 'wall', subtype);
                this.health = this.getMaxHealth();
                this.maxHealth = this.health;
                this.blocksMovement = true;
            }

            getMaxHealth() {
                switch (this.subtype) {
                    case 'steel': return 3;
                    case 'spike': return 3;
                    case 'fortress': return 5;
                    default: return 1;
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        class Tech extends GameObject {
            constructor(x, y, subtype = 'miner') {
                super(x, y, 'tech', subtype);
                this.cost = this.getCost();
                this.health = 2;
                this.maxHealth = 2;

                if (subtype === 'turret') {
                    this.shotsLeft = 8;
                    this.range = 3;
                }
            }

            getCost() {
                const costs = {
                    miner: { Steel: 20 },
                    goldminer: { Steel: 25 },
                    coinmaker: { Steel: 30 },
                    turret: { Steel: 40 },
                    bomb: { gold: 10 },
                    supply: { gold: 35 },
                    campfire: { Steel: 30 }
                };
                return costs[this.subtype] || { Steel: 20 };
            }

            onTurn() {
                const campfireBonus = 1 + (0.5 * this.getNearbyCampfires());

                switch (this.subtype) {
                    case 'miner':
                        gameState.addResources({ Steel: Math.floor(5 * campfireBonus) });
                        break;
                    case 'goldminer':
                        gameState.addResources({ gold: Math.ceil(1 * campfireBonus) });
                        break;
                    case 'coinmaker':
                        gameState.addResources({ coins: Math.floor(5 * campfireBonus) });
                        break;
                    case 'supply':
                        this.handleSupplyDrop();
                        break;
                    case 'turret':
                        this.attackNearbyEnemies();
                        break;
                    case 'bomb':
                        this.handleBomb();
                        break;
                }
            }

            getNearbyCampfires() {
                let count = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const x = this.x + dx;
                        const y = this.y + dy;
                        if (x >= 0 && x < CONFIG.GRID_SIZE_X && y >= 0 && y < CONFIG.GRID_SIZE_Y) {
                            const obj = gameState.grid[y][x];
                            if (obj && obj.type === 'tech' && obj.subtype === 'campfire') {
                                count++;
                            }
                        }
                    }
                }
                return count;
            }

            handleSupplyDrop() {
                if (Math.random() < 0.33) {
                    const resources = ['coins', 'Steel', 'gold'];
                    const resource = resources[Math.floor(Math.random() * resources.length)];
                    const amount = 5 + Math.floor(Math.random() * 6);
                    gameState.addResources({ [resource]: amount });
                    showNotification(`+${amount} ${resource} from Supply Drop!`, this.x, this.y);
                }
            }

            attackNearbyEnemies() {
                if (this.shotsLeft <= 0) return false;

                for (let dy = -this.range; dy <= this.range; dy++) {
                    for (let dx = -this.range; dx <= this.range; dx++) {
                        if (Math.max(Math.abs(dx), Math.abs(dy)) > this.range) continue;
                        const x = this.x + dx;
                        const y = this.y + dy;
                        if (x >= 0 && x < CONFIG.GRID_SIZE_X && y >= 0 && y < CONFIG.GRID_SIZE_Y) {
                            const target = gameState.grid[y][x];
                            if (target && target.type === 'enemy') {
                                gameState.grid[y][x] = null;
                                gameState.objects.delete(target.id);
                                this.shotsLeft--;
                                if (this.shotsLeft <= 0) {
                                    gameState.grid[this.y][this.x] = null;
                                    gameState.objects.delete(this.id);
                                }
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            handleBomb() {
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const x = this.x + dx;
                        const y = this.y + dy;
                        if (x >= 0 && x < CONFIG.GRID_SIZE_X && y >= 0 && y < CONFIG.GRID_SIZE_Y) {
                            const target = gameState.grid[y][x];
                            if (target && target.type === 'enemy') {
                                for (let dy2 = -2; dy2 <= 2; dy2++) {
                                    for (let dx2 = -2; dx2 <= 2; dx2++) {
                                        const x2 = this.x + dx2;
                                        const y2 = this.y + dy2;
                                        if (x2 >= 0 && x2 < CONFIG.GRID_SIZE_X && y2 >= 0 && y2 < CONFIG.GRID_SIZE_Y) {
                                            const target2 = gameState.grid[y2][x2];
                                            if (target2 && target2.type === 'enemy') {
                                                gameState.grid[y2][x2] = null;
                                                gameState.objects.delete(target2.id);
                                            }
                                        }
                                    }
                                }
                                gameState.grid[this.y][this.x] = null;
                                gameState.objects.delete(this.id);
                                return;
                            }
                        }
                    }
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        class Army extends GameObject {
            constructor(x, y, subtype = 'scout') {
                super(x, y, 'army', subtype);
                this.cost = this.getCost();
                this.health = this.getMaxHealth();
                this.maxHealth = this.health;
                this.range = this.getRange();
                this.movement = this.getMovement();

                if (subtype === 'barrack') {
                    this.spawnCounter = 0;
                }
            }

            getCost() {
                const costs = {
                    scout: { coins: 15 },
                    knight: { coins: 25 },
                    archer: { coins: 20 },
                    tank: { coins: 50 },
                    siegetower: { coins: 275 },
                    king: { gold: 500 },
                    barrack: { gold: 50 }
                };
                return costs[this.subtype] || { coins: 15 };
            }

            getMaxHealth() {
                switch (this.subtype) {
                    case 'tank': return 5;
                    case 'king': return 25;
                    default: return 1;
                }
            }

            getRange() {
                switch (this.subtype) {
                    case 'archer':
                    case 'siegetower': return 4;
                    case 'king': return 2;
                    default: return 1;
                }
            }

            getMovement() {
                switch (this.subtype) {
                    case 'knight': return 5;
                    case 'archer': return 1;
                    case 'tank': return 1;
                    case 'king': return 2;
                    default: return 1;
                }
            }

            getValidMoves() {
                const moves = [];
                const attacks = [];

                const directions = this.subtype === 'knight' ?
                    [[-1, -1], [-1, 1], [1, -1], [1, 1]] :
                    [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];

                directions.forEach(([dx, dy]) => {
                    for (let i = 1; i <= this.movement; i++) {
                        const x = this.x + dx * i;
                        const y = this.y + dy * i;

                        if (x < 0 || x >= CONFIG.GRID_SIZE_X || y < 0 || y >= CONFIG.GRID_SIZE_Y) break;

                        const target = gameState.grid[y][x];
                        if (target === null) {
                            moves.push({ x, y });
                        } else if (target.type === 'enemy') {
                            attacks.push({ x, y });
                            break;
                        } else {
                            break;
                        }
                    }
                });

                if (this.subtype === 'archer' || this.subtype === 'siegetower') {
                    const allDirections = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];
                    allDirections.forEach(([dx, dy]) => {
                        for (let i = 1; i <= this.range; i++) {
                            const x = this.x + dx * i;
                            const y = this.y + dy * i;

                            if (x < 0 || x >= CONFIG.GRID_SIZE_X || y < 0 || y >= CONFIG.GRID_SIZE_Y) break;

                            const target = gameState.grid[y][x];
                            if (target && target.type === 'enemy') {
                                attacks.push({ x, y });
                            }
                        }
                    });
                }

                return { moves, attacks };
            }

            onTurn() {
                if (this.subtype === 'barrack') {
                    this.spawnCounter = (this.spawnCounter || 0) + 1;
                    if (this.spawnCounter >= 2) {
                        this.spawnCounter = 0;
                        const x = this.x - 1;
                        const y = this.y;
                        if (x >= 0 && gameState.grid[y][x] === null) {
                            const scout = new Army(x, y, 'scout');
                            gameState.grid[y][x] = scout;
                            gameState.objects.set(scout.id, scout);
                            showNotification('Barrack spawned a Soldier!', x, y);
                        }
                    }
                }
            }

            moveTo(x, y) {
                gameState.grid[this.y][this.x] = null;
                gameState.grid[y][x] = this;
                this.x = x;
                this.y = y;
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        class Enemy extends GameObject {
            constructor(x, y, subtype = 'basic') {
                super(x, y, 'enemy', subtype);
                this.health = this.getMaxHealth();
                this.maxHealth = this.health;
            }

            getMaxHealth() {
                switch (this.subtype) {
                    case 'tank': return 100;
                    case 'fast': return 30;
                    case 'ranged': return 40;
                    case 'healer': return 25;
                    default: return 50;
                }
            }

            onTurn() {
                if (this.x === CONFIG.PLAYER_START.x && this.y === CONFIG.PLAYER_START.y) {
                    gameOver();
                    return;
                }

                const attacks = this.getValidAttacks();
                if (attacks.length > 0) {
                    const target = attacks[0].target;
                    this.attackTarget(target);
                    return;
                }

                this.moveTowardsPlayer();
            }

            getValidAttacks() {
                const attacks = [];
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];

                directions.forEach(([dx, dy]) => {
                    const x = this.x + dx;
                    const y = this.y + dy;

                    if (x >= 0 && x < CONFIG.GRID_SIZE_X && y >= 0 && y < CONFIG.GRID_SIZE_Y) {
                        const target = gameState.grid[y][x];
                        if (target && (
                            (target.type === 'army' && target.owner === 'player') ||
                            target.type === 'wall' ||
                            target.type === 'tech'
                        )) {
                            attacks.push({ x, y, target });
                        }
                    }
                });

                return attacks;
            }

            moveTowardsPlayer() {
                const targetX = CONFIG.PLAYER_START.x;
                const targetY = CONFIG.PLAYER_START.y;

                let dx = Math.sign(targetX - this.x);
                let dy = Math.sign(targetY - this.y);

                let newX = this.x + dx;
                let newY = this.y;

                if (newX < 0 || newX >= CONFIG.GRID_SIZE_X ||
                    (gameState.grid[newY][newX] !== null && gameState.grid[newY][newX] !== 'player')) {
                    newX = this.x;
                    newY = this.y + dy;

                    if (newY < 0 || newY >= CONFIG.GRID_SIZE_Y ||
                        (gameState.grid[newY][newX] !== null && gameState.grid[newY][newX] !== 'player')) {
                        newX = this.x + dx;
                    }
                }

                if (newX >= 0 && newX < CONFIG.GRID_SIZE_X && newY >= 0 && newY < CONFIG.GRID_SIZE_Y &&
                    (gameState.grid[newY][newX] === null || gameState.grid[newY][newX] === 'player')) {
                    gameState.grid[this.y][this.x] = null;
                    gameState.grid[newY][newX] = this;
                    this.x = newX;
                    this.y = newY;
                }
            }

            attackTarget(target) {
                if (target.type === 'army' || target.type === 'tech') {
                    const isDestroyed = target.takeDamage(1);
                    if (isDestroyed) {
                        gameState.grid[target.y][target.x] = null;
                        gameState.objects.delete(target.id);

                        if (gameState.selectedUnit && gameState.selectedUnit.id === target.id) {
                            clearSelection();
                        }
                    }
                } else if (target.type === 'wall') {
                    target.takeDamage(1);
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        const gameState = new GameState();

        function initGame() {
            createGrid();
            gameState.grid[CONFIG.PLAYER_START.y][CONFIG.PLAYER_START.x] = 'player';

            spawnEnemy(5, 5);
            spawnEnemy(10, 2);
            spawnEnemy(2, 10);

            updateDisplay();
            setupEventListeners();
        }

        function createGrid() {
            const gridElement = document.getElementById('game-grid');
            gridElement.innerHTML = '';

            for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('click', () => handleCellClick(x, y));
                    gridElement.appendChild(cell);
                }
            }
        }

        function handleCellClick(x, y) {
            const cell = gameState.grid[y][x];
            let actionTaken = false;

            if (gameState.placementMode) {
                if (cell === null) {
                    const [type, subtype] = parsePlacementMode(gameState.placementMode);
                    const placed = placeObject(x, y, type, subtype);
                    if (placed) {
                        actionTaken = true;
                    }
                }
                updateDisplay();
                if (actionTaken && !gameState.inWaveBreak) {
                    processEnemyTurn();
                }
                return;
            }

            if (cell && cell.type === 'army') {
                clearSelection();
                gameState.selectedUnit = cell;
                highlightValidMoves(cell);
                updateDisplay();
                return;
            }

            if (gameState.selectedUnit) {
                const { moves, attacks } = gameState.selectedUnit.getValidMoves();
                const isValidMove = moves.some(move => move.x === x && move.y === y);
                const isValidAttack = attacks.some(attack => attack.x === x && attack.y === y);

                if (isValidMove && cell === null) {
                    gameState.selectedUnit.moveTo(x, y);
                    actionTaken = true;
                } else if (isValidAttack && cell && cell.type === 'enemy') {
                    attackEnemy(cell);
                    actionTaken = true;
                } else {
                    clearSelection();
                }

                clearSelection();
                updateDisplay();
                if (actionTaken && !gameState.inWaveBreak) {
                    processEnemyTurn();
                }
            }
        }

        function parsePlacementMode(mode) {
            if (mode.includes('-')) {
                const parts = mode.split('-');
                return [parts[0], parts[1]];
            }
            return [mode, null];
        }

        function placeObject(x, y, type, subtype = null) {
            let obj;
            let cost;

            switch (type) {
                case 'wall':
                    obj = new Wall(x, y, subtype || 'stone');
                    cost = getWallCost(subtype);
                    break;
                case 'tech':
                    obj = new Tech(x, y, subtype || 'miner');
                    cost = obj.cost;
                    break;
                case 'army':
                    obj = new Army(x, y, subtype || 'scout');
                    cost = obj.cost;
                    break;
                default:
                    return false;
            }

            if (!gameState.canAfford(cost)) {
                showNotification('Not enough resources!', x, y, 'warning');
                return false;
            }

            gameState.spendResources(cost);
            gameState.grid[y][x] = obj;
            gameState.objects.set(obj.id, obj);

            if (type === 'tech') {
                obj.onTurn();
            }

            showNotification(`${subtype || type} placed!`, x, y, 'success');
            return true;
        }

        function getWallCost(subtype) {
            switch (subtype) {
                case 'steel': return { Steel: 20 };
                case 'spike': return { Steel: 15 };
                case 'fortress': return { gold: 25 };
                default: return { Steel: 10 };
            }
        }

        function spawnEnemy(x, y, subtype = null) {
            if (gameState.grid[y] && gameState.grid[y][x] === null) {
                if (!subtype) {
                    const enemyTypes = [
                        { type: 'basic', weight: 5 },
                        { type: 'fast', weight: 3 },
                        { type: 'tank', weight: 2 },
                        { type: 'ranged', weight: 3 },
                        { type: 'healer', weight: 2 }
                    ];

                    const totalWeight = enemyTypes.reduce((sum, type) => sum + type.weight, 0);
                    let random = Math.random() * totalWeight;

                    for (const enemyType of enemyTypes) {
                        random -= enemyType.weight;
                        if (random <= 0) {
                            subtype = enemyType.type;
                            break;
                        }
                    }
                }

                const enemy = new Enemy(x, y, subtype || 'basic');
                gameState.grid[y][x] = enemy;
                gameState.objects.set(enemy.id, enemy);
                gameState.enemiesRemaining++;
            }
        }

        function clearSelection() {
            gameState.selectedUnit = null;
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.classList.remove('selected', 'valid-move', 'valid-attack');
            });
        }

        function attackEnemy(enemy) {
            gameState.grid[enemy.y][enemy.x] = null;
            gameState.objects.delete(enemy.id);
            gameState.enemiesRemaining--;

            gameState.addResources({ coins: 5 });
        }

        function gameOver() {
            showNotification('Game Over! The enemies have reached your base!', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'danger');
            setTimeout(() => {
                if (confirm('Game Over! Would you like to restart?')) {
                    restartGame();
                }
            }, 1000);
        }

        function highlightValidMoves(unit) {
            const { moves, attacks } = unit.getValidMoves();

            moves.forEach(move => {
                const cell = document.querySelector(`[data-x="${move.x}"][data-y="${move.y}"]`);
                if (cell) {
                    cell.classList.add('valid-move');
                }
            });

            attacks.forEach(attack => {
                const cell = document.querySelector(`[data-x="${attack.x}"][data-y="${attack.y}"]`);
                if (cell) {
                    cell.classList.add('valid-attack');
                }
            });

            const unitCell = document.querySelector(`[data-x="${unit.x}"][data-y="${unit.y}"]`);
            if (unitCell) {
                unitCell.classList.add('selected');
            }
        }

        function spawnNextWave() {
            gameState.wave++;
            gameState.inWaveBreak = false;

            let numEnemies = 3 + gameState.wave * 2;

            const emptyCells = [];
            for (let y = 0; y < CONFIG.GRID_SIZE; y++) {
                for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
                    if (gameState.grid[y][x] === null && !(x === CONFIG.PLAYER_START.x && y === CONFIG.PLAYER_START.y)) {
                        emptyCells.push({ x, y });
                    }
                }
            }

            for (let i = emptyCells.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [emptyCells[i], emptyCells[j]] = [emptyCells[j], emptyCells[i]];
            }

            const enemiesToSpawn = Math.min(numEnemies, emptyCells.length);
            for (let i = 0; i < enemiesToSpawn; i++) {
                const { x, y } = emptyCells[i];
                spawnEnemy(x, y);
            }

            showNotification(`Wave ${gameState.wave} incoming!`, CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'warning');
            updateDisplay();
        }

        function processEnemyTurn() {
            gameState.objects.forEach(obj => {
                if (obj.type === 'army' && obj.onTurn) {
                    obj.onTurn();
                }
            });

            gameState.objects.forEach(obj => {
                if (obj.type === 'tech' && obj.onTurn) {
                    obj.onTurn();
                }
            });

            const enemies = [];
            gameState.objects.forEach(obj => {
                if (obj.type === 'enemy') {
                    enemies.push(obj);
                }
            });

            enemies.forEach(enemy => {
                enemy.onTurn();
            });

            gameState.turn++;
            gameState.countEnemies();

            if (gameState.enemiesRemaining === 0 && !gameState.inWaveBreak) {
                gameState.inWaveBreak = true;
                gameState.waveBreakTurns = CONFIG.WAVE_BREAK_TURNS;
                showNotification(`Wave ${gameState.wave} complete! Prepare for the next wave.`, CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
            }

            if (gameState.inWaveBreak) {
                gameState.waveBreakTurns--;
                if (gameState.waveBreakTurns <= 0) {
                    spawnNextWave();
                }
            }

            updateDisplay();
        }

        function updateDisplay() {
            document.getElementById('steel-count').textContent = gameState.resources.Steel;
            document.getElementById('coin-count').textContent = gameState.resources.coins;
            document.getElementById('gold-count').textContent = gameState.resources.gold;

            document.getElementById('turn-count').textContent = gameState.turn;
            document.getElementById('wave-count').textContent = gameState.wave;
            document.getElementById('enemies-remaining').textContent = gameState.enemiesRemaining;

            const instructions = document.getElementById('turn-instructions');
            if (gameState.inWaveBreak) {
                instructions.textContent = `Wave break: ${gameState.waveBreakTurns} turns until next wave`;
            } else if (gameState.placementMode) {
                instructions.textContent = 'Click on an empty cell to place the selected object';
            } else if (gameState.selectedUnit) {
                instructions.textContent = 'Click on a highlighted cell to move or attack';
            } else {
                instructions.textContent = 'Click an army unit to select it, then click a highlighted square to move';
            }

            document.querySelectorAll('.grid-cell').forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const obj = gameState.grid[y][x];

                cell.className = 'grid-cell';
                cell.innerHTML = '';

                if (obj === 'player') {
                    const sprite = document.createElement('div');
                    sprite.className = 'object-sprite';
                    const img = document.createElement('img');
                    img.src = CONFIG.SPRITES.player;
                    img.alt = 'player';
                    sprite.appendChild(img);
                    cell.appendChild(sprite);
                } else if (obj && obj.type) {
                    const sprite = document.createElement('div');
                    sprite.className = 'object-sprite';
                    const img = document.createElement('img');
                    img.src = obj.getSprite();
                    img.alt = obj.subtype;
                    sprite.appendChild(img);

                    if (obj.health < obj.maxHealth) {
                        const healthBar = document.createElement('div');
                        healthBar.className = 'health-bar';
                        const healthFill = document.createElement('div');
                        healthFill.className = 'health-fill';
                        healthFill.style.width = `${(obj.health / obj.maxHealth) * 100}%`;
                        healthBar.appendChild(healthFill);
                        cell.appendChild(healthBar);
                    }

                    cell.appendChild(sprite);
                }

                if (gameState.selectedUnit &&
                    gameState.selectedUnit.x === x &&
                    gameState.selectedUnit.y === y) {
                    cell.classList.add('selected');
                }
            });

            if (gameState.selectedUnit) {
                highlightValidMoves(gameState.selectedUnit);
            }

            updateButtonStates();
        }

        function updateButtonStates() {
            document.querySelectorAll('.btn').forEach(btn => btn.classList.remove('active'));

            if (gameState.placementMode) {
                const activeButton = document.querySelector(`[data-mode="${gameState.placementMode}"]`);
                if (activeButton) {
                    activeButton.classList.add('active');
                }
            }

            document.querySelectorAll('.btn[data-cost]').forEach(btn => {
                const cost = JSON.parse(btn.dataset.cost);
                if (gameState.canAfford(cost)) {
                    btn.classList.remove('disabled');
                } else {
                    btn.classList.add('disabled');
                }
            });
        }

        function showNotification(message, x, y, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        const BUTTONS = [
            { id: 'place-wall', mode: 'wall', cost: { Steel: 10 } },
            { id: 'place-steel-wall', mode: 'wall-steel', cost: { Steel: 20 } },
            { id: 'place-spike', mode: 'wall-spike', cost: { Steel: 15 } },
            { id: 'place-fortress', mode: 'wall-fortress', cost: { gold: 25 } },
            { id: 'place-tech', mode: 'tech', cost: { Steel: 20 } },
            { id: 'place-gold-miner', mode: 'tech-goldminer', cost: { Steel: 25 } },
            { id: 'place-coin-maker', mode: 'tech-coinmaker', cost: { Steel: 30 } },
            { id: 'place-turret', mode: 'tech-turret', cost: { Steel: 40 } },
            { id: 'place-bomb', mode: 'tech-bomb', cost: { gold: 10 } },
            { id: 'place-supply', mode: 'tech-supply', cost: { gold: 35 } },
            { id: 'place-campfire', mode: 'tech-campfire', cost: { Steel: 30 } },
            { id: 'place-scout', mode: 'army-scout', cost: { coins: 15 } },
            { id: 'place-knight', mode: 'army-knight', cost: { coins: 25 } },
            { id: 'place-archer', mode: 'army-archer', cost: { coins: 20 } },
            { id: 'place-tank', mode: 'army-tank', cost: { coins: 50 } },
            { id: 'place-siege-tower', mode: 'army-siegetower', cost: { coins: 275 } },
            { id: 'place-king', mode: 'army-king', cost: { gold: 500 } },
            { id: 'place-barrack', mode: 'army-barrack', cost: { gold: 50 } }
        ];

        function setupEventListeners() {
            document.querySelectorAll('[data-folder] .folder-title').forEach(title => {
                title.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const folder = title.closest('.folder');
                    folder.classList.toggle('open');
                });
            });

            document.addEventListener('click', () => {
                document.querySelectorAll('.folder.open').forEach(folder => {
                    folder.classList.remove('open');
                });
            });

            BUTTONS.forEach(({ id, mode, cost }) => {
                const button = document.getElementById(id);
                if (button) {
                    button.dataset.mode = mode;
                    button.dataset.cost = JSON.stringify(cost);
                    button.addEventListener('click', (e) => {
                        e.stopPropagation();
                        gameState.placementMode = gameState.placementMode === mode ? null : mode;
                        updateButtonStates();
                        updateDisplay();
                    });
                }
            });

            document.getElementById('clear-selection').addEventListener('click', (e) => {
                e.stopPropagation();
                gameState.placementMode = null;
                clearSelection();
                updateButtonStates();
                updateDisplay();
            });

            document.getElementById('save-game').addEventListener('click', saveGame);
            document.getElementById('load-game').addEventListener('click', () => {
                document.getElementById('load-file').click();
            });
            document.getElementById('restart-game').addEventListener('click', restartGame);

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.id = 'load-file';
            fileInput.accept = '.coregrid';
            fileInput.style.display = 'none';
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    loadGame(e.target.files[0]);
                }
            });
            document.body.appendChild(fileInput);
        }

        function restartGame() {
            if (confirm('Are you sure you want to restart the game?')) {
                gameState.reset();
                initGame();
            }
        }

        function saveGame() {
            const gameData = {
                resources: gameState.resources,
                turn: gameState.turn,
                wave: gameState.wave,
                waveBreakTurns: gameState.waveBreakTurns,
                inWaveBreak: gameState.inWaveBreak,
                enemiesRemaining: gameState.enemiesRemaining,
                grid: serializeGrid()
            };

            const blob = new Blob([JSON.stringify(gameData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `coregrid_save_${new Date().toISOString().slice(0, 10)}.coregrid`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('Game saved successfully!', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
        }

        function loadGame(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const gameData = JSON.parse(e.target.result);

                    if (!gameData.resources || !gameData.grid) {
                        throw new Error('Invalid save file');
                    }

                    gameState.resources = gameData.resources;
                    gameState.turn = gameData.turn;
                    gameState.wave = gameData.wave;
                    gameState.waveBreakTurns = gameData.waveBreakTurns || 0;
                    gameState.inWaveBreak = gameData.inWaveBreak || false;
                    gameState.enemiesRemaining = gameData.enemiesRemaining || 0;

                    deserializeGrid(gameData.grid);

                    showNotification('Game loaded successfully!', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
                    updateDisplay();
                } catch (error) {
                    showNotification('Error loading game: Invalid save file', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'danger');
                    console.error('Error loading game:', error);
                }
            };
            reader.readAsText(file);
        }

        function serializeGrid() {
            const gridData = [];
            for (let y = 0; y < CONFIG.GRID_SIZE; y++) {
                const row = [];
                for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
                    const obj = gameState.grid[y][x];
                    if (obj === 'player') {
                        row.push('player');
                    } else if (obj && obj.type) {
                        row.push({
                            type: obj.type,
                            subtype: obj.subtype,
                            health: obj.health,
                            maxHealth: obj.maxHealth,
                            ...(obj.type === 'tech' && obj.subtype === 'turret' ? { shotsLeft: obj.shotsLeft } : {}),
                            ...(obj.type === 'army' && obj.subtype === 'barrack' ? { spawnCounter: obj.spawnCounter } : {})
                        });
                    } else {
                        row.push(null);
                    }
                }
                gridData.push(row);
            }
            return gridData;
        }

        function deserializeGrid(gridData) {
            gameState.grid = Array(CONFIG.GRID_SIZE).fill().map(() => Array(CONFIG.GRID_SIZE).fill(null));
            gameState.objects.clear();

            for (let y = 0; y < CONFIG.GRID_SIZE; y++) {
                for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
                    const objData = gridData[y][x];
                    if (objData === 'player') {
                        gameState.grid[y][x] = 'player';
                    } else if (objData && objData.type) {
                        let obj;
                        switch (objData.type) {
                            case 'wall':
                                obj = new Wall(x, y, objData.subtype);
                                break;
                            case 'tech':
                                obj = new Tech(x, y, objData.subtype);
                                break;
                            case 'army':
                                obj = new Army(x, y, objData.subtype);
                                break;
                            case 'enemy':
                                obj = new Enemy(x, y, objData.subtype);
                                break;
                            default:
                                continue;
                        }

                        obj.health = objData.health;
                        obj.maxHealth = objData.maxHealth;

                        if (objData.type === 'tech' && objData.subtype === 'turret' && objData.shotsLeft) {
                            obj.shotsLeft = objData.shotsLeft;
                        }

                        if (objData.type === 'army' && objData.subtype === 'barrack' && objData.spawnCounter) {
                            obj.spawnCounter = objData.spawnCounter;
                        }

                        gameState.grid[y][x] = obj;
                        gameState.objects.set(obj.id, obj);
                    }
                }
            }
        }

        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>

</html>