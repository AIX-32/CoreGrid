<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CoreGrid - Strategy Defense Game</title>
    <link rel="icon" href="./sprites/tower.png">
    <meta name="description"
        content="CoreGrid - a strategy game where you build and defend your base against waves of enemies">
    <meta name="keywords" content="grid, game, management, resource, online game, strategy game">
    <meta name="author" content="A_I_X">
    <meta name="theme-color" content="#121212">

    <style>
        :root {
            --bg-primary: #2b2b2b;
            --bg-secondary: #3a3a3a;
            --bg-tertiary: #404040;
            --border-color: #555;
            --text-primary: #e0e0e0;
            --text-secondary: #c0c0c0;
            --accent-primary: #66d9ff;
            --accent-secondary: #99ecff;
            --danger: #dd7e77;
            --success: #7a977b;
            --warning: #ceab77;
            --cell-size: 42px;
            --grid-gap: 6px;
            --border-radius: 4px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', sans-serif;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            padding: 30px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            max-width: 900px;
            width: 100%;
            text-align: center;
        }

        .game-header {
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--accent-primary);
            text-align: center;
            border-bottom: 4px solid var(--border-color);
            padding-bottom: 10px;
            letter-spacing: 1px;
        }

        .game-subtitle {
            color: var(--text-secondary);
            margin-bottom: 20px;
            text-align: center;
        }

        .ui-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding: 20px;
            background: #353535;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            box-shadow: 0 6px 0 rgba(0, 0, 0, 0.2);
        }

        .resources {
            display: flex;
            gap: 20px;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: var(--text-primary);
            padding: 10px 15px;
            background: #353535;
            border-radius: var(--border-radius);
            border: 2px solid #7a7a7a;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .resource img {
            width: 24px;
            height: 24px;
        }

        .controls-folder {
            display: flex;
            gap: 15px;
        }

        .folder {
            background: var(--bg-tertiary);
            border-radius: var(--border-radius);
            border: 3px solid #7a7a7a;
            min-width: 100px;
            position: relative;
            z-index: 100;
            transition: all 0.2s ease;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
            display: inline-block;
        }

        .folder-title {
            padding: 10px 12px;
            background: #353535;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #ddd;
            border-radius: var(--border-radius);
            border: 3px solid #7a7a7a;
            display: flex;
            align-items: center;
            gap: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: inset 0 -3px 0 rgba(0, 0, 0, 0.2);
            font-size: 12px;
            user-select: none;
        }

        .folder-title img {
            width: 24px;
            height: 24px;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
        }

        .folder-content {
            display: none;
            flex-direction: column;
            gap: 8px;
            padding: 0;
            position: fixed;
            background: var(--bg-tertiary);
            border-radius: var(--border-radius);
            border: 3px solid #7a7a7a;
            width: 200px;
            z-index: 1000;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
            min-width: 140px;
        }

        .folder-header {
            padding: 8px 12px;
            background: #3a3a3a;
            font-weight: bold;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid #7a7a7a;
            user-select: none;
        }

        .folder-header-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .folder-close {
            background: none;
            border: none;
            color: #ddd;
            cursor: pointer;
            font-size: 16px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }

        .folder-close:hover {
            background: #ff5555;
        }

        .folder-content.draggable {
            position: fixed;
        }

        .folder-buttons {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .folder.open .folder-content {
            display: block;
            animation: dropdownFade 0.2s ease;
        }

        @keyframes dropdownFade {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .folder-content .btn {
            width: 100%;
            height: auto;
            min-height: 50px;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            background-color: #353535;
            color: #ddd;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            font-size: 11px;
            text-align: left;
            padding: 6px 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .folder-content .btn:hover {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
            transform: translateX(5px);
        }

        .folder-content .btn img {
            width: 20px;
            height: 20px;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
            margin: 0;
            max-width: 20px;
            max-height: 20px;
        }

        .btn-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-right {
            display: flex;
            align-items: center;
        }

        .btn-left img {
            width: 20px;
            height: 20px;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .btn-left span {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .btn-right .lowcol {
            font-weight: bold;
            color: #aaa;
        }


        .btn {
            width: 100px;
            height: 80px;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            background-color: #353535;
            color: #ddd;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            font-size: 11px;
            text-align: center;
            padding: 5px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .info-icon {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 16px;
            height: 16px;
            background-color: #444;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: #ddd;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
            border: 1px solid #7a7a7a;
        }

        .btn:hover .info-icon {
            opacity: 1;
        }

        .info-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            padding: 15px;
            width: auto;
            min-width: 250px;
            max-width: 350px;
            z-index: 2000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
            font-size: 12px;
        }

        .info-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #555;
        }

        .info-popup-title {
            font-weight: bold;
            font-size: 14px;
            text-transform: uppercase;
        }

        .info-popup-close {
            background: none;
            border: none;
            color: #ddd;
            cursor: pointer;
            font-size: 18px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }

        .info-popup-close:hover {
            background: #ff5555;
        }

        .info-popup-content {
            font-size: 12px;
            line-height: 1.5;
        }

        .info-popup-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin: 10px 0;
        }

        .info-popup-stat {
            background: #444;
            padding: 5px 8px;
            border-radius: 3px;
            font-size: 11px;
            white-space: nowrap;
        }

        .info-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1999;
            display: none;
        }

        .btn:hover {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
            transform: translateY(-2px);
        }

        .btn img {
            width: 16px;
            height: 16px;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
            margin: 0 auto;
            max-width: 16px;
            max-height: 16px;
        }

        .btn.active {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
        }

        .btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn.disabled:hover {
            transform: none;
            background: var(--bg-tertiary);
        }

        .game-grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(25, 1fr);
            grid-template-rows: repeat(15, 1fr);
            gap: var(--grid-gap);
            background: #353535;
            border: 2px solid #7a7a7a;
            padding: 15px;
            border-radius: var(--border-radius);
            justify-content: center;
            align-content: center;
            min-height: 650px;
            aspect-ratio: 25 / 15;
            box-shadow: 0 6px 0 rgba(0, 0, 0, 0.2);
        }

        .grid-cell {
            background: #2f811b;
            border: 3px solid #398d24;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #ccc;
            border-radius: var(--border-radius);
            aspect-ratio: 1 / 1;
        }

        .grid-cell:hover {
            background: #3ea326;
            border: 3px solid #4cb72f;
            transform: translateY(-2px);
            border-radius: var(--border-radius);
            z-index: 2;
        }

        .grid-cell.selected {
            box-shadow: 0 0 8px var(--accent-secondary);
            border-color: var(--accent-secondary);
            background: rgba(255, 215, 0, 0.2);
        }

        .grid-cell.valid-move {
            background: rgba(76, 175, 80, 0.3);
            border-color: var(--accent-primary);
            cursor: pointer;
        }

        .grid-cell.valid-attack {
            background: rgba(244, 67, 54, 0.3);
            border-color: var(--danger);
            cursor: crosshair;
        }

        .grid-cell.valid-attack:hover {
            background: rgba(244, 67, 54, 0.5);
        }

        .grid-cell .object-sprite {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            border-radius: 2px;
        }

        .grid-cell .object-sprite img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            display: block;
        }

        .game-info {
            display: flex;
            gap: 25px;
            margin-bottom: 25px;
        }

        .turn-info,
        .wave-info {
            padding: 20px;
            background: #353535;
            border-radius: var(--border-radius);
            border: 2px solid #7a7a7a;
            text-align: center;
            color: var(--text-primary);
            flex: 1;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .info-panel {
            padding: 20px;
            background: #353535;
            border-radius: var(--border-radius);
            border: 2px solid #7a7a7a;
            text-align: left;
            color: var(--text-primary);
            margin-bottom: 25px;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .info-panel h3 {
            margin-bottom: 10px;
            color: var(--accent-primary);
            border-left: 5px solid var(--accent-primary);
            padding-left: 10px;
        }

        .info-panel p {
            color: var(--text-secondary);
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .floating-sidebar {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
            background: #353535;
            border-radius: var(--border-radius);
            border: 2px solid #7a7a7a;
            z-index: 1000;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        .control-btn {
            padding: 12px 20px;
            border: 2px solid #7a7a7a;
            background-color: #353535;
            color: #ddd;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .control-btn:hover {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
            transform: translateY(-2px);
        }

        .control-btn.primary {
            background-color: var(--accent-primary);
            color: #111;
            border-color: var(--accent-secondary);
        }

        .control-btn.warning {
            background: var(--warning);
            color: white;
            border-color: #7a7a7a;
        }

        .health-bar {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            height: 3px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            border: 1px solid #555;
        }

        .health-fill {
            height: 100%;
            background: var(--success);
            transition: width 0.3s ease;
        }

        .notification {
            padding: 15px 20px;
            background: #353535;
            color: var(--text-primary);
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            animation: slideIn 0.3s ease;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
            width: 300px;
            margin-bottom: 10px;
        }

        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }


        .lowcol {
            color: #858585;
        }

        /* Card styles from design.html */
        .card {
            background: #353535;
            border: 2px solid #7a7a7a;
            border-radius: var(--border-radius);
            padding: 25px;
            margin-bottom: 25px;
            transition: transform 0.15s ease, border-color 0.2s ease;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .card:hover {
            transform: scale(1.01);
            border-color: var(--accent-primary);
        }

        .card h2 {
            margin-bottom: 10px;
            color: #e8e8e8;
            font-size: 1.4rem;
        }

        .card p {
            color: var(--text-secondary);
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .text-section h2 {
            color: #eee;
            border-left: 5px solid var(--accent-primary);
            padding-left: 10px;
            margin-bottom: 15px;
        }

        .highlight {
            background-color: #353535;
            border: 2px solid #7a7a7a;
            padding: 20px;
            color: #ddd;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 25px 0;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 4px;
            padding: 8px;
            position: absolute;
            z-index: 1001;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 11px;
            line-height: 1.4;
            border: 1px solid #7a7a7a;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 0; /* Changed from 50% to 0 for cubes */
            pointer-events: none;
            opacity: 0;
        }

        .particle-effect {
            position: absolute;
            pointer-events: none;
            z-index: 999;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .folder-buttons .btn {
            position: relative;
        }
    </style>
</head>

<body>
    <div class="game-container">
        <!-- Game title and subtitle moved to sidebar -->

        <div class="ui-panel">
            <div class="resources">
                <div class="resource">
                    <img src="./sprites/ironin.png" alt="Steel">
                    <span id="steel-count">100</span> Steel
                </div>
                <div class="resource">
                    <img src="./sprites/coin.png" alt="Coins">
                    <span id="coin-count">50</span> Coins
                </div>
                <div class="resource">
                    <img src="./sprites/goldin.png" alt="Gold">
                    <span id="gold-count">25</span> Gold
                </div>
            </div>

            <div class="controls-folder">
                <div class="folder" data-folder>
                    <div class="folder-title">
                        <img src="./sprites/wall.png" alt="Walls"> Walls
                    </div>
                    <div class="folder-content">
                        <div class="folder-header">
                            <div class="folder-header-title">Walls</div>
                            <button class="folder-close">×</button>
                        </div>
                        <div class="folder-buttons">
                            <button class="btn" id="place-wall" data-info="Wall,Basic defensive structure to block enemy movement,Health: 1">
                                <div class="btn-left">
                                    <img src="./sprites/wall.png" alt="Wall">
                                    <span>Wall</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">10S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-steel-wall" data-info="Steel Wall,Stronger wall with increased durability,Health: 3">
                                <div class="btn-left">
                                    <img src="./sprites/wallsteel.png" alt="Steel Wall">
                                    <span>Steel</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">20S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-spike" data-info="Spike,Damages enemies that walk over it,Health: 3">
                                <div class="btn-left">
                                    <img src="./sprites/spike.png" alt="Spike">
                                    <span>Spike</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">15S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-fortress" data-info="Fortress,Your main base that must be protected,Health: 5">
                                <div class="btn-left">
                                    <img src="./sprites/spawn.png" alt="Fortress">
                                    <span>Fortress</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">25G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                        </div>
                    </div>
                </div>

                <div class="folder" data-folder>
                    <div class="folder-title">
                        <img src="./sprites/turret.png" alt="Tech"> Tech
                    </div>
                    <div class="folder-content">
                        <div class="folder-header">
                            <div class="folder-header-title">Tech</div>
                            <button class="folder-close">×</button>
                        </div>
                        <div class="folder-buttons">
                            <button class="btn" id="place-tech" data-info="Steel Mine,Generates 5 steel per turn,Health: 2">
                                <div class="btn-left">
                                    <img src="./sprites/iron.png" alt="Steel Mine">
                                    <span>Steel Mine</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">20S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-gold-miner" data-info="Gold Mine,Generates 1 gold per turn,Health: 2">
                                <div class="btn-left">
                                    <img src="./sprites/gold.png" alt="Gold Mine">
                                    <span>Gold Mine</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">25S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-coin-maker" data-info="Bank,Generates 5 coins per turn,Health: 2">
                                <div class="btn-left">
                                    <img src="./sprites/bank.png" alt="Bank">
                                    <span>Bank</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">30S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-turret" data-info="Turret,Attacks enemies within range 3,Health: 2,Shots: 8">
                                <div class="btn-left">
                                    <img src="./sprites/turret.png" alt="Turret">
                                    <span>Turret</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">40S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-gold-turret" data-info="Gold Turret,Powerful turret with range 3,Health: 2,Shots: 10">
                                <div class="btn-left">
                                    <img src="./sprites/goldturret.png" alt="Gold Turret">
                                    <span>Gold Turret</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">200G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-bomb" data-info="Bomb,Explodes when enemy approaches damaging area,Health: 1">
                                <div class="btn-left">
                                    <img src="./sprites/bomb.png" alt="Bomb">
                                    <span>Bomb</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">10G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-supply" data-info="Supply Drop,Randomly generates resources,Health: 1">
                                <div class="btn-left">
                                    <img src="./sprites/supply.gif" alt="Supply Drop">
                                    <span>Supply Drop</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">35G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-campfire" data-info="Campfire,Boosts nearby resource buildings by 50%,Health: 1">
                                <div class="btn-left">
                                    <img src="./sprites/campfire.gif" alt="Campfire">
                                    <span>Campfire</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">30S</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                        </div>
                    </div>
                </div>

                <div class="folder" data-folder>
                    <div class="folder-title">
                        <img src="./sprites/Tank.png" alt="Army"> Army
                    </div>
                    <div class="folder-content">
                        <div class="folder-header">
                            <div class="folder-header-title">Army</div>
                            <button class="folder-close">×</button>
                        </div>
                        <div class="folder-buttons">
                            <button class="btn" id="place-scout" data-info="Soldier,Basic unit with balanced stats,Health: 1,Range: 1,Movement: 1">
                                <div class="btn-left">
                                    <img src="./sprites/soldier.png" alt="Soldier">
                                    <span>Soldier</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">15C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-knight" data-info="Knight,Fast-moving unit with high mobility,Health: 1,Range: 1,Movement: 5">
                                <div class="btn-left">
                                    <img src="./sprites/knight.png" alt="Knight">
                                    <span>Knight</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">25C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-archer" data-info="Archer,Ranged unit that can attack from a distance,Health: 1,Range: 4,Movement: 1">
                                <div class="btn-left">
                                    <img src="./sprites/Archer.png" alt="Archer">
                                    <span>Archer</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">20C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-tank" data-info="Tank,Heavy unit with high health,Health: 5,Range: 1,Movement: 1">
                                <div class="btn-left">
                                    <img src="./sprites/Tank.png" alt="Tank">
                                    <span>Tank</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">50C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-siege-tower" data-info="Siege Tower,Powerful siege unit with long range,Health: 1,Range: 4,Movement: 1">
                                <div class="btn-left">
                                    <img src="./sprites/siegetower.png" alt="Siege Tower">
                                    <span>Siege Tower</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">275C</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-king" data-info="King,Command unit that boosts nearby army,Health: 25,Range: 2,Movement: 2">
                                <div class="btn-left">
                                    <img src="./sprites/king.png" alt="King">
                                    <span>King</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">500G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                            <button class="btn" id="place-barrack" data-info="Barrack,Automatically spawns soldier units,Health: 2">
                                <div class="btn-left">
                                    <img src="./sprites/barrack.png" alt="Barrack">
                                    <span>Barrack</span>
                                </div>
                                <div class="btn-right">
                                    <span class="lowcol">50G</span>
                                </div>
                                <div class="info-icon">i</div>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="game-grid-container">
            <div class="game-grid" id="game-grid"></div>
        </div>

        <div class="game-info">
            <div class="turn-info">
                <h3>Information</h3>
                <p>Turn: <span id="turn-count">1</span></p>
                <p id="turn-instructions"></p>
            </div>
            <div class="wave-info">
                <h3>Wave Information</h3>
                <p>Wave: <span id="wave-count">1</span></p>
                <p id="wave-status">Enemies remaining: <span id="enemies-remaining">3</span></p>
            </div>
        </div>

        <div class="info-panel">
            <h3>Game Instructions</h3>
            <p><strong>Combat:</strong> Move your army units into enemy squares to attack! Different units have
                different movement ranges and attacks.</p>
            <p><strong>Defense:</strong> Use walls and fortresses to protect your units and resources.</p>
            <p><strong>Resources:</strong> Place miner buildings to generate resources.</p>
            <p><strong>Waves:</strong> Defend against waves of different enemies.</p>
        </div>

        <div class="floating-sidebar">
            <h1 class="game-title">CoreGrid</h1>
            <p class="game-subtitle">Build, Defend, and Conquer</p>
            <button class="control-btn" id="save-game">Save Game</button>
            <button class="control-btn" id="load-game">Load Game</button>
            <button class="control-btn" id="restart-game">Restart Game</button>
        </div>
    </div>

    <script>
        const CONFIG = {
            GRID_SIZE_X: 25,
            GRID_SIZE_Y: 15,
            PLAYER_START: { x: 12, y: 7 },
            WAVE_BREAK_TURNS: 3,
            INITIAL_RESOURCES: {
                Steel: 100,
                coins: 50,
                gold: 25
            },
            SPRITES: {
                player: './sprites/spawn.png',
                wall: {
                    stone: './sprites/wall.png',
                    steel: './sprites/wallsteel.png',
                    spike: './sprites/spike.png',
                    fortress: './sprites/spawn.png'
                },
                tech: {
                    miner: './sprites/iron.png',
                    goldminer: './sprites/gold.png',
                    coinmaker: './sprites/bank.png',
                    turret: './sprites/turret.png',
                    goldturret: './sprites/goldturret.png',
                    bomb: './sprites/bomb.png',
                    supply: './sprites/supply.gif',
                    campfire: './sprites/campfire.gif'
                },
                army: {
                    scout: './sprites/soldier.png',
                    knight: './sprites/knight.png',
                    archer: './sprites/Archer.png',
                    tank: './sprites/Tank.png',
                    king: './sprites/king.png',
                    barrack: './sprites/barrack.png',
                    siegetower: './sprites/siegetower.png'
                },
                enemy: {
                    basic: './sprites/defaultbad.png',
                    fast: './sprites/badfast.png',
                    tank: './sprites/badheavy.png',
                    ranged: './sprites/badarcher.png',
                    healer: './sprites/badhealer.png'
                }
            }
        };

        class GameState {
            constructor() {
                this.reset();
            }

            reset() {
                // Clear any wave break timeout when resetting the game
                if (window.waveBreakTimeout) {
                    clearTimeout(window.waveBreakTimeout);
                    window.waveBreakTimeout = null;
                }

                this.resources = { ...CONFIG.INITIAL_RESOURCES };
                this.turn = 1;
                this.selectedUnit = null;
                this.placementMode = null;
                this.grid = Array(CONFIG.GRID_SIZE_Y).fill().map(() => Array(CONFIG.GRID_SIZE_X).fill(null));
                this.objects = new Map();
                this.wave = 1;
                this.waveBreakTurns = 0;
                this.inWaveBreak = false;
                this.enemiesRemaining = 0;
            }

            canAfford(cost) {
                return this.resources.Steel >= (cost.Steel || 0) &&
                    this.resources.coins >= (cost.coins || 0) &&
                    this.resources.gold >= (cost.gold || 0);
            }

            spendResources(cost) {
                if (cost.Steel) this.resources.Steel -= cost.Steel;
                if (cost.coins) this.resources.coins -= cost.coins;
                if (cost.gold) this.resources.gold -= cost.gold;
            }

            addResources(resources) {
                if (resources.Steel) this.resources.Steel += resources.Steel;
                if (resources.coins) this.resources.coins += resources.coins;
                if (resources.gold) this.resources.gold += resources.gold;
            }

            countEnemies() {
                let count = 0;
                for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                    for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                        const obj = this.grid[y][x];
                        if (obj && obj.type === 'enemy') count++;
                    }
                }
                console.log(`countEnemies: calculated ${count}, previous value was ${this.enemiesRemaining}`);
                this.enemiesRemaining = count;
                return count;
            }
        }

        class GameObject {
            constructor(x, y, type, subtype) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.subtype = subtype;
                this.id = `${type}_${subtype}_${x}_${y}_${Date.now()}`;
            }

            getSprite() {
                return CONFIG.SPRITES[this.type]?.[this.subtype] || 'sprites/missing.png';
            }
        }

        class Wall extends GameObject {
            constructor(x, y, subtype = 'stone') {
                super(x, y, 'wall', subtype);
                this.health = this.getMaxHealth();
                this.maxHealth = this.health;
                this.blocksMovement = true;
            }

            getMaxHealth() {
                switch (this.subtype) {
                    case 'steel': return 3;
                    case 'spike': return 3;
                    case 'fortress': return 5;
                    default: return 1;
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        class Tech extends GameObject {
            constructor(x, y, subtype = 'miner') {
                super(x, y, 'tech', subtype);
                this.cost = this.getCost();
                this.health = 2;
                this.maxHealth = 2;

                if (subtype === 'turret') {
                    this.shotsLeft = 8;
                    this.range = 3;
                } else if (subtype === 'goldturret') {
                    this.shotsLeft = 10;
                    this.range = 3;
                }
            }

            getCost() {
                const costs = {
                    miner: { Steel: 20 },
                    goldminer: { Steel: 25 },
                    coinmaker: { Steel: 30 },
                    turret: { Steel: 40 },
                    goldturret: { gold: 200 },
                    bomb: { gold: 10 },
                    supply: { gold: 35 },
                    campfire: { Steel: 30 }
                };
                return costs[this.subtype] || { Steel: 20 };
            }

            onTurn() {
                const campfireBonus = 1 + (0.5 * this.getNearbyCampfires());

                switch (this.subtype) {
                    case 'miner':
                        gameState.addResources({ Steel: Math.floor(5 * campfireBonus) });
                        createResourceCollectionEffect(this.x, this.y, 'Steel'); // Add particle effect
                        break;
                    case 'goldminer':
                        gameState.addResources({ gold: Math.ceil(1 * campfireBonus) });
                        createResourceCollectionEffect(this.x, this.y, 'gold'); // Add particle effect
                        break;
                    case 'coinmaker':
                        gameState.addResources({ coins: Math.floor(5 * campfireBonus) });
                        createResourceCollectionEffect(this.x, this.y, 'coins'); // Add particle effect
                        break;
                    case 'supply':
                        this.handleSupplyDrop();
                        break;
                    case 'turret':
                    case 'goldturret':
                        this.attackNearbyEnemies();
                        break;
                    case 'bomb':
                        this.handleBomb();
                        break;
                }
            }

            getNearbyCampfires() {
                let count = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const x = this.x + dx;
                        const y = this.y + dy;
                        if (x >= 0 && x < CONFIG.GRID_SIZE_X && y >= 0 && y < CONFIG.GRID_SIZE_Y) {
                            const obj = gameState.grid[y][x];
                            if (obj && obj.type === 'tech' && obj.subtype === 'campfire') {
                                count++;
                            }
                        }
                    }
                }
                return count;
            }

            handleSupplyDrop() {
                if (Math.random() < 0.33) {
                    const resources = ['coins', 'Steel', 'gold'];
                    const resource = resources[Math.floor(Math.random() * resources.length)];
                    const amount = 5 + Math.floor(Math.random() * 6);
                    gameState.addResources({ [resource]: amount });
                    showNotification(`+${amount} ${resource} from Supply Drop!`, this.x, this.y);
                    createResourceCollectionEffect(this.x, this.y, resource); // Add particle effect
                }
            }

            attackNearbyEnemies() {
                if (this.shotsLeft <= 0) return false;

                for (let dy = -this.range; dy <= this.range; dy++) {
                    for (let dx = -this.range; dx <= this.range; dx++) {
                        if (Math.max(Math.abs(dx), Math.abs(dy)) > this.range) continue;
                        const x = this.x + dx;
                        const y = this.y + dy;
                        if (x >= 0 && x < CONFIG.GRID_SIZE_X && y >= 0 && y < CONFIG.GRID_SIZE_Y) {
                            const target = gameState.grid[y][x];
                            if (target && target.type === 'enemy') {
                                gameState.grid[y][x] = null;
                                gameState.objects.delete(target.id);
                                this.shotsLeft--;
                                if (this.shotsLeft <= 0) {
                                    gameState.grid[this.y][this.x] = null;
                                    gameState.objects.delete(this.id);
                                }
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            handleBomb() {
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const x = this.x + dx;
                        const y = this.y + dy;
                        if (x >= 0 && x < CONFIG.GRID_SIZE_X && y >= 0 && y < CONFIG.GRID_SIZE_Y) {
                            const target = gameState.grid[y][x];
                            if (target && target.type === 'enemy') {
                                for (let dy2 = -2; dy2 <= 2; dy2++) {
                                    for (let dx2 = -2; dx2 <= 2; dx2++) {
                                        const x2 = this.x + dx2;
                                        const y2 = this.y + dy2;
                                        if (x2 >= 0 && x2 < CONFIG.GRID_SIZE_X && y2 >= 0 && y2 < CONFIG.GRID_SIZE_Y) {
                                            const target2 = gameState.grid[y2][x2];
                                            if (target2 && target2.type === 'enemy') {
                                                gameState.grid[y2][x2] = null;
                                                gameState.objects.delete(target2.id);
                                            }
                                        }
                                    }
                                }
                                gameState.grid[this.y][this.x] = null;
                                gameState.objects.delete(this.id);
                                return;
                            }
                        }
                    }
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        class Army extends GameObject {
            constructor(x, y, subtype = 'scout') {
                super(x, y, 'army', subtype);
                this.cost = this.getCost();
                this.health = this.getMaxHealth();
                this.maxHealth = this.health;
                this.range = this.getRange();
                this.movement = this.getMovement();

                if (subtype === 'barrack') {
                    this.spawnCounter = 0;
                }
            }

            getCost() {
                const costs = {
                    scout: { coins: 15 },
                    knight: { coins: 25 },
                    archer: { coins: 20 },
                    tank: { coins: 50 },
                    siegetower: { coins: 275 },
                    king: { gold: 500 },
                    barrack: { gold: 50 }
                };
                return costs[this.subtype] || { coins: 15 };
            }

            getMaxHealth() {
                switch (this.subtype) {
                    case 'tank': return 5;
                    case 'king': return 25;
                    default: return 1;
                }
            }

            getRange() {
                switch (this.subtype) {
                    case 'archer':
                    case 'siegetower': return 4;
                    case 'king': return 2;
                    default: return 1;
                }
            }

            getMovement() {
                switch (this.subtype) {
                    case 'knight': return 5;
                    case 'archer': return 1;
                    case 'tank': return 1;
                    case 'king': return 2;
                    default: return 1;
                }
            }

            getValidMoves() {
                const moves = [];
                const attacks = [];

                const directions = this.subtype === 'knight' ?
                    [[-1, -1], [-1, 1], [1, -1], [1, 1]] :
                    [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];

                directions.forEach(([dx, dy]) => {
                    for (let i = 1; i <= this.movement; i++) {
                        const x = this.x + dx * i;
                        const y = this.y + dy * i;

                        if (x < 0 || x >= CONFIG.GRID_SIZE_X || y < 0 || y >= CONFIG.GRID_SIZE_Y) break;

                        const target = gameState.grid[y][x];
                        if (target === null) {
                            moves.push({ x, y });
                        } else if (target.type === 'enemy') {
                            attacks.push({ x, y });
                            break;
                        } else {
                            break;
                        }
                    }
                });

                if (this.subtype === 'archer' || this.subtype === 'siegetower') {
                    const allDirections = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];
                    allDirections.forEach(([dx, dy]) => {
                        for (let i = 1; i <= this.range; i++) {
                            const x = this.x + dx * i;
                            const y = this.y + dy * i;

                            if (x < 0 || x >= CONFIG.GRID_SIZE_X || y < 0 || y >= CONFIG.GRID_SIZE_Y) break;

                            const target = gameState.grid[y][x];
                            if (target && target.type === 'enemy') {
                                attacks.push({ x, y });
                            }
                        }
                    });
                }

                return { moves, attacks };
            }

            onTurn() {
                if (this.subtype === 'barrack') {
                    this.spawnCounter = (this.spawnCounter || 0) + 1;
                    if (this.spawnCounter >= 2) {
                        this.spawnCounter = 0;
                        const x = this.x - 1;
                        const y = this.y;
                        if (x >= 0 && gameState.grid[y][x] === null) {
                            const scout = new Army(x, y, 'scout');
                            gameState.grid[y][x] = scout;
                            gameState.objects.set(scout.id, scout);
                            showNotification('Barrack spawned a Soldier!', x, y);
                        }
                    }
                }
            }

            moveTo(x, y) {
                gameState.grid[this.y][this.x] = null;
                gameState.grid[y][x] = this;
                this.x = x;
                this.y = y;
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        class Enemy extends GameObject {
            constructor(x, y, subtype = 'basic') {
                super(x, y, 'enemy', subtype);
                this.health = this.getMaxHealth();
                this.maxHealth = this.health;
            }

            getMaxHealth() {
                switch (this.subtype) {
                    case 'tank': return 100;
                    case 'fast': return 30;
                    case 'ranged': return 40;
                    case 'healer': return 25;
                    default: return 50;
                }
            }

            onTurn() {
                if (this.x === CONFIG.PLAYER_START.x && this.y === CONFIG.PLAYER_START.y) {
                    gameOver();
                    return;
                }

                const attacks = this.getValidAttacks();
                if (attacks.length > 0) {
                    const target = attacks[0].target;
                    this.attackTarget(target);
                    return;
                }

                this.moveTowardsPlayer();
            }

            getValidAttacks() {
                const attacks = [];
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];

                directions.forEach(([dx, dy]) => {
                    const x = this.x + dx;
                    const y = this.y + dy;

                    if (x >= 0 && x < CONFIG.GRID_SIZE_X && y >= 0 && y < CONFIG.GRID_SIZE_Y) {
                        const target = gameState.grid[y][x];
                        if (target && (
                            (target.type === 'army' && target.owner === 'player') ||
                            target.type === 'wall' ||
                            target.type === 'tech'
                        )) {
                            attacks.push({ x, y, target });
                        }
                    }
                });

                return attacks;
            }

            moveTowardsPlayer() {
                const targetX = CONFIG.PLAYER_START.x;
                const targetY = CONFIG.PLAYER_START.y;

                let dx = Math.sign(targetX - this.x);
                let dy = Math.sign(targetY - this.y);

                let newX = this.x + dx;
                let newY = this.y;

                if (newX < 0 || newX >= CONFIG.GRID_SIZE_X ||
                    (gameState.grid[newY][newX] !== null && gameState.grid[newY][newX] !== 'player')) {
                    newX = this.x;
                    newY = this.y + dy;

                    if (newY <0 || newY >= CONFIG.GRID_SIZE_Y ||
                        (gameState.grid[newY][newX] !== null && gameState.grid[newY][newX] !== 'player')) {
                        newX = this.x + dx;
                    }
                }

                if (newX >= 0 && newX < CONFIG.GRID_SIZE_X && newY >= 0 && newY < CONFIG.GRID_SIZE_Y &&
                    (gameState.grid[newY][newX] === null || gameState.grid[newY][newX] === 'player')) {
                    gameState.grid[this.y][this.x] = null;
                    gameState.grid[newY][newX] = this;
                    this.x = newX;
                    this.y = newY;
                }
            }

            attackTarget(target) {
                if (target.type === 'army' || target.type === 'tech') {
                    const isDestroyed = target.takeDamage(1);
                    if (isDestroyed) {
                        gameState.grid[target.y][target.x] = null;
                        gameState.objects.delete(target.id);

                        if (gameState.selectedUnit && gameState.selectedUnit.id === target.id) {
                            clearSelection();
                        }
                    }
                } else if (target.type === 'wall') {
                    const isDestroyed = target.takeDamage(1);
                    if (isDestroyed) {
                        gameState.grid[target.y][target.x] = null;
                        gameState.objects.delete(target.id);
                    }
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                return this.health <= 0;
            }
        }

        const gameState = new GameState();

        function initGame() {
            // Clear any wave break timeout when initializing the game
            if (window.waveBreakTimeout) {
                clearTimeout(window.waveBreakTimeout);
                window.waveBreakTimeout = null;
            }

            createGrid();
            gameState.grid[CONFIG.PLAYER_START.y][CONFIG.PLAYER_START.x] = 'player';

            spawnEnemy(5, 5);
            spawnEnemy(10, 2);
            spawnEnemy(2, 10);

            console.log(`Initial enemies spawned, count: ${gameState.enemiesRemaining}`);
            gameState.countEnemies();
            console.log(`After countEnemies, enemies remaining: ${gameState.enemiesRemaining}`);
            updateDisplay();
            setupEventListeners();
        }

        function createGrid() {
            const gridElement = document.getElementById('game-grid');
            gridElement.innerHTML = '';

            for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('click', () => handleCellClick(x, y));
                    gridElement.appendChild(cell);
                }
            }
        }

        function handleCellClick(x, y) {
            const cell = gameState.grid[y][x];
            let actionTaken = false;

            if (gameState.placementMode) {
                if (cell === null) {
                    const [type, subtype] = parsePlacementMode(gameState.placementMode);
                    const placed = placeObject(x, y, type, subtype);
                    if (placed) {
                        actionTaken = true;
                    }
                }
                updateDisplay();
                if (actionTaken) {
                    processEnemyTurn();
                }
                return;
            }

            if (cell && cell.type === 'army') {
                clearSelection();
                gameState.selectedUnit = cell;
                highlightValidMoves(cell);
                updateDisplay();
                return;
            }

            if (gameState.selectedUnit) {
                const { moves, attacks } = gameState.selectedUnit.getValidMoves();
                const isValidMove = moves.some(move => move.x === x && move.y === y);
                const isValidAttack = attacks.some(attack => attack.x === x && attack.y === y);

                if (isValidMove && cell === null) {
                    gameState.selectedUnit.moveTo(x, y);
                    actionTaken = true;
                } else if (isValidAttack && cell && cell.type === 'enemy') {
                    attackEnemy(cell);
                    actionTaken = true;
                } else {
                    clearSelection();
                }

                clearSelection();
                updateDisplay();
                if (actionTaken) {
                    processEnemyTurn();
                }
            }
        }

        function parsePlacementMode(mode) {
            if (mode.includes('-')) {
                const parts = mode.split('-');
                return [parts[0], parts[1]];
            }
            return [mode, null];
        }

        function placeObject(x, y, type, subtype = null) {
            let obj;
            let cost;

            switch (type) {
                case 'wall':
                    obj = new Wall(x, y, subtype || 'stone');
                    cost = getWallCost(subtype);
                    break;
                case 'tech':
                    obj = new Tech(x, y, subtype || 'miner');
                    cost = obj.cost;
                    break;
                case 'army':
                    obj = new Army(x, y, subtype || 'scout');
                    cost = obj.cost;
                    break;
                default:
                    return false;
            }

            if (!gameState.canAfford(cost)) {
                showNotification('Not enough resources!', x, y, 'warning');
                return false;
            }

            gameState.spendResources(cost);
            gameState.grid[y][x] = obj;
            gameState.objects.set(obj.id, obj);

            if (type === 'tech') {
                obj.onTurn();
            }

            showNotification(`${subtype || type} placed!`, x, y, 'success');
            createPlacementEffect(x, y); // Add particle effect
            return true;
        }

        function getWallCost(subtype) {
            switch (subtype) {
                case 'steel': return { Steel: 20 };
                case 'spike': return { Steel: 15 };
                case 'fortress': return { gold: 25 };
                default: return { Steel: 10 };
            }
        }

        function spawnEnemy(x, y, subtype = null) {
            console.log(`spawnEnemy called with x=${x}, y=${y}`);
            if (gameState.grid[y] && gameState.grid[y][x] === null) {
                if (!subtype) {
                    const enemyTypes = [
                        { type: 'basic', weight: 5 },
                        { type: 'fast', weight: 3 },
                        { type: 'tank', weight: 2 },
                        { type: 'ranged', weight: 3 },
                        { type: 'healer', weight: 2 }
                    ];

                    const totalWeight = enemyTypes.reduce((sum, type) => sum + type.weight, 0);
                    let random = Math.random() * totalWeight;

                    for (const enemyType of enemyTypes) {
                        random -= enemyType.weight;
                        if (random <= 0) {
                            subtype = enemyType.type;
                            break;
                        }
                    }
                }

                const enemy = new Enemy(x, y, subtype || 'basic');
                gameState.grid[y][x] = enemy;
                gameState.objects.set(enemy.id, enemy);
                gameState.enemiesRemaining++; // ADD THIS LINE
                console.log(`Enemy spawned, enemies remaining: ${gameState.enemiesRemaining}`);
            } else {
                console.log(`Failed to spawn enemy at ${x},${y} - cell not empty or out of bounds`);
            }
        }

        function clearSelection() {
            gameState.selectedUnit = null;
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.classList.remove('selected', 'valid-move', 'valid-attack');
            });
        }

        function attackEnemy(enemy) {
            gameState.grid[enemy.y][enemy.x] = null;
            gameState.objects.delete(enemy.id);
            gameState.enemiesRemaining--; // ADD THIS LINE
            console.log(`Enemy attacked, enemies remaining: ${gameState.enemiesRemaining}`);

            gameState.addResources({ coins: 5 });
            createEnemyDefeatEffect(enemy.x, enemy.y); // Add particle effect
        }

        function gameOver() {
            showNotification('Game Over! The enemies have reached your base!', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'danger');
            setTimeout(() => {
                if (confirm('Game Over! Would you like to restart?')) {
                    restartGame();
                }
            }, 1000);
        }

        function highlightValidMoves(unit) {
            const { moves, attacks } = unit.getValidMoves();

            moves.forEach(move => {
                const cell = document.querySelector(`[data-x="${move.x}"][data-y="${move.y}"]`);
                if (cell) {
                    cell.classList.add('valid-move');
                }
            });

            attacks.forEach(attack => {
                const cell = document.querySelector(`[data-x="${attack.x}"][data-y="${attack.y}"]`);
                if (cell) {
                    cell.classList.add('valid-attack');
                }
            });

            const unitCell = document.querySelector(`[data-x="${unit.x}"][data-y="${unit.y}"]`);
            if (unitCell) {
                unitCell.classList.add('selected');
            }
        }

        function spawnNextWave() {
            console.log("spawnNextWave called");
            // Clear any wave break timeout when starting a new wave
            if (window.waveBreakTimeout) {
                clearTimeout(window.waveBreakTimeout);
                window.waveBreakTimeout = null;
            }
            gameState.wave++;
            console.log(`Wave incremented to ${gameState.wave}`);
            gameState.inWaveBreak = false;
            console.log("Wave break reset to false");

            let numEnemies = 3 + gameState.wave * 2;

            const emptyCells = [];
            for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                    // Skip player start position
                    if (x === CONFIG.PLAYER_START.x && y === CONFIG.PLAYER_START.y) continue;

                    // Only consider truly empty cells
                    if (gameState.grid[y][x] === null) {
                        emptyCells.push({ x, y });
                    }
                }
            }

            // Shuffle empty cells to get random positions
            for (let i = emptyCells.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [emptyCells[i], emptyCells[j]] = [emptyCells[j], emptyCells[i]];
            }

            const enemiesToSpawn = Math.min(numEnemies, emptyCells.length);

            // Debug logging
            console.log(`Spawning wave ${gameState.wave}: ${enemiesToSpawn} enemies`);

            for (let i = 0; i < enemiesToSpawn; i++) {
                const { x, y } = emptyCells[i];
                spawnEnemy(x, y);
            }

            gameState.countEnemies();
            showNotification(`Wave ${gameState.wave} incoming!`, CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'warning');
            updateDisplay();
        }

        function processEnemyTurn() {
            gameState.objects.forEach(obj => {
                if (obj.type === 'army' && obj.onTurn) {
                    obj.onTurn();
                }
            });

            gameState.objects.forEach(obj => {
                if (obj.type === 'tech' && obj.onTurn) {
                    obj.onTurn();
                }
            });

            const enemies = [];
            gameState.objects.forEach(obj => {
                if (obj.type === 'enemy') {
                    enemies.push(obj);
                }
            });

            enemies.forEach(enemy => {
                enemy.onTurn();
            });

            gameState.turn++;
            gameState.countEnemies();

            // Debug: Check if wave break should start
            console.log(`Enemies remaining: ${gameState.enemiesRemaining}, In wave break: ${gameState.inWaveBreak}`);

            if (gameState.enemiesRemaining === 0 && !gameState.inWaveBreak) {
                console.log("Condition met: enemiesRemaining is 0 and not in wave break");
                console.log("Starting wave break");
                gameState.inWaveBreak = true;
                gameState.waveBreakTurns = CONFIG.WAVE_BREAK_TURNS;
                showNotification(`Wave ${gameState.wave} complete! Prepare for the next wave.`, CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
            }

            if (gameState.inWaveBreak) {
                console.log(`Wave break turns remaining: ${gameState.waveBreakTurns}`);
                gameState.waveBreakTurns--;
                console.log(`Decremented wave break turns: ${gameState.waveBreakTurns}`);
                if (gameState.waveBreakTurns <= 0) {
                    console.log("Spawning next wave");
                    spawnNextWave();
                } else {

                    if (window.waveBreakTimeout) {
                        clearTimeout(window.waveBreakTimeout);
                    }
                    window.waveBreakTimeout = setTimeout(processEnemyTurn, 1000);
                }
            }

            updateDisplay();
        }

        function updateDisplay() {
            document.getElementById('steel-count').textContent = gameState.resources.Steel;
            document.getElementById('coin-count').textContent = gameState.resources.coins;
            document.getElementById('gold-count').textContent = gameState.resources.gold;

            document.getElementById('turn-count').textContent = gameState.turn;
            document.getElementById('wave-count').textContent = gameState.wave;
            document.getElementById('enemies-remaining').textContent = gameState.enemiesRemaining;

            const instructions = document.getElementById('turn-instructions');
            if (gameState.inWaveBreak) {
                instructions.textContent = `Wave break: ${gameState.waveBreakTurns} turns until next wave`;
            } else if (gameState.placementMode) {
                instructions.textContent = 'Click on an empty cell to place the selected object';
            } else if (gameState.selectedUnit) {
                instructions.textContent = 'Click on a highlighted cell to move or attack';
            } else {
                instructions.textContent = 'Click an army unit to select it, then click a highlighted square to move';
            }

            document.querySelectorAll('.grid-cell').forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const obj = gameState.grid[y][x];

                cell.className = 'grid-cell';
                cell.innerHTML = '';

                if (obj === 'player') {
                    const sprite = document.createElement('div');
                    sprite.className = 'object-sprite';
                    const img = document.createElement('img');
                    img.src = CONFIG.SPRITES.player;
                    img.alt = 'player';
                    sprite.appendChild(img);
                    cell.appendChild(sprite);
                } else if (obj && obj.type) {
                    const sprite = document.createElement('div');
                    sprite.className = 'object-sprite';
                    const img = document.createElement('img');
                    img.src = obj.getSprite();
                    img.alt = obj.subtype;
                    sprite.appendChild(img);

                    if (obj.health < obj.maxHealth) {
                        const healthBar = document.createElement('div');
                        healthBar.className = 'health-bar';
                        const healthFill = document.createElement('div');
                        healthFill.className = 'health-fill';
                        healthFill.style.width = `${(obj.health / obj.maxHealth) * 100}%`;
                        healthBar.appendChild(healthFill);
                        cell.appendChild(healthBar);
                    }

                    cell.appendChild(sprite);
                }

                if (gameState.selectedUnit &&
                    gameState.selectedUnit.x === x &&
                    gameState.selectedUnit.y === y) {
                    cell.classList.add('selected');
                }
            });

            if (gameState.selectedUnit) {
                highlightValidMoves(gameState.selectedUnit);
            }

            updateButtonStates();
        }

        function updateButtonStates() {
            document.querySelectorAll('.btn').forEach(btn => btn.classList.remove('active'));

            if (gameState.placementMode) {
                const activeButton = document.querySelector(`[data-mode="${gameState.placementMode}"]`);
                if (activeButton) {
                    activeButton.classList.add('active');
                }
            }

            document.querySelectorAll('.btn[data-cost]').forEach(btn => {
                const cost = JSON.parse(btn.dataset.cost);
                if (gameState.canAfford(cost)) {
                    btn.classList.remove('disabled');
                } else {
                    btn.classList.add('disabled');
                }
            });
        }

        function showNotification(message, x, y, type) {
            // Create notification container if it doesn't exist
            let container = document.querySelector('.notification-container');
            if (!container) {
                container = document.createElement('div');
                container.className = 'notification-container';
                document.body.appendChild(container);
            }

            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            
            // Add to the top of the container (so newest appears at top)
            container.insertBefore(notification, container.firstChild);
            
            // Remove notification after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.3s ease forwards';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // Particle effect system
        function createParticleEffect(x, y, color, count = 15) {
            const effectContainer = document.createElement('div');
            effectContainer.className = 'particle-effect';
            effectContainer.style.left = x + 'px';
            effectContainer.style.top = y + 'px';
            document.body.appendChild(effectContainer);

            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.backgroundColor = color;
                effectContainer.appendChild(particle);

                // Random direction and speed
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;

                // Random size
                const size = 2 + Math.random() * 4;
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';

                // Animate particle
                let posX = 0;
                let posY = 0;
                let opacity = 1;
                particle.style.opacity = opacity;

                const animate = () => {
                    posX += vx;
                    posY += vy;
                    opacity -= 0.02;

                    if (opacity <= 0) {
                        particle.remove();
                        return;
                    }

                    particle.style.transform = `translate(${posX}px, ${posY}px)`;
                    particle.style.opacity = opacity;

                    requestAnimationFrame(animate);
                };

                animate();
            }

            // Remove container after particles are done
            setTimeout(() => {
                if (effectContainer.parentNode) {
                    effectContainer.parentNode.removeChild(effectContainer);
                }
            }, 1000);
        }

        // Function to create placement effect
        function createPlacementEffect(x, y) {
            const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
                const rect = cell.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                createParticleEffect(centerX, centerY, '#66d9ff', 20);
            }
        }

        // Function to create enemy defeat effect
        function createEnemyDefeatEffect(x, y) {
            const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
                const rect = cell.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                createParticleEffect(centerX, centerY, '#ff5555', 25);
            }
        }

        // Reduced frequency resource collection effect
        let lastResourceEffectTime = 0;
        const RESOURCE_EFFECT_COOLDOWN = 2000; // 2 seconds cooldown

        function createResourceCollectionEffect(x, y, resourceType) {
            // Limit frequency of resource effects
            const now = Date.now();
            if (now - lastResourceEffectTime < RESOURCE_EFFECT_COOLDOWN) {
                return;
            }
            lastResourceEffectTime = now;

            const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
                const rect = cell.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let color;
                switch (resourceType) {
                    case 'Steel': color = '#aaaaaa'; break;
                    case 'coins': color = '#d4af37'; break;
                    case 'gold': color = '#ffcc00'; break;
                    default: color = '#66d9ff';
                }
                
                createParticleEffect(centerX, centerY, color, 5); // Reduced particle count
            }
        }

        const BUTTONS = [
            { id: 'place-wall', mode: 'wall', cost: { Steel: 10 } },
            { id: 'place-steel-wall', mode: 'wall-steel', cost: { Steel: 20 } },
            { id: 'place-spike', mode: 'wall-spike', cost: { Steel: 15 } },
            { id: 'place-fortress', mode: 'wall-fortress', cost: { gold: 25 } },
            { id: 'place-tech', mode: 'tech', cost: { Steel: 20 } },
            { id: 'place-gold-miner', mode: 'tech-goldminer', cost: { Steel: 25 } },
            { id: 'place-coin-maker', mode: 'tech-coinmaker', cost: { Steel: 30 } },
            { id: 'place-turret', mode: 'tech-turret', cost: { Steel: 40 } },
            { id: 'place-gold-turret', mode: 'tech-goldturret', cost: { gold: 15 } },
            { id: 'place-bomb', mode: 'tech-bomb', cost: { gold: 10 } },
            { id: 'place-supply', mode: 'tech-supply', cost: { gold: 35 } },
            { id: 'place-campfire', mode: 'tech-campfire', cost: { Steel: 30 } },
            { id: 'place-scout', mode: 'army-scout', cost: { coins: 15 } },
            { id: 'place-knight', mode: 'army-knight', cost: { coins: 25 } },
            { id: 'place-archer', mode: 'army-archer', cost: { coins: 20 } },
            { id: 'place-tank', mode: 'army-tank', cost: { coins: 50 } },
            { id: 'place-siege-tower', mode: 'army-siegetower', cost: { coins: 275 } },
            { id: 'place-king', mode: 'army-king', cost: { gold: 500 } },
            { id: 'place-barrack', mode: 'army-barrack', cost: { gold: 50 } }
        ];

        function setupEventListeners() {
            // Make folders draggable
            makeFoldersDraggable();

            document.querySelectorAll('[data-folder] .folder-title').forEach(function(title) {
                title.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const folder = title.closest('.folder');
                    const folderContent = folder.querySelector('.folder-content');
                    
                    // Toggle current folder
                    const isOpening = !folder.classList.contains('open');
                    folder.classList.toggle('open');
                    
                    // Position the folder content near the title if it's opening
                    if (isOpening) {
                        const rect = title.getBoundingClientRect();
                        folderContent.style.left = rect.left + 'px';
                        folderContent.style.top = (rect.bottom + 5) + 'px';
                    }
                });
            });

            // Handle close buttons
            document.querySelectorAll('.folder-close').forEach(function(button) {
                button.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const folder = button.closest('.folder');
                    folder.classList.remove('open');
                });
            });

            // Handle info icons
            document.querySelectorAll('.info-icon').forEach(function(icon) {
                icon.addEventListener('click', function(e) {
                    e.stopPropagation();
                    showInfoPopup(this.closest('.btn'));
                });
            });

            BUTTONS.forEach(function(buttonData) {
                const id = buttonData.id;
                const mode = buttonData.mode;
                const cost = buttonData.cost;
                const button = document.getElementById(id);
                if (button) {
                    button.dataset.mode = mode;
                    button.dataset.cost = JSON.stringify(cost);
                    button.addEventListener('click', function(e) {
                        e.stopPropagation();
                        gameState.placementMode = gameState.placementMode === mode ? null : mode;
                        updateButtonStates();
                        updateDisplay();
                    });
                }
            });

            document.getElementById('save-game').addEventListener('click', saveGame);
            document.getElementById('load-game').addEventListener('click', function() {
                document.getElementById('load-file').click();
            });
            document.getElementById('restart-game').addEventListener('click', restartGame);

            // Close popups when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.info-popup') && !e.target.closest('.info-icon')) {
                    closeInfoPopup();
                }
            });

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.id = 'load-file';
            fileInput.accept = '.coregrid';
            fileInput.style.display = 'none';
            fileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    loadGame(e.target.files[0]);
                }
            });
            document.body.appendChild(fileInput);
        }

        function showInfoPopup(button) {
            const infoData = button.dataset.info.split(',');
            const title = infoData[0];
            const description = infoData[1];
            const stats = infoData.slice(2);
            
            // Create overlay
            let overlay = document.querySelector('.info-popup-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'info-popup-overlay';
                document.body.appendChild(overlay);
            }
            
            // Create popup
            let popup = document.querySelector('.info-popup');
            if (!popup) {
                popup = document.createElement('div');
                popup.className = 'info-popup';
                document.body.appendChild(popup);
            }
            
            // Build popup content
            let statsHtml = '';
            stats.forEach(function(stat) {
                statsHtml += '<div class="info-popup-stat">' + stat + '</div>';
            });
            
            popup.innerHTML = `
                <div class="info-popup-header">
                    <div class="info-popup-title">${title}</div>
                    <button class="info-popup-close">×</button>
                </div>
                <div class="info-popup-content">
                    <p>${description}</p>
                    <div class="info-popup-stats">
                        ${statsHtml}
                    </div>
                </div>
            `;
            
            // Add close event
            popup.querySelector('.info-popup-close').addEventListener('click', closeInfoPopup);
            
            // Show popup and overlay
            overlay.style.display = 'block';
            popup.style.display = 'block';
        }

        function closeInfoPopup() {
            const overlay = document.querySelector('.info-popup-overlay');
            const popup = document.querySelector('.info-popup');
            
            if (overlay) overlay.style.display = 'none';
            if (popup) popup.style.display = 'none';
        }

        function makeFoldersDraggable() {
            document.querySelectorAll('.folder-content').forEach(function(folderContent) {
                const header = folderContent.querySelector('.folder-header');
                if (!header) return;
                
                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                let xOffset = 0;
                let yOffset = 0;

                header.addEventListener('mousedown', dragStart);
                document.addEventListener('mouseup', dragEnd);
                document.addEventListener('mousemove', drag);

                function dragStart(e) {
                    if (e.target.closest('.folder-close')) return; // Don't drag when clicking close button
                    
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    
                    isDragging = true;
                    header.style.cursor = 'grabbing';
                }

                function dragEnd() {
                    initialX = currentX;
                    initialY = currentY;
                    
                    isDragging = false;
                    header.style.cursor = 'move';
                }

                function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        
                        xOffset = currentX;
                        yOffset = currentY;
                        
                        setTranslate(currentX, currentY, folderContent);
                    }
                }

                function setTranslate(xPos, yPos, el) {
                    el.style.transform = 'translate3d(' + xPos + 'px, ' + yPos + 'px, 0)';
                }
            });
        }

        function restartGame() {
            if (confirm('Are you sure you want to restart the game?')) {
                gameState.reset();
                initGame();
            }
        }

        function saveGame() {
            const gameData = {
                resources: gameState.resources,
                turn: gameState.turn,
                wave: gameState.wave,
                waveBreakTurns: gameState.waveBreakTurns,
                inWaveBreak: gameState.inWaveBreak,
                enemiesRemaining: gameState.enemiesRemaining,
                grid: serializeGrid()
            };

            const blob = new Blob([JSON.stringify(gameData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `coregrid_save_${new Date().toISOString().slice(0, 10)}.coregrid`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('Game saved successfully!', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
        }

        function loadGame(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const gameData = JSON.parse(e.target.result);

                    if (!gameData.resources || !gameData.grid) {
                        throw new Error('Invalid save file');
                    }

                    gameState.resources = gameData.resources;
                    gameState.turn = gameData.turn;
                    gameState.wave = gameData.wave;
                    gameState.waveBreakTurns = gameData.waveBreakTurns || 0;
                    gameState.inWaveBreak = gameData.inWaveBreak || false;
                    gameState.enemiesRemaining = gameData.enemiesRemaining || 0;

                    deserializeGrid(gameData.grid);

                    showNotification('Game loaded successfully!', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
                    updateDisplay();
                } catch (error) {
                    showNotification('Error loading game: Invalid save file', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'danger');
                    console.error('Error loading game:', error);
                }
            };
            reader.readAsText(file);
        }

        function serializeGrid() {
            const gridData = [];
            for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                const row = [];
                for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                    const obj = gameState.grid[y][x];
                    if (obj === 'player') {
                        row.push('player');
                    } else if (obj && obj.type) {
                        row.push({
                            type: obj.type,
                            subtype: obj.subtype,
                            health: obj.health,
                            maxHealth: obj.maxHealth,
                            ...(obj.type === 'tech' && (obj.subtype === 'turret' || obj.subtype === 'goldturret') ? { shotsLeft: obj.shotsLeft } : {}),
                            ...(obj.type === 'army' && obj.subtype === 'barrack' ? { spawnCounter: obj.spawnCounter } : {})
                        });
                    } else {
                        row.push(null);
                    }
                }
                gridData.push(row);
            }
            return gridData;
        }

        function deserializeGrid(gridData) {
            gameState.grid = Array(CONFIG.GRID_SIZE_Y).fill().map(() => Array(CONFIG.GRID_SIZE_X).fill(null));
            gameState.objects.clear();

            for (let y = 0; y < CONFIG.GRID_SIZE_Y; y++) {
                for (let x = 0; x < CONFIG.GRID_SIZE_X; x++) {
                    const objData = gridData[y][x];
                    if (objData === 'player') {
                        gameState.grid[y][x] = 'player';
                    } else if (objData && objData.type) {
                        let obj;
                        switch (objData.type) {
                            case 'wall':
                                obj = new Wall(x, y, objData.subtype);
                                break;
                            case 'tech':
                                obj = new Tech(x, y, objData.subtype);
                                break;
                            case 'army':
                                obj = new Army(x, y, objData.subtype);
                                break;

                            case 'enemy':
                                obj = new Enemy(x, y, objData.subtype);
                                break;
                            default:
                                continue;
                        }

                        obj.health = objData.health;
                        obj.maxHealth = objData.maxHealth;

                        if (objData.type === 'tech' && (objData.subtype === 'turret' || objData.subtype === 'goldturret') && objData.shotsLeft) {
                            obj.shotsLeft = objData.shotsLeft;
                        }

                        if (objData.type === 'army' && objData.subtype === 'barrack' && objData.spawnCounter) {
                            obj.spawnCounter = objData.spawnCounter;
                        }

                        gameState.grid[y][x] = obj;
                        gameState.objects.set(obj.id, obj);
                    }
                }
            }
        }

        function debugNextWave() {
            console.log("Debug: Manually triggering next wave");
            spawnNextWave();
        }

        let cheatSequence = [];
        const targetSequence = ['i', 'l', 'f'];
        
        document.addEventListener('keydown', (event) => {
            cheatSequence.push(event.key.toLowerCase());
            
            if (cheatSequence.length > 3) {
                cheatSequence.shift();
            }
            
            if (cheatSequence.length === 3 && 
                cheatSequence[0] === targetSequence[0] &&
                cheatSequence[1] === targetSequence[1] &&
                cheatSequence[2] === targetSequence[2]) {
                
                gameState.resources.Steel += 7000;
                gameState.resources.coins += 7000;
                gameState.resources.gold += 7000;
                
                updateDisplay();
                
                showNotification('Cheat activated! +7000 Steel, Coins, and Gold', CONFIG.PLAYER_START.x, CONFIG.PLAYER_START.y, 'success');
                
                cheatSequence = [];
            }
        });

        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>

</html>